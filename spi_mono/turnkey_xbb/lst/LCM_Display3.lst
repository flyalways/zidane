C51 COMPILER V9.00   LCM_DISPLAY3                                                          07/09/2012 21:16:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LCM_DISPLAY3
OBJECT MODULE PLACED IN .\obj\LCM_Display3.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LCM\LCM_Display3.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsourc
                    -e\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\LCM_Display3.lst) OBJECT(.\obj\LCM_Display3.obj)

line level    source

   1          #include "..\Header\SPDA2K.h"
   2          #include "..\header\UI_config.h"
   3          #include "..\header\variables.h"
   4          #include "..\LCM\LCM_BMP.h"
   5          
   6          void LCM_ShowRepeatMenu(U8 tc_item)
   7          {
   8   1              data    U8      i;
   9   1              xdata   U8      *p;
  10   1      
  11   1              switch(tc_item)
  12   1              {
  13   2                      case 0: // 全部循環
  14   2                              p=gc_Str_RepeatAll[gc_CurrentHZK];
  15   2                      break;
  16   2      
  17   2                      case 1: // 普通播放
  18   2                              p=gc_Str_PlayAll[gc_CurrentHZK];
  19   2                      break;
  20   2      
  21   2                      case 2: // 單曲循環
  22   2                              p=gc_Str_Repeat1[gc_CurrentHZK];
  23   2                      break;
  24   2      
  25   2                      case 3: // 隨機播放
  26   2                              p=gc_Str_Random[gc_CurrentHZK];
  27   2                      break;
  28   2      
  29   2                      case 4: // 目錄循環
  30   2                              p=gc_Str_RepeatFolder[gc_CurrentHZK];
  31   2                      break;
  32   2      
  33   2                      case 5: // 目錄播放
  34   2                              p=gc_Str_Folder[gc_CurrentHZK];
  35   2                      break;
  36   2              }
  37   1      
  38   1              if(tc_item==gc_RepeatMenuNum)
  39   1              {
  40   2                      gb_LCM_InverseDisp=1;   
  41   2              }
  42   1      
  43   1              for(i=0;i<p[0];i++)
  44   1              {
  45   2                      gc_LrcDisplayBuf[i]=p[1+i];
  46   2              }
  47   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,(tc_item%4)*16,1);
  48   1              gb_LCM_InverseDisp=0;
  49   1      }
  50          
  51          
  52          void LCM_ShowEQMenu(U8 tc_item)
  53          {
  54   1              data    U8      i;
C51 COMPILER V9.00   LCM_DISPLAY3                                                          07/09/2012 21:16:49 PAGE 2   

  55   1              xdata   U8      *p;
  56   1      
  57   1              switch(tc_item)
  58   1              {
  59   2                      case 0: // NORMAL
  60   2                              p=gc_Str_Natural[gc_CurrentHZK];
  61   2                      break;
  62   2      
  63   2                      case 1: // DBB
  64   2                              p=gc_Str_DBB[gc_CurrentHZK];
  65   2                      break;
  66   2      
  67   2                      case 2: // JAZZ
  68   2                              p=gc_Str_JAZZ[gc_CurrentHZK];
  69   2                      break;
  70   2      
  71   2                      case 3: // ROCK
  72   2                              p=gc_Str_ROCK[gc_CurrentHZK];
  73   2                      break;
  74   2      
  75   2                      case 4: // POP
  76   2                              p=gc_Str_POP[gc_CurrentHZK];
  77   2                      break;
  78   2      
  79   2                      case 5: // Classic
  80   2                              p=gc_Str_Classic[gc_CurrentHZK];
  81   2                      break;
  82   2              }
  83   1              if(tc_item==gs_DSP_GLOBAL_RAM.sc_EQ_Type)
  84   1              {
  85   2                      gb_LCM_InverseDisp=1;   
  86   2              }
  87   1      
  88   1              for(i=0;i<p[0];i++)
  89   1              {
  90   2                      gc_LrcDisplayBuf[i]=p[1+i];
  91   2              }
  92   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,(tc_item%4)*16,1);
  93   1              gb_LCM_InverseDisp=0;
  94   1      }
  95          
  96          void LCM_ShowFMMenu(U8 tc_item)
  97          {
  98   1              data    U8      i;
  99   1              xdata   U8      *p;
 100   1      
 101   1              switch(tc_item)
 102   1              {
 103   2                      case 0: // Record
 104   2                              p=gc_Str_Record[gc_CurrentHZK];
 105   2                      break;
 106   2      
 107   2                      case 1: // Save channel
 108   2                              p=gc_Str_SaveCH[gc_CurrentHZK];
 109   2                      break;
 110   2      
 111   2                      case 2: // Delete channel
 112   2                              p=gc_Str_DelCH[gc_CurrentHZK];
 113   2                      break;
 114   2      
 115   2                      case 3: // Delete all
 116   2                              p=gc_Str_DelAll[gc_CurrentHZK];
C51 COMPILER V9.00   LCM_DISPLAY3                                                          07/09/2012 21:16:49 PAGE 3   

 117   2                      break;
 118   2      
 119   2                      case 4: // Order record
 120   2                              p=gc_Str_OrderRecord[gc_CurrentHZK];
 121   2                      break;
 122   2      
 123   2                      case 5: // Quality
 124   2                              p=gc_Str_Quality[gc_CurrentHZK];
 125   2                      break;
 126   2      
 127   2                      case 6: // Exit
 128   2                              p=gc_Str_Exit1[gc_CurrentHZK];
 129   2                      break;
 130   2              }
 131   1              if(tc_item==gc_FMMenuNum)
 132   1              {
 133   2                      gb_LCM_InverseDisp=1;   
 134   2              }
 135   1      
 136   1              for(i=0;i<p[0];i++)
 137   1              {
 138   2                      gc_LrcDisplayBuf[i]=p[1+i];
 139   2              }
 140   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,(tc_item%4)*16,1);
 141   1              gb_LCM_InverseDisp=0;
 142   1      }
 143          
 144          void LCM_ShowFMMenu_Quality(U8 tc_item)
 145          {
 146   1              data    U8      i;
 147   1              xdata   U8      *p;
 148   1      
 149   1              switch(tc_item)
 150   1              {
 151   2                      case 0: // Low
 152   2                              p=gc_Str_Low[gc_CurrentHZK];
 153   2                      break;
 154   2      
 155   2                      case 1: // Middle
 156   2                              p=gc_Str_Middle[gc_CurrentHZK];
 157   2                      break;
 158   2      
 159   2                      case 2: // High
 160   2                              p=gc_Str_High[gc_CurrentHZK];
 161   2                      break;
 162   2              }
 163   1              if(tc_item==gc_RecordQuality)
 164   1              {
 165   2                      gb_LCM_InverseDisp=1;   
 166   2              }
 167   1      
 168   1              for(i=0;i<p[0];i++)
 169   1              {
 170   2                      gc_LrcDisplayBuf[i]=p[1+i];
 171   2              }
 172   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,(tc_item%4)*16,1);
 173   1              gb_LCM_InverseDisp=0;
 174   1      }
 175          
 176          void LCM_ShowUSBConnectIcon(void)
 177          {
 178   1          xdata       U16     i;
C51 COMPILER V9.00   LCM_DISPLAY3                                                          07/09/2012 21:16:49 PAGE 4   

 179   1              data    U8      j;
 180   1              xdata   U16     tw_Addr;
 181   1      
 182   1              tw_Addr=PCIcon128x32;
 183   1              LCM_ReadSPIBMPdata(tw_Addr,512);
 184   1              for(j=0;j<4;j++)
 185   1              {
 186   2                      LCM_set_address(j+2,0);
 187   2      
 188   2                      for(i=0;i<128;i++)
 189   2                      {
 190   3                              LCM_write_data(gc_DirLCMtempBuf[((U16)j*128)+i]);
 191   3                      }
 192   2              }
 193   1      }
 194          
 195          void LCM_ShowFrequency_L()      // 12x32
 196          {
 197   1              data    U16 tw_FM_frequency;
 198   1      
 199   1              tw_FM_frequency=gw_FM_frequency;
 200   1              if(tw_FM_frequency>999)
 201   1              {
 202   2                      LCM_ShowChar12x32(1,16);
 203   2              }
 204   1              else
 205   1              {
 206   2                      LCM_ShowChar12x32(31,16);
 207   2              }
 208   1              LCM_ShowChar12x32((tw_FM_frequency%1000)/100,28);
 209   1              LCM_ShowChar12x32((tw_FM_frequency%100)/10,40);
 210   1              LCM_ShowChar12x32(32,52);       // "."
 211   1              LCM_ShowChar12x32(tw_FM_frequency%10,60);
 212   1              LCM_ShowChar12x32(21,72);       // M
 213   1              LCM_ShowChar12x32(17,84);       // H
 214   1              LCM_ShowChar12x32(30,96);       // z    
 215   1      }
 216          
 217          void LCM_ShowRecordString(void)
 218          {
 219   1              data    U8      i;
 220   1              xdata   U8      *p;
 221   1      
 222   1              p=gc_Str_Record[gc_CurrentHZK];
 223   1              for(i=0;i<p[0];i++)
 224   1              {
 225   2                      gc_LrcDisplayBuf[i]=p[1+i];
 226   2              }
 227   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,0,1);
 228   1      }
 229          
 230          void LCM_ShowStartTimeString(void)
 231          {
 232   1              data    U8      i;
 233   1              xdata   U8      *p;
 234   1      
 235   1              p=gc_Str_Start[gc_CurrentHZK];
 236   1              for(i=0;i<p[0];i++)
 237   1              {
 238   2                      gc_LrcDisplayBuf[i]=p[1+i];
 239   2              }
 240   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,16,1);
C51 COMPILER V9.00   LCM_DISPLAY3                                                          07/09/2012 21:16:49 PAGE 5   

 241   1      }
 242          
 243          void LCM_ShowDurationString(void)
 244          {
 245   1              data    U8      i;
 246   1              xdata   U8      *p;
 247   1      
 248   1              p=gc_Str_Duration[gc_CurrentHZK];
 249   1              for(i=0;i<p[0];i++)
 250   1              {
 251   2                      gc_LrcDisplayBuf[i]=p[1+i];
 252   2              }
 253   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,32,1);
 254   1      }
 255          
 256          void LCM_ShowRecONOFFString(void)
 257          {
 258   1              data    U8      i;
 259   1              xdata   U8      *p;
 260   1      
 261   1              if(gb_OrderRecord==1)
 262   1              {
 263   2                      p=gc_Str_ON[gc_CurrentHZK];
 264   2              }
 265   1              else
 266   1              {
 267   2                      p=gc_Str_OFF[gc_CurrentHZK];
 268   2              }
 269   1              for(i=0;i<p[0];i++)
 270   1              {
 271   2                      gc_LrcDisplayBuf[i]=p[1+i];
 272   2              }
 273   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],70,0,0);
 274   1      }
 275          
 276          void LCM_ShowAlarmONOFFString(void)
 277          {
 278   1              data    U8      i;
 279   1              xdata   U8      *p;
 280   1      
 281   1              if(gb_AlarmON==1)
 282   1              {
 283   2                      p=gc_Str_ON[gc_CurrentHZK];
 284   2              }
 285   1              else
 286   1              {
 287   2                      p=gc_Str_OFF[gc_CurrentHZK];
 288   2              }
 289   1              for(i=0;i<p[0];i++)
 290   1              {
 291   2                      gc_LrcDisplayBuf[i]=p[1+i];
 292   2              }
 293   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],70,0,0);
 294   1      }
 295          
 296          void LCM_ShowAlarmRepeatONOFFString(void)
 297          {
 298   1              data    U8      i;
 299   1              xdata   U8      *p;
 300   1      
 301   1              if(gb_AlarmRepeatON==1)
 302   1              {
C51 COMPILER V9.00   LCM_DISPLAY3                                                          07/09/2012 21:16:49 PAGE 6   

 303   2                      p=gc_Str_ON[gc_CurrentHZK];
 304   2              }
 305   1              else
 306   1              {
 307   2                      p=gc_Str_OFF[gc_CurrentHZK];
 308   2              }
 309   1              for(i=0;i<p[0];i++)
 310   1              {
 311   2                      gc_LrcDisplayBuf[i]=p[1+i];
 312   2              }
 313   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],70,32,0);
 314   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1243    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      35
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      13
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
