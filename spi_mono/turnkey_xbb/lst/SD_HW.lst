C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SD_HW
OBJECT MODULE PLACED IN .\obj\SD_HW.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SD\SD_HW.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource\header
                    -) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\SD_HW.lst) OBJECT(.\obj\SD_HW.obj)

line level    source

   1          #include "..\header\SPDA2K.h"
   2          #include "..\header\variables.h"
   3          
   4          
   5          void  SD_CMD0_Reset(void)
   6          {
   7   1          XBYTE[0xB45B]=0x40;
   8   1          XBYTE[0xB45C]=0x00;
   9   1          XBYTE[0xB45D]=0x00;
  10   1          XBYTE[0xB45E]=0x00;
  11   1          XBYTE[0xB45F]=0x00;
  12   1          SD_Trigger_CMD();
  13   1          SD_Check_Idle();
  14   1              SD_Send_DummyCLK(1);    // 8 clks before send cmd
  15   1      }
  16          
  17          
  18          void SD_CMD55_PreACmd(void)
  19          {
  20   1              XBYTE[0xB45B]=0x40+55;
  21   1              XBYTE[0xB45C]=SDMMC_SDRCA.BY[0];
  22   1              XBYTE[0xB45D]=SDMMC_SDRCA.BY[1];
  23   1              XBYTE[0xB45E]=0x00;
  24   1              XBYTE[0xB45F]=0x00;
  25   1              SD_Trigger_CMD();
  26   1              SD_Check_Idle();
  27   1              SD_Receive_Respond(gc_SDRespBuff,0,0); 
  28   1      }    
  29          
  30          
  31          bit SD_ACmd41_OCR(void)
  32          {
  33   1              data    U16     tw_SD_CountDown;
  34   1              
  35   1              tw_SD_CountDown=12000;  
  36   1              
  37   1              do{     
  38   2                      SD_CMD55_PreACmd();
  39   2                      XBYTE[0xB45B]=0x40+41;
  40   2                      if(gb_SDHC_Type)
  41   2                      {       
  42   3                              XBYTE[0xB45C]=0x40;
  43   3                      }
  44   2                      else
  45   2                      {
  46   3                              XBYTE[0xB45C]=0x00;
  47   3                      }       
  48   2                      XBYTE[0xB45D]=0xFC;
  49   2                      XBYTE[0xB45E]=0x00;
  50   2                      XBYTE[0xB45F]=0x00;
  51   2                      SD_Trigger_CMD();
  52   2                      SD_Check_Idle();
  53   2                      SD_Receive_Respond(gc_SDRespBuff,0,0);
  54   2                      if(gb_SD_pin)
C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 2   

  55   2                      {                              // card out 
  56   3                              return 0;
  57   3                      }    
  58   2              if((--tw_SD_CountDown==0))
  59   2                      {       
  60   3                        return 0;
  61   3                      }
  62   2              }while(!(gc_SDRespBuff[1]&0x80)); 
  63   1              
  64   1              if(gb_SDHC_Type)
  65   1              {
  66   2                      if(gc_SDRespBuff[1]&0x40)
  67   2                      {
  68   3                              gb_SDHC_Type=1;                                                         // High Capacity
  69   3                      }
  70   2                      else
  71   2                      {
  72   3                              gb_SDHC_Type=0;                                                         // Standard Capicity
  73   3                      }
  74   2              }
  75   1              return 1;   
  76   1      }    
  77          
  78          
  79          void SD_Cmd2_CID(void)
  80          {
  81   1              XBYTE[0xB45B]=0x40+2;
  82   1              XBYTE[0xB45C]=0x00;
  83   1              XBYTE[0xB45D]=0x00;
  84   1              XBYTE[0xB45E]=0x00;
  85   1              XBYTE[0xB45F]=0x00;
  86   1              SD_Trigger_CMD();
  87   1              SD_Check_Idle();
  88   1              SD_Receive_Respond(gc_SDRespBuff,1,0);                // 136 bit    
  89   1      } 
  90          
  91          
  92          void SD_Cmd3_RCA(void)
  93          {
  94   1          if(gb_MMC_Type)
  95   1              {
  96   2              SDMMC_SDRCA.BY[0]=0x1F;
  97   2              SDMMC_SDRCA.BY[1]=0x3C;
  98   2          }
  99   1          else
 100   1              {
 101   2              SDMMC_SDRCA.BY[0]=0x00;
 102   2              SDMMC_SDRCA.BY[1]=0x00;
 103   2          }
 104   1          XBYTE[0xB45B]=0x40+3;
 105   1          XBYTE[0xB45C]=SDMMC_SDRCA.BY[0];
 106   1          XBYTE[0xB45D]=SDMMC_SDRCA.BY[1];
 107   1          XBYTE[0xB45E]=0x00;
 108   1          XBYTE[0xB45F]=0x00;
 109   1          SD_Trigger_CMD();
 110   1          SD_Check_Idle();
 111   1          SD_Receive_Respond(gc_SDRespBuff,0,0);                // 48 bit 
 112   1          if(!gb_MMC_Type)
 113   1              {
 114   2              SDMMC_SDRCA.BY[0]=gc_SDRespBuff[1];
 115   2              SDMMC_SDRCA.BY[1]=gc_SDRespBuff[2];
 116   2          }  
C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 3   

 117   1      }
 118          
 119          
 120          void SD_Cmd8_Send_If_Cond(void)
 121          { 
 122   1              XBYTE[0xB45B]=0x40+8;
 123   1              XBYTE[0xB45C]=0x00;
 124   1              XBYTE[0xB45D]=0x00;
 125   1              XBYTE[0xB45E]=0x01;
 126   1              XBYTE[0xB45F]=0xAA;
 127   1              SD_Trigger_CMD();
 128   1              SD_Check_Idle();
 129   1              if(SD_Receive_Respond(gc_SDRespBuff,0,0))
 130   1              {       // Time out -->No Responce 
 131   2                      gb_SDHC_Type=0; // 0:Stand Capacity , 1: High Capicity
 132   2              }
 133   1              else
 134   1              {
 135   2                      gb_SDHC_Type=1; // 0:Stand Capacity , 1: High Capicity
 136   2              }
 137   1      }
 138          
 139          
 140          void SD_Cmd9_CSD(void)
 141          {
 142   1          data        U8      tc_ReadBl_Len;
 143   1              data    U8      tc_CSizeMult;   
 144   1              data    U16     tw_Mult;
 145   1              data    U16     tw_BlockLen;
 146   1              data    U16     tw_CSize;
 147   1          xdata       U8      tc_Counter;
 148   1              xdata   U32     tdw_CardTotalSize;
 149   1          xdata       U32     tdw_SD_BlockNum;    
 150   1          
 151   1          XBYTE[0xB45B]=0x40+9;
 152   1          XBYTE[0xB45C]=SDMMC_SDRCA.BY[0];
 153   1          XBYTE[0xB45D]=SDMMC_SDRCA.BY[1];
 154   1          XBYTE[0xB45E]=0x00;
 155   1          XBYTE[0xB45F]=0x00;
 156   1          SD_Trigger_CMD();
 157   1          SD_Check_Idle();
 158   1          SD_Receive_Respond(gc_SDRespBuff,1,0);                // 136 bit  
 159   1         
 160   1          for(tc_Counter=0;tc_Counter<16;tc_Counter++)
 161   1              {
 162   2              gc_SD_CSD[tc_Counter]=gc_SDRespBuff[tc_Counter+1];
 163   2          }
 164   1          
 165   1          if(gb_MMC_Type)
 166   1              {
 167   2              tc_ReadBl_Len=gc_SD_CSD[0x05]&0x0f;     
 168   2              tw_BlockLen=0x01<<(tc_ReadBl_Len);// 直接轉成sector
 169   2                      tw_CSize=(gc_SD_CSD[6]&0X03)<<10;
 170   2                      tw_CSize=tw_CSize|(gc_SD_CSD[7]<<2);
 171   2                      tw_CSize=tw_CSize|(gc_SD_CSD[8]>>6);
 172   2                      tc_CSizeMult=((gc_SD_CSD[9]&0x03)<<1)|(gc_SD_CSD[10]>>7); 
 173   2                      tw_Mult=0x0001<<(tc_CSizeMult+2);
 174   2                      tdw_SD_BlockNum=((U32)(tw_CSize+1)*tw_Mult);              
 175   2                      tdw_CardTotalSize=(U32)(tdw_SD_BlockNum*tw_BlockLen);
 176   2                      if(gb_SDHC_Type)
 177   2                      {
 178   3                              SD_Capacity.LW=(tdw_CardTotalSize);  // 直接就是Sector 
C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 4   

 179   3                      }
 180   2                      else
 181   2                      {
 182   3                              SD_Capacity.LW=(tdw_CardTotalSize>>9); 
 183   3              }       
 184   2          }
 185   1          else
 186   1              {       
 187   2              if((gc_SD_CSD[0x00]&0xC0)==0x40)
 188   2                      {//SD2.0 or High Capicity        
 189   3                              tdw_CardTotalSize=((gc_SD_CSD[7]&0x3F)<<16)|(gc_SD_CSD[8]<<8)|gc_SD_CSD[9];
 190   3                              SD_Capacity.LW=(tdw_CardTotalSize+1)<<10 ;    
 191   3              }
 192   2              else
 193   2                      {   //SD1.1 or Standard Capicity    
 194   3                      tc_ReadBl_Len=gc_SD_CSD[0x05]&0x0f;     
 195   3                      tw_BlockLen=0x01<<(tc_ReadBl_Len);// 直接轉成sector
 196   3                              tw_CSize=(gc_SD_CSD[6]&0X03)<<10;
 197   3                              tw_CSize=tw_CSize|(gc_SD_CSD[7]<<2);
 198   3                              tw_CSize=tw_CSize|(gc_SD_CSD[8]>>6);
 199   3                              tc_CSizeMult=((gc_SD_CSD[9]&0x03)<<1)|(gc_SD_CSD[10]>>7); 
 200   3                              tw_Mult=0x0001<<(tc_CSizeMult+2);
 201   3                              tdw_SD_BlockNum=((U32)(tw_CSize+1)*tw_Mult);              
 202   3                              tdw_CardTotalSize=(U32)(tdw_SD_BlockNum*tw_BlockLen);
 203   3                              SD_Capacity.LW=(tdw_CardTotalSize>>9);    
 204   3                      }
 205   2              }
 206   1              gdw_CARD_TotalSizeMB=SD_Capacity.LW-1;
 207   1      } 
 208          
 209          
 210          void SD_Trigger_CMD(void)
 211          {
 212   1              SD_Send_DummyCLK(1);
 213   1          SD_Check_Idle();
 214   1          XBYTE[0xB450]=0x03; // reset crc                       
 215   1          XBYTE[0xB452]=0x01; // send command  
 216   1      }
 217          
 218          
 219          bit  SD_Identification_Flow(void)
 220          {   
 221   1              // SD Interface Initial
 222   1              XBYTE[0xB400]=0x06;             // switch to sd interface
 223   1              XBYTE[0xB450]=0x03;             // reset sd & crc interface;
 224   1              XBYTE[0xB451]=0x03;             // set SD CLK  1/128 per clk,1 bit mode  
 225   1          XBYTE[0xB456]=0x02;
 226   1              XBYTE[0xB457]=0xFF;             // set rsp time out
 227   1              XBYTE[0xB458]=0xFF;             // crc time out 
 228   1              SDMMC_SDRCA.WD=0x0000;  // default RCA is 0 
 229   1              SD_Capacity.LW=0x0001; 
 230   1              gb_SDHC_Type=0;                 // 0:Stand Capacity , 1: High Capicity
 231   1              gb_MMC_Type=0;                  // 0:SD , 1: MMC
 232   1              gc_HostSectorUnit=1;
 233   1      
 234   1              if(gb_SD_pin)
 235   1              {
 236   2                      goto RET;
 237   2              }
 238   1          SD_Send_DummyCLK(8);  // send 64 clk 
 239   1              SD_CMD0_Reset();
 240   1              if(gb_SD_pin)
C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 5   

 241   1              {
 242   2                      goto RET;
 243   2              } 
 244   1              
 245   1              SD_MMC_Check_Mode();
 246   1              if(gb_SD_pin)
 247   1              {
 248   2                      goto RET;
 249   2              }
 250   1              
 251   1              if(gb_MMC_Type)
 252   1              {//MMC card
 253   2                      SD_CMD0_Reset();
 254   2              if(MMC_Cmd01_OCR_Wait_Ready()==0)
 255   2                      {
 256   3                              goto RET;
 257   3                      }
 258   2                      XBYTE[0xB451] |=0x40;  // MMC mode      
 259   2              }
 260   1              else
 261   1              {       // SD card 
 262   2                      SD_CMD0_Reset();
 263   2                      SD_Cmd8_Send_If_Cond();   
 264   2              if(SD_ACmd41_OCR()==0)
 265   2                      {
 266   3                              goto RET;
 267   3                      }
 268   2              }
 269   1              
 270   1              SD_Cmd2_CID();
 271   1              if(gb_SD_pin)
 272   1              {
 273   2                      goto RET;
 274   2              }
 275   1              
 276   1              SD_Cmd3_RCA();          // get RCA
 277   1              if(gb_SD_pin)
 278   1              {
 279   2                      goto RET;
 280   2              }   
 281   1              
 282   1              SD_Cmd9_CSD();     // det CSD
 283   1              if(gb_SD_pin)
 284   1              {
 285   2                      goto RET;
 286   2              }
 287   1              
 288   1              SD_Cmd13_Status();
 289   1              if(gb_SD_pin)
 290   1              {
 291   2                      goto RET;
 292   2              }
 293   1              
 294   1              SD_Cmd7_Select();// pust to transfer stat
 295   1              if(gb_SD_pin)
 296   1              {
 297   2                      goto RET;
 298   2              }       
 299   1              
 300   1              if(!gb_MMC_Type)
 301   1              {       
 302   2                      XBYTE[0xB451]|= 0x04;  // set 4bit mode
C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 6   

 303   2                      SD_ACmd6_BusWidth(1);   // form 1 bit to 4 bit
 304   2              }   
 305   1              XBYTE[0xB451]&=0xFD;
 306   1              XBYTE[0xB456]|=0xA0;    
 307   1              SD_Cmd16_Blocklen();    // set 512 block length
 308   1              if(gb_SD_pin)
 309   1              {
 310   2                      goto RET;
 311   2              }       
 312   1              return 1; 
 313   1      RET:
 314   1              USER_Delay(200);
 315   1              return 0;
 316   1      }
 317          
 318          
 319          void SD_Cmd7_Select(void)
 320          {
 321   1              XBYTE[0xB45B]=0x40+7;
 322   1              XBYTE[0xB45C]=SDMMC_SDRCA.BY[0];
 323   1              XBYTE[0xB45D]=SDMMC_SDRCA.BY[1];
 324   1              XBYTE[0xB45E]=0x00;
 325   1              XBYTE[0xB45F]=0x00;
 326   1              SD_Trigger_CMD();
 327   1              SD_Check_Idle();
 328   1              SD_Receive_Respond(gc_SDRespBuff,0,0);  // 48 bit    
 329   1      }                              
 330          
 331          
 332          void SD_Cmd13_Status(void)
 333          {
 334   1              XBYTE[0xB45B]=0x40+13;
 335   1              XBYTE[0xB45C]=SDMMC_SDRCA.BY[0];
 336   1              XBYTE[0xB45D]=SDMMC_SDRCA.BY[1];
 337   1              XBYTE[0xB45E]=0x00;
 338   1              XBYTE[0xB45F]=0x00;
 339   1              SD_Trigger_CMD();
 340   1              SD_Check_Idle();
 341   1              SD_Receive_Respond(gc_SDRespBuff,0,0);  // 48 bit        
 342   1      }
 343          
 344          
 345          void SD_ACmd6_BusWidth(bit _4bit)
 346          {
 347   1          SD_CMD55_PreACmd();
 348   1          XBYTE[0xB45B]=0x40+6;
 349   1          XBYTE[0xB45C]=0x00;
 350   1          XBYTE[0xB45D]=0x00;
 351   1          XBYTE[0xB45E]=0x00;
 352   1              XBYTE[0xB45F]=((U8)_4bit)<<1;
 353   1          SD_Trigger_CMD();
 354   1          SD_Check_Idle();
 355   1          SD_Receive_Respond(gc_SDRespBuff,0,0);      // 48 bit    
 356   1      }
 357          
 358          void SD_Cmd16_Blocklen(void)
 359          {
 360   1          XBYTE[0xB45B]=0x40+16;
 361   1          XBYTE[0xB45C]=0x00;
 362   1          XBYTE[0xB45D]=0x00;
 363   1          XBYTE[0xB45E]=0x02;
 364   1          XBYTE[0xB45F]=0x00;
C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 7   

 365   1          SD_Trigger_CMD();
 366   1          SD_Check_Idle();
 367   1          SD_Receive_Respond(gc_SDRespBuff,0,0);      // 48 bit    
 368   1              XBYTE[0xB455]=0x00;
 369   1              XBYTE[0xB456]|=0x02;
 370   1      }
 371          
 372          U8 SD_Receive_Respond(U8 *tc_RespBuff,U8 tc_Resptype136bit,U8 tc_CRC)
 373          { 
 374   1              data    U8      tc_FullFlag;
 375   1              data    U8      tc_CRC7;
 376   1              data    U8      tc_i;
 377   1              data    U8      tc_SD_CountDown;     
 378   1      
 379   1              tc_SD_CountDown=0;
 380   1              if(tc_Resptype136bit)
 381   1              {       
 382   2                      XBYTE[0xB451]|=0x08;                    
 383   2              }
 384   1              else
 385   1              {       
 386   2                      XBYTE[0xB451]&=0xF7;
 387   2              }       
 388   1              XBYTE[0xB457]=0xFF; 
 389   1              XBYTE[0xB456]|=0x20; // auto send dummy clk
 390   1              XBYTE[0xB452]=0x02;
 391   1              do
 392   1              {
 393   2                      tc_FullFlag=(XBYTE[0xB453]&0x02);
 394   2                      if((XBYTE[0xB453]&0x40)||(--tc_SD_CountDown==0))
 395   2                      {
 396   3                              XBYTE[0xB450]=0x03;     
 397   3                              return 1;     // Time out
 398   3                      }               
 399   2              }while((tc_FullFlag==0));
 400   1              //48bit
 401   1              tc_RespBuff[0]=XBYTE[0xB460];
 402   1              tc_RespBuff[1]=XBYTE[0xB461];
 403   1              tc_RespBuff[2]=XBYTE[0xB462];
 404   1              tc_RespBuff[3]=XBYTE[0xB463];
 405   1              tc_RespBuff[4]=XBYTE[0xB464];
 406   1              tc_RespBuff[5]=XBYTE[0xB465];   
 407   1              tc_CRC7=tc_RespBuff[5];
 408   1              if(tc_Resptype136bit)   //136 bit
 409   1              {
 410   2                      for(tc_i=0;tc_i<11;tc_i++) 
 411   2                      {
 412   3                              do
 413   3                              {
 414   4                                      tc_FullFlag=(XBYTE[0xB453]&0x02);
 415   4                                      if((XBYTE[0xB453]&0x40)||(--tc_SD_CountDown==0))
 416   4                                      {
 417   5                                              XBYTE[0xB450] =0x03;    
 418   5                                              return 1;     // Time out
 419   5                                      }               
 420   4                              }while((tc_FullFlag==0));               
 421   3                              tc_RespBuff[6+tc_i]=XBYTE[0xB465];              
 422   3                      }
 423   2                      tc_CRC7=tc_RespBuff[16];
 424   2              }
 425   1              if((tc_CRC7!=XBYTE[0xB466])&&tc_CRC)
 426   1              {//CRC error
C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 8   

 427   2                      XBYTE[0xB450]=0x03;
 428   2                      return 1;               
 429   2              }       
 430   1              return 0;       
 431   1      } 
 432          
 433          
 434          void  SD_MMC_Check_Mode(void)
 435          {
 436   1              SD_CMD0_Reset();
 437   1              if(MMC_Cmd01_OCR())
 438   1              {   // By CMD1     
 439   2                      gb_MMC_Type =1;  // MMC Mode
 440   2              }
 441   1              else
 442   1              {
 443   2                      gb_MMC_Type =0;  //SD Mode
 444   2              }
 445   1              SD_Send_DummyCLK(8);         
 446   1      }
 447          
 448          
 449          bit MMC_Cmd01_OCR(void)
 450          {
 451   1              XBYTE[0xB45B]=0x40+1;
 452   1              XBYTE[0xB45C]=0x80;
 453   1              XBYTE[0xB45D]=0xFF;     //2.7~3.6 Volt
 454   1              XBYTE[0xB45E]=0x00;
 455   1              XBYTE[0xB45F]=0x00;
 456   1              SD_Trigger_CMD();
 457   1              SD_Check_Idle();
 458   1              if(SD_Receive_Respond(gc_SDRespBuff,0,0))
 459   1              {
 460   2                      return 0;
 461   2              }
 462   1              else
 463   1              {               
 464   2                      return 1;               
 465   2              } 
 466   1      }
 467          
 468          
 469          bit MMC_Cmd01_OCR_Wait_Ready(void)
 470          {    
 471   1              U16 tw_SD_CountDown;
 472   1      
 473   1              tw_SD_CountDown=PseudoCard_TimeOut;     
 474   1      
 475   1              do{
 476   2                      XBYTE[0xB45B]=0x40+1;
 477   2              XBYTE[0xB45C]=0x80;
 478   2              XBYTE[0xB45D]=0xFF;
 479   2              XBYTE[0xB45E]=0x00;
 480   2              XBYTE[0xB45F]=0x00;
 481   2                      SD_Trigger_CMD();
 482   2              SD_Check_Idle();
 483   2              SD_Receive_Respond(gc_SDRespBuff,0,0);
 484   2              if(gb_SD_pin)
 485   2                      {                              // card out 
 486   3                      return 0;
 487   3              }    
 488   2              if((--tw_SD_CountDown==0))
C51 COMPILER V9.00   SD_HW                                                                 07/09/2012 21:16:54 PAGE 9   

 489   2                      {
 490   3                return 0;
 491   3              }
 492   2          }while(!(gc_SDRespBuff[1]&0x80)); 
 493   1         
 494   1          if(gc_SDRespBuff[1]&0x40)
 495   1              {
 496   2              gb_SDHC_Type =1;                                                                        // High Capacity MMC Sector mode        
 497   2          }
 498   1          else
 499   1              {
 500   2              gb_SDHC_Type =0;                                                                        // Standard Capicity   MMC Byte mode
 501   2          }   
 502   1          return 1;       
 503   1      } 
 504          
 505           


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1326    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      15
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
