C51 COMPILER V9.00   ALARMCLOCK                                                            07/09/2012 21:16:51 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ALARMCLOCK
OBJECT MODULE PLACED IN .\obj\AlarmClock.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE MAIN\AlarmClock.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource
                    -\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\AlarmClock.lst) OBJECT(.\obj\AlarmClock.obj)

line level    source

   1          #include "..\header\SPDA2K.h"
   2          #include "..\header\UI_config.h"
   3          #include "..\header\variables.h"
   4          
   5          void AlarmMusic(void)
   6          {
   7   1              data    U8      tc_timeout;
   8   1      
   9   1              gb_AlarmTrigger=0;
  10   1              gw_AlarmClockTimer=300; // Alarm clock sound duration(Unit:Sec)
  11   1              MP3_Download(); // Download DSP code
  12   1              L2_DSP_Write_DMem16(DSP_PostProcessSelect,L2_DSP_Read_DMem16(DSP_PostProcessSelect)|0x0020);
  13   1              tc_timeout=0xFF;
  14   1              while((L2_DSP_Read_DMem16(DSP_PostProcessSelect)&0x0020))  //Handshake with DSP to make sure that DSP has
             - ramp digital volume up.
  15   1              {
  16   2                      if(!(tc_timeout--))
  17   2                      {
  18   3                              break;
  19   3                      }
  20   2              }
  21   1      
  22   1              Music_PlayCmd();
  23   1              L2_DSP_Write_DMem16(DSP_VolumeControl,25);      // Set Volume
  24   1              gc_GetSPIdataSectorNumber=0;
  25   1              while(1)
  26   1              {
  27   2                      if(L2_DSP_Read_DMem16(DSP_EmptyBuffer)>511)
  28   2                      {
  29   3                              AlarmMusic_DataIn();
  30   3                      }
  31   2      
  32   2                      Key_Detect();
  33   2                      if(gc_KeyEvent==2||gw_AlarmClockTimer==0)
  34   2                      {
  35   3                              Music_StopCmd(0);
  36   3                              gb_Mp3FileEnd=1;
  37   3                              gc_KeyEvent=0;
  38   3                              break;
  39   3                      }
  40   2              }
  41   1              gc_Task_Current=gc_Task_Last;
  42   1      }
  43          
  44          void AlarmMusic_DataIn(void)
  45          {
  46   1              xdata   U8  tc_DSPAddr_High;
  47   1              data    U16 tw_DSP_Word_Align;
  48   1              xdata   U16     tw_SmpRateIdx;
  49   1              code    U16     gw_DSP_Addr_Table[3]={0x0000,0x80aa,0x4155};
  50   1      
  51   1              GetAlarmData();
  52   1              // ----- DMA Reset -----
  53   1              XBYTE[0xB304] = 0x09;
C51 COMPILER V9.00   ALARMCLOCK                                                            07/09/2012 21:16:51 PAGE 2   

  54   1              XBYTE[0xB304] = 0x08;
  55   1              XBYTE[0xB3C0] = 0x00;           // clear DMA complete
  56   1              XBYTE[0xB330] = 0x01;           // clear checksum
  57   1      
  58   1              // ----- DMA initial settings for DM transfer -----
  59   1              XBYTE[0xB216] = 0x00;   // Remain DSP mode.  When you do MCU -> DM, MCU will stop DSP automaticlly
  60   1              XBYTE[0xB301] = 0x50;   // DMA : SRAM --> DM
  61   1              XBYTE[0xB302] = 0xFF;   // Define data size in DMA (assume 512 bytes)
  62   1              XBYTE[0xB303] = 0x01;
  63   1      
  64   1              // Destination
  65   1              XBYTE[0xB340]=0x00;     // 24-bit DMA
  66   1              tw_DSP_Word_Align=gw_DSP_Addr_Table[gs_DSP_GLOBAL_RAM.sc_DM_Index%3]+0x200*(gs_DSP_GLOBAL_RAM.sc_DM_Index
             -/3);
  67   1              tc_DSPAddr_High=*((U8 *)&tw_DSP_Word_Align);
  68   1              XBYTE[0xB21D]=(U8)(tc_DSPAddr_High>>6);
  69   1              tc_DSPAddr_High=*((U8 *)&tw_DSP_Word_Align);
  70   1              tc_DSPAddr_High=tc_DSPAddr_High&0x3F;
  71   1              tc_DSPAddr_High+=0x20;
  72   1              XBYTE[0xB217]=*((U8 *)&tw_DSP_Word_Align+1);
  73   1              XBYTE[0xB218]=tc_DSPAddr_High;
  74   1              // Source
  75   1              XBYTE[0xB112]=(U8)gc_PlayRecordDataBuf;
  76   1              XBYTE[0xB113]=gc_PlayRecordDataBufHB;
  77   1              Trigger_Data_Transfer_Done();
  78   1      
  79   1              L2_DSP_SendCommandSet(DCMD_DatIn);
  80   1              gs_DSP_GLOBAL_RAM.sc_DM_Index++;
  81   1              if(gs_DSP_GLOBAL_RAM.sc_DM_Index==24)
  82   1              {
  83   2                      gs_DSP_GLOBAL_RAM.sc_DM_Index=0;
  84   2              }
  85   1      
  86   1              gc_GetSPIdataSectorNumber++;
  87   1              if(gc_GetSPIdataSectorNumber==C_AlarmDataSize)
  88   1              {
  89   2                      gc_GetSPIdataSectorNumber=0;
  90   2              }
  91   1      
  92   1          tw_SmpRateIdx=L2_DSP_Read_DMem16(0x3F8E);   //0x3F8E is an index of mp3 sampling rate within DSP
  93   1                                                                                                                
             -      //0x0:44.1k;  0x1:48k;  0x2:32k;  0x3:22.1k;  0x4:24k;  0x5:16k;  0x6:11.025k;  0x7:12k;  0x8:8k
  94   1          if(tw_SmpRateIdx==0||tw_SmpRateIdx==3||tw_SmpRateIdx==6)
  95   1              {
  96   2                      GLOBAL_REG[0x46]|=0x04;
  97   2              }
  98   1          else
  99   1              {
 100   2                      GLOBAL_REG[0x46]&=0xFB; 
 101   2              }
 102   1      }
 103          
 104          void GetAlarmData(void)
 105          {
 106   1              unionU16        tdw_SPIAddr;
 107   1      #ifdef SPI_1M
 108   1              Device_Read_SRAM_Index.BY[0]=gc_PlayRecordDataBufHB;
 109   1              Device_Read_SRAM_Index.BY[1]=0x00;
 110   1              tdw_SPIAddr.BY[0]=(0xC2+gc_GetSPIdataSectorNumber*2)%256; // 1-page=256-byte
 111   1              tdw_SPIAddr.BY[1]=0x0B+(0xC2+gc_GetSPIdataSectorNumber*2)/256;
 112   1              SPI_Read_Data(tdw_SPIAddr);     
 113   1      #else
C51 COMPILER V9.00   ALARMCLOCK                                                            07/09/2012 21:16:51 PAGE 3   

                      Device_Read_SRAM_Index.BY[0]=gc_PlayRecordDataBufHB;
                      Device_Read_SRAM_Index.BY[1]=0x00;
                      tdw_SPIAddr.BY[0]=(0x2E+gc_GetSPIdataSectorNumber*2)%256; // 1-page=256-byte
                      tdw_SPIAddr.BY[1]=0x1F+(0x2E+gc_GetSPIdataSectorNumber*2)/256;
                      SPI_Read_Data(tdw_SPIAddr);
              #endif
 120   1      }
 121          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    376    ----
   CONSTANT SIZE    =      6    ----
   XDATA SIZE       =   ----       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
