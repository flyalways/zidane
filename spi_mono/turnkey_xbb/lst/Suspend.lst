C51 COMPILER V9.00   SUSPEND                                                               07/09/2012 21:16:51 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SUSPEND
OBJECT MODULE PLACED IN .\obj\Suspend.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE MAIN\Suspend.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource\he
                    -ader) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\Suspend.lst) OBJECT(.\obj\Suspend.obj)

line level    source

   1          #include <intrins.h>
   2          #include "..\Header\SPDA2K.h"
   3          #include "..\header\variables.h"
   4          
   5          
   6          void Suspend(void)
   7          {
   8   1              // P1/P3 Setting by circuit design
   9   1              XBYTE[0xB102]=0x21;
  10   1              XBYTE[0xB103]=0x00;
  11   1              P1=0xDE;
  12   1              P3=0xFF;
  13   1              gb_LCM_ForceShow=1;
  14   1              LCM_Clear_L0_L7();
  15   1      //      dbprintf("Suspend\n");
  16   1              LCM_ShowChar16x32(10,78);
  17   1              LCM_ShowChar16x32(10,33);
  18   1              LCM_ShowFMOrderRecordIcon();
  19   1              LCM_ShowAlarmIcon();
  20   1              gc_SW_RESET=0x36;
  21   1              gb_SuspendKeyRelease=0;
  22   1      suspend_again:
  23   1              LCM_ShowClock();
  24   1              set_clock_mode(CLOCK_MODE_XTL);
  25   1              XBYTE[0xB006]&=~0x20;   // turn off system PLL
  26   1              XBYTE[0xB09F]=0x02;
  27   1              XBYTE[0xB08A]&=~0x30;   // Turn off headphone driver
  28   1              XBYTE[0xB08A]&=~0x08;   // Turn off DAC
  29   1      //**************************************************************
  30   1      
  31   1              XBYTE[0xB0AB]=0x00;     // enable cpuadrl pull
  32   1      
  33   1              // Disable GPIO[0..13] pull up/down
  34   1              XBYTE[0xB0A1]=0x00;
  35   1              XBYTE[0xB0A2]=0x00;
  36   1              XBYTE[0xB0A3]=0x00;
  37   1              XBYTE[0xB0A4]=0x00;
  38   1              XBYTE[0xB0A5]=0x00;//0x0a;
  39   1              XBYTE[0xB0A6]=0x00;//0xf0;      // set fmgpio pull
  40   1              XBYTE[0xB0A7]=0x00;//0x0f;      // set fmgpio pull
  41   1      
  42   1              // GPIO Setting by circuit design
  43   1              XBYTE[0xB030]=0xFF;     // GPIO[0~7] output 1
  44   1              XBYTE[0xB031]=0xFF;     // GPIO[8~13] output 1
  45   1              XBYTE[0xB038]=0x00;     // Enable GPIO[0~7] output
  46   1              XBYTE[0xB039]=0x00;     // Enable GPIO[8~13] output
  47   1      
  48   1              XBYTE[0xB400]=0;
  49   1              XBYTE[0xB405]=0x00;
  50   1              XBYTE[0xB406]=0x00;
  51   1              
  52   1              XBYTE[0xB059]=0x01;     // P30 falling interrupt
  53   1              XBYTE[0xB079]=0x00;     // clear falling event P3
  54   1              XBYTE[0xB0D1]=0x00; // clear rising & falling usb_det 
C51 COMPILER V9.00   SUSPEND                                                               07/09/2012 21:16:51 PAGE 2   

  55   1              XBYTE[0xB0C0]=0x00;     // clear all interrupt
  56   1              XBYTE[0xB0D0]=0x49; // Enable IR/RTC interrupt
  57   1      
  58   1              XBYTE[0xB005]=0xFF;     // XTAL stable time
  59   1              XBYTE[0xB010]=0x00;     // DSP/DSP-memory clock disable
  60   1              XBYTE[0xB011]=0x44;
  61   1              XBYTE[0xB016]=0x00;
  62   1              XBYTE[0xB019]=0x00;
  63   1              XBYTE[0xB060]=0x02;
  64   1              XBYTE[0xB08A]=0xC1;     // Turn off PLLA and DAC
  65   1              XBYTE[0xB0F7]=0x20;     // Turn-off All RAM module but Boot SRAM
  66   1              XBYTE[0xB092]=0x50; // 2.9V & 1.8V
  67   1              gb_IR_wakeup=0;
  68   1      //dbprintf("Z z z ...\n");
  69   1              XBYTE[0xB013]=0x83;     // turn off XTAL
  70   1              _nop_();
  71   1              XBYTE[0xB013]=0x04;     // hold XTAL
  72   1      //dbprintf("Wakeup...");
  73   1              XBYTE[0xB0D1]=0xF0;
  74   1              XBYTE[0xB0F7]=0xF8;
  75   1              XBYTE[0xB005]=0x00;
  76   1              XBYTE[0xB010]=0x04;     // DSP/DSP-memory clock disable
  77   1              XBYTE[0xB011]=0xE6;
  78   1              XBYTE[0xB016]=0x04;
  79   1              XBYTE[0xB019]=0x01;
  80   1              XBYTE[0xB060]=0x01;
  81   1      
  82   1              XBYTE[0xB09F]=0x06;
  83   1              XBYTE[0xB0C0]=0x00;             // clear all interrupt
  84   1              XBYTE[0xB0A5]|=0x08;    // set fmgpio pull
  85   1      
  86   1              if(gb_RTC_wakeup==1) // check if RTC alarm interrupt occurred
  87   1              {
  88   2                      gb_RTC_wakeup=0;
  89   2                      if(gb_OrderRecordTrigger==1)
  90   2                      {
  91   3                              gc_Task_Current=C_Task_FM;
  92   3                              gb_Suspend_OrderRecord=1;
  93   3                              goto WakeUp_By_OrderRecord;
  94   3                      }
  95   2                      
  96   2                      if(gb_AlarmTrigger==1)
  97   2                      {
  98   3                              if(CheckAlarmSetting()==0)      // Match Alarm Clock Setting
  99   3                              {
 100   4                                      gc_Task_Last=C_Task_Suspend;
 101   4                                      gc_Task_Current=C_Task_AlarmON;
 102   4                                      goto Wakeup_By_AlarmClock;
 103   4                              }
 104   3                      }
 105   2      
 106   2                      if(gb_SuspendKeyRelease==0)
 107   2                      {
 108   3                              if(READ_SARADC(0)>0x78) // [Play]Released(When Release, Key value about 0x7F)
 109   3                              {
 110   4                                      gb_SuspendKeyRelease=1;
 111   4                              }
 112   3                      }
 113   2                      else
 114   2                      {
 115   3                              if(READ_SARADC(0)<0x78) // [Play]Pressed
 116   3                              {
C51 COMPILER V9.00   SUSPEND                                                               07/09/2012 21:16:51 PAGE 3   

 117   4                                      if(READ_SARADC(0)<5)    // Double Check, Avoid SAR Unstable
 118   4                                      {
 119   5                                              goto Wakeup_By_PlayKey;
 120   5                                      }
 121   4                              }
 122   3                      }
 123   2                      goto suspend_again;
 124   2              }
 125   1              XBYTE[0xB0D0]=0x41;
 126   1              XBYTE[0xB059]=0x00;             // P30 falling interrupt
 127   1              XBYTE[0xB079]=0x00;             // clear falling event P3
 128   1      
 129   1              USER_Delay(300);                // Wait IR receive all data
 130   1              if(gb_IR_wakeup==1)
 131   1              {               
 132   2                      gb_IR_wakeup=0;
 133   2                      if(XBYTE[0xBA1A]==0x00 && XBYTE[0xBA1B]==0xFF && XBYTE[0xBA1C]==0x46)
 134   2                      { // Wake by IR Power-on key    
 135   3                              
 136   3                      }
 137   2                      else
 138   2                      {
 139   3                              goto suspend_again;
 140   3                      }
 141   2              } 
 142   1              else
 143   1              {
 144   2      //              dbprintf("-----some err ----\n");
 145   2                      XBYTE[0xBA19]=0x07;
 146   2                      goto suspend_again;
 147   2              }
 148   1      
 149   1      Wakeup_By_PlayKey:
 150   1      WakeUp_By_OrderRecord:
 151   1      Wakeup_By_AlarmClock:
 152   1              XBYTE[0xB08A]=0xF8;     // Turn On PLLA and DAC
 153   1              IE=0;
 154   1              XBYTE[0xB092]=0x77; // 3.2V & 1.9V
 155   1              XBYTE[0xB0D0]=0x00;
 156   1              gc_clock_mode=0;
 157   1              load_nand_bank();
 158   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    443    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
