/******************************************************************************
* Implementation for common ui function.
*
* Interface provided from this file are expected to be called by ui.c
*
* Created: 2012/08/27
******************************************************************************/
#include <assert.h>
#include "SPDA2K.H"
#include "../IR/lcm_bmp_driver.h"
#include "ui_impl.h"

#include "ui_bmp.c"

//-----------------------------------------------------------------------------
// _ui_set_bound
//
// Description: Set the area in the LCD which we'd like to light using dot as
//              the unit. This is extremely conbined with the way to generate
//              dot matrix array data which is sent to LCM later.
//
// Created: 2012/08/27
//-----------------------------------------------------------------------------




//-----------------------------------------------------------------------------
// ui_fill_ui_data
//
// Populate the ui_data struct. Prepare the parameter to use ui_disp_ui_data( ).
//
// Parameter p_bmp is very special, which requires that the passed in para must
// be the address of bmp data generated by modulo. All of the logic is built
// based on the structure of bmp data:
//      1st byte: lenght.
//      2nd byte: height.
//      3rd byte: bytes in a line.
//      4st byte until end: data.
//
// Created: 2012/09/04
//-----------------------------------------------------------------------------
void ui_fill_ui_data ( 
                        ui_data_t   *p_ui_data,
                        uint8       origin_x,
                        uint8       origin_y,
                        uint8       *p_bmp,
                        uint16      size_bmp_data
                     )
{
    p_ui_data->origin_x     = origin_x;
    p_ui_data->origin_y     = origin_y;

    p_ui_data->ui_bmp.bmp.length        = *p_bmp;
    p_ui_data->ui_bmp.bmp.height        = *(p_bmp+1);
    p_ui_data->ui_bmp.bmp.byte_of_line  = *(p_bmp+2);
    p_ui_data->ui_bmp.bmp.p_data        = p_bmp+3;
    p_ui_data->ui_bmp.size_bmp_data     = size_bmp_data;
}
                      

//-----------------------------------------------------------------------------
// ui_disp_ui_data
//
// Created: 2012/09/04
//-----------------------------------------------------------------------------
void ui_disp_ui_data (ui_data_t * p_ui_data)
{
    uint8 i=0;
    uint8 j=0;
    uint8 bound_offset_x;
    uint8 bound_offset_y;
    uint8 bound_length;
    uint8 bound_height;

    uint8 bound_length_mod;

    uint8 *p_tmp;
    uint8 byte_of_line;
    uint16 size_bmp_data;
    uint8 line;
    uint8 line_mod;

    bound_offset_x      = p_ui_data->origin_x;
    bound_offset_y      = p_ui_data->origin_y;
    bound_length        = p_ui_data->ui_bmp.bmp.length;
    bound_height        = p_ui_data->ui_bmp.bmp.height;
    byte_of_line        = p_ui_data->ui_bmp.bmp.byte_of_line;    
    p_tmp               = p_ui_data->ui_bmp.bmp.p_data;
    size_bmp_data       = p_ui_data->ui_bmp.size_bmp_data;
    
    // Do necessary modification for length, height and byte_of_line.

    
    // If the length and byte_of_line match perfectly, show it right now!
    if ( !(bound_length%3)
        &&(bound_length==8*byte_of_line)
       )
    {
        // I do not check if the origin x is 3's multiple.
        lcm_set_disp_bound (bound_offset_x,
                            bound_offset_x+bound_length-1,
                            bound_offset_y,
                            bound_offset_y+bound_height-1);
    
        lcm_write_command (ST7587_WRITE_DISPLAY_DATA_CMD);
        for (i=0; i<size_bmp_data; i++)
        {
            lcm_write_data_cooked (*p_tmp);
            p_tmp++;
        }
        
        return;        
    }

    // Send the data line by line. This is slow.
    // If need, modify the bound length to 3's multiple.
    // Set the y bound range to 2 (y+1) in order to avoid the overlay in the
    // begining of a line by the redundant data at the end of a line.
    else
    {
        // Check if bound length needs modified.
        if (bound_length%3)
        {
            bound_length_mod = (bound_length/3)*3 + 3;
        }
        else
        {
            bound_length_mod = bound_length;
        }

        // Calculate how many lines there are in the bmp data.
        line_mod = size_bmp_data%byte_of_line;
        if (line_mod)
        {
            line = size_bmp_data/byte_of_line + 1;
        }
        else
        {
            line = size_bmp_data/byte_of_line;
        }

        for (i=0; i<line; i++)
        {
            
            lcm_set_disp_bound (bound_offset_x,
                                bound_offset_x+bound_length_mod-1,
                                bound_offset_y,
                                bound_offset_y+1);
            lcm_write_command (ST7587_WRITE_DISPLAY_DATA_CMD);
            while(j<byte_of_line)
            {
                lcm_write_data_cooked (*p_tmp);
                p_tmp++;
                j++;
            }

            // Prepare to send data of next line.
            bound_offset_y++;
            j=0;

            // If next line is the last line, check if it will be a full line.
            // If not, we will cut off the number of data we will send. This is
            // to avoid access the bmp data overflow.
            if ( (i==line-2) && (line_mod) )
            {
                j = byte_of_line-line_mod;
            }
        }
        
        return;                                
    }
                            
}

//-----------------------------------------------------------------------------
// ui_disp_bmp_data
//
// Given the origin postion, bmp_data and size of data, show it. The idea is:
// tell me where you want to show and what you want to show, then I will show
// you.
//
// IMPORTANT!
// The logic here higher depands on the struct of bmp data generated from the
// modulo software.
//
// Created: 2012/09/04
//-----------------------------------------------------------------------------
void ui_disp_bmp_data (
                        uint8   origin_x,
                        uint8   origin_y,
                        uint8*  bmp_data,
                        uint16  size_bmp_data
                      )
{
    ui_data_t ui_data;

    ui_fill_ui_data (
                        &ui_data,
                        origin_x,
                        origin_y,
                        bmp_data,
                        size_bmp_data
                    );
    ui_disp_ui_data (&ui_data);
}

//-----------------------------------------------------------------------------
// Display the bmp in the middle of the screen.
//
// Created: 2012/09/05
//-----------------------------------------------------------------------------
void ui_disp_bmp_data_mid_xy (uint8* bmp_data, uint16 size_bmp_data)
{
    uint8 origin_x;
    uint8 origin_y;
    uint8 length;
    uint8 height;

    length = *bmp_data;
    height = *(bmp_data+1);

    origin_x = (UI_DISP_BOUND_LIMIT_X-length)/2;
    origin_y = (UI_DISP_BOUND_LIMIT_Y-height)/2;

    // Have to adjust origin x to be 3's multiple
    if (origin_x%3)
    {
        origin_x = (origin_x/3 + 1)*3;
    }

    ui_disp_bmp_data (origin_x,
                      origin_y,
                      bmp_data,
                      size_bmp_data);
}

//-----------------------------------------------------------------------------
// ui_disp_hello_impl
//
// Created: 2012/09/04
//-----------------------------------------------------------------------------
void ui_disp_hello_impl(void)
{
    ui_disp_bmp_data (54,
                      54,
                      bmp_hello,
                      sizeof(bmp_hello)-3);
}


//-----------------------------------------------------------------------------
// ui_clear_screen
//
// Created: 2012/08/27
//-----------------------------------------------------------------------------
void ui_clear_screen(void)
{
    lcm_clear_screen();
}

//-----------------------------------------------------------------------------
// Show a music demo menu like UES.
//
// Created: 2012/09/05
//-----------------------------------------------------------------------------
void ui_show_demo_menu(void)
{
    ui_disp_bmp_data (0,
                      10,
                      bmp_demo_top,
                      sizeof(bmp_demo_top)-3);
    ui_disp_bmp_data_mid_xy (bmp_demo_mid,
                             sizeof(bmp_demo_mid)-3);
    ui_disp_bmp_data (0,
                      98,
                      bmp_demo_bot,
                      sizeof(bmp_demo_bot)-3);   
}

//-----------------------------------------------------------------------------
// UI test routine
//
// Created: 2012/09/05
//-----------------------------------------------------------------------------
#if (UI_TEST_ONLY == FEATURE_ON)
void ui_test_impl(void)
{
    while(1)
    {
        ui_show_demo_menu();
        ui_clear_screen();
    }
    
}
#endif