C51 COMPILER V9.00   FLASH_ENHANCE                                                         07/10/2012 15:51:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE FLASH_ENHANCE
OBJECT MODULE PLACED IN .\obj\Flash_EnHance.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\libsource\FLASH\Flash_EnHance.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS IN
                    -CDIR(..\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\Flash_EnHance.lst) OBJECT(.\obj\Flash_EnH
                    -ance.obj)

line level    source

   1          /*
   2           *                          Sunplus mMedia Inc.
   3           *
   4           *   (c) Copyright 2008~, Sunplus mMedia Inc., Hsinchu, Taiwan R.O.C.
   5           *                          All Right Reserved
   6           */
   7          /*! \file       fepr.c
   8           *      \brief  
   9           *
  10           *      \author jay
  11           */
  12          #include "SPDA2K.h"
  13          
  14          static  void FLASH_Recover_Blcok(UWORD StartPage , UWORD EndPage , U8 TargetDev);
  15          /*********************************************************************************
  16          * NAME:               U16 Flash_Search_ReplaceBlock (U8 cDev)
  17          * DESCRIPTION:
  18          *********************************************************************************/
  19          U16 Flash_Search_ReplaceBlock_Index (void ){
  20   1              U16 tw_Replace;
  21   1              U8  tc_Find_Replace =0 ;
  22   1              U8  tc_i;
  23   1              if((Wear_Table[WINX]>=SYS_ZONE.wZONE_SIZE)||(Wear_Table[WINX]==0)){
  24   2                      Wear_Table[WINX] = (SYS_ZONE.wZONE_SIZE-1);
  25   2              }
  26   1              //tw_Replace = Wear_Table[WINX];
  27   1              tw_Replace = (SYS_ZONE.wZONE_SIZE-1);
  28   1              do{
  29   2                      if((Wear_Table[tw_Replace]>0x70)&&(Wear_Table[tw_Replace]<=0x7F)){
  30   3                              tc_Find_Replace =1; 
  31   3                              for(tc_i=0;tc_i<Extend_NUM;tc_i++){
  32   4                                      if(Mapping_Table[EINX+tc_i]==tw_Replace){
  33   5                                              tc_Find_Replace =0;
  34   5                                              break;
  35   5                                      }
  36   4                              }                       
  37   3                              for(tc_i=0;tc_i<MAX_RANDOM_HBLOCK;tc_i++){
  38   4                                      if(Wear_Table[RINX+tc_i]==tw_Replace){
  39   5                                              tc_Find_Replace =0;                                             
  40   5                                              break;
  41   5                                      }
  42   4                              }                                       
  43   3                      }                               
  44   2                      if(tc_Find_Replace){                    
  45   3                              break;
  46   3                      }       
  47   2                      tw_Replace--;
  48   2              }while(tw_Replace);
  49   1              if(tc_Find_Replace){
  50   2                      
  51   2                      return tw_Replace;
  52   2              }
  53   1              else{
C51 COMPILER V9.00   FLASH_ENHANCE                                                         07/10/2012 15:51:49 PAGE 2   

  54   2                      tw_Replace = Wear_Table[WINX];
  55   2                      tw_Replace= tw_Replace%SYS_ZONE.wZONE_SIZE;
  56   2                      do{                     
  57   3                              tc_Find_Replace =1; 
  58   3                              for(tc_i=0;tc_i<Extend_NUM;tc_i++){
  59   4                                      if(Mapping_Table[EINX+tc_i]==tw_Replace){
  60   5                                              tc_Find_Replace =0;
  61   5                                              break;
  62   5                                      }
  63   4                              }                       
  64   3                              for(tc_i=0;tc_i<MAX_RANDOM_HBLOCK;tc_i++){
  65   4                                      if(Wear_Table[RINX+tc_i]==tw_Replace){
  66   5                                              tc_Find_Replace =0;                                             
  67   5                                              break;
  68   5                                      }
  69   4                              }                                       
  70   3                                                              
  71   3                              if(tc_Find_Replace){                            
  72   4                                      break;
  73   4                              }
  74   3                                      
  75   3                              else{
  76   4                                       tw_Replace--;
  77   4                                       if(tw_Replace==0){
  78   5                                              tw_Replace =(SYS_ZONE.wZONE_SIZE-1);
  79   5                                      }
  80   4                              }
  81   3                      }while(tw_Replace);     
  82   2                      Wear_Table[WINX] = tw_Replace-1;
  83   2                      return tw_Replace;
  84   2              }
  85   1      }
  86          /*********************************************************************************
  87          * NAME:               void  Flash_Update_WearBlock (void)
  88          * DESCRIPTION:
  89          *********************************************************************************/
  90          void  NAND_Update_WearBlock (U8 tc_Dev){
  91   1              U16 tw_HBlock;
  92   1              tw_HBlock = Flash_Search_ReplaceBlock_Index();
  93   1      //      dbprintf("\n Wear_Index:%X",tw_HBlock);
  94   1              
  95   1              FDBP.cFDev= tc_Dev;
  96   1              FDBP.cFPlane = 0;
  97   1              FDBP.wFBlock = Mapping_Table[tw_HBlock];
  98   1              FDBP.wFPage  = 0;
  99   1              FDBP.cFInAddr =0;  
 100   1              Device_Read_SRAM_Index.WD=0x8000;
 101   1              Flash_ReadSpare(8);   
 102   1              ZSpare[3] =0;  
 103   1              gw_SourceBlock = Mapping_Table[tw_HBlock];
 104   1              gw_TargetBlock = Mapping_Table[SBK];
 105   1              FLASH_Recover_Blcok(0 , NAND_INFO.wPAGE_NUM ,tc_Dev);
 106   1              Mapping_Table[tw_HBlock] =gw_TargetBlock;
 107   1              Mapping_Table[SBK] =gw_SourceBlock;
 108   1              Wear_Table[SCNT]= Wear_Table[tw_HBlock]+1;      
 109   1              Wear_Table[tw_HBlock] =0;
 110   1              FDBP.cFDev = tc_Dev;
 111   1              FDBP.cFPlane = 0;
 112   1              FDBP.wFBlock = gw_SourceBlock;
 113   1              FDBP.wFPage  = 0;
 114   1              FDBP.cFInAddr = 0;
 115   1              Flash_EraseOneBlock_NO_ChkRdy();
C51 COMPILER V9.00   FLASH_ENHANCE                                                         07/10/2012 15:51:49 PAGE 3   

 116   1      } 
 117          /*********************************************************************************
 118          * NAME:                   void NAND_Recover_Block(U16 tw_Inx, U8 tc_Recover_Type );
 119          * DESCRIPTION:
 120          *********************************************************************************/
 121          void NAND_Recover_Block(U16 tw_Inx, U8 tc_Recover_Type ){
 122   1              U8  tc_Replace_Mode =0;
 123   1              U16 tw_Cnt,tw_WhichGroup;
 124   1              gw_SourceBlock = Mapping_Table[tw_Inx];
 125   1              
 126   1              if((tc_Recover_Type&0x03)==0x02){// replace block 
 127   2                      tc_Replace_Mode=1;
 128   2                      FDBP.cFDev = gc_HDev;
 129   2                      FDBP.cFPlane = 0;
 130   2                      FDBP.wFBlock = ReplacementBlock_Table[gc_HDev];
 131   2                      FDBP.wFPage  = ReplacementBlock_Page[gc_HDev];
 132   2                      FDBP.cFInAddr = 0;
 133   2                      Device_Read_SRAM_Index.BY[0] = 0x80;    
 134   2                      Device_Read_SRAM_Index.BY[1] = 0x00;
 135   2                      Flash_Sequent_Read(4);
 136   2                      if((FLASH_REG[0x60]==0x3E)&&(FLASH_REG[0x61] =='R')){   
 137   3                              tw_Cnt = XWORD_8000[511];
 138   3                              if(tw_Cnt ==0){//表示已經將所有 replace block 用完
 139   4                                      tc_Replace_Mode =0;
 140   4      //                              dbprintf("\n Recover Over");
 141   4                                      return;
 142   4                              }
 143   3                              else{
 144   4                                      tw_Cnt--;
 145   4                                      gw_TargetBlock = XWORD_8000[tw_Cnt];
 146   4                                      XWORD_8000[tw_Cnt] =0xFFFF;
 147   4                                      XWORD_8000[511 ] =tw_Cnt;
 148   4                                      tw_Cnt=XWORD_8400[511];
 149   4                                      XWORD_8400[tw_Cnt]= Mapping_Table[tw_Inx];
 150   4                                      XWORD_8400[511]= tw_Cnt+1;
 151   4                                      FDBP.cFDev = gc_HDev;
 152   4                                      FDBP.cFPlane = 0;
 153   4                                      FDBP.wFBlock = ReplacementBlock_Table[gc_HDev];
 154   4                                      FDBP.wFPage  = ReplacementBlock_Page[gc_HDev]+1;
 155   4                                      FDBP.cFInAddr = 0;
 156   4                                      if(FDBP.wFPage== NAND_INFO.wPAGE_NUM){
 157   5                                              Flash_EraseOneBlock_NO_ChkRdy();
 158   5                                              ReplacementBlock_Page[gc_HDev] =0;
 159   5                                              FDBP.wFPage =ReplacementBlock_Page[gc_HDev];
 160   5                                              FDBP.cFInAddr = 0;
 161   5                                      }
 162   4                                      ZSpare[0] = 0x3E;                                                       ZSpare[1] = 'R';
 163   4                                      ZSpare[2] = 'M';                                                        ZSpare[3] = 'T';        
 164   4                                      ZSpare[4] =  0x3E;                                                      ZSpare[5] = 'R';
 165   4                                      ZSpare[6] = 'M';                                                        ZSpare[7] = 'T';
 166   4                                      Device_Write_SRAM_Index.BY[0] = 0x80;   
 167   4                                      Device_Write_SRAM_Index.BY[1] = 0x00;
 168   4                                      Flash_Sequent_Write(4,1); 
 169   4                              }
 170   3                      }
 171   2                      else{
 172   3                              tc_Replace_Mode =0;
 173   3      //                      dbprintf("\n No Replacement block");
 174   3                              return;
 175   3                      }       
 176   2              }
 177   1              if(!tc_Replace_Mode){
C51 COMPILER V9.00   FLASH_ENHANCE                                                         07/10/2012 15:51:49 PAGE 4   

 178   2                      gw_TargetBlock = Mapping_Table[SBK];
 179   2              }       
 180   1              //------ Read Source Block Mark ----------//
 181   1              FDBP.cFDev=gc_HDev;
 182   1              FDBP.cFPlane = 0;
 183   1              FDBP.wFBlock = Mapping_Table[tw_Inx];
 184   1              FDBP.wFPage  = 0;
 185   1              FDBP.cFInAddr =0;  
 186   1              Device_Read_SRAM_Index.WD=0x8000;
 187   1              Flash_ReadSpare(8);  // get Hblock spare data 
 188   1              ZSpare[3] =1; // update erase cnt 
 189   1              
 190   1              FLASH_Recover_Blcok(0 , NAND_INFO.wPAGE_NUM , gc_HDev);
 191   1              //----------------------------------//
 192   1              if(tc_Replace_Mode){
 193   2                      Mapping_Table[tw_Inx]=gw_TargetBlock;
 194   2                      Wear_Table[tw_Inx] =0x01;
 195   2                      //--------- erase Temp Block ---//
 196   2                      FDBP.cFDev= gc_HDev;
 197   2                      FDBP.cFPlane = 0;
 198   2                      FDBP.wFBlock = TempBlock_Table[FDBP.cFDev];
 199   2                      FDBP.wFPage  = 0;
 200   2                      FDBP.cFInAddr =0;  
 201   2                      Flash_EraseOneBlock_NO_ChkRdy();
 202   2                      //--------- Copy BMT to  Temp --//
 203   2                      tw_WhichGroup =MAP_Table[gw_NowBMTPoint];
 204   2                      NAND_ZONE_To_BMT_DBP(tw_WhichGroup);
 205   2                      FDBP.cFDev= BMT.cFDev;
 206   2                      FDBP.cFPlane = 0;               
 207   2                      for(FDBP.wFPage=0; FDBP.wFPage< SYS_ZONE.cDEV_ZONE_NUM; FDBP.wFPage++){
 208   3                              FDBP.wFBlock  = BMT.wFBlock;
 209   3                              FDBP.cFInAddr =0;
 210   3                              Device_Read_SRAM_Index.WD= 0x8000;
 211   3                              Flash_Sequent_Read(4);
 212   3                              if(FDBP.wFPage==BMT.wFPage){
 213   4                                      for(tw_Cnt=0;tw_Cnt<( SYS_ZONE.wZONE_SIZE+ZONE_TOTAL_OTHER);tw_Cnt++){
 214   5                                              if(XWORD_8000[tw_Cnt]==gw_SourceBlock){
 215   6                                                      XWORD_8000[tw_Cnt] =gw_TargetBlock;
 216   6                                              }
 217   5                                      }
 218   4                              }                                               
 219   3                              Device_Write_SRAM_Index.WD =0x8000;
 220   3                              FDBP.wFBlock = TempBlock_Table[FDBP.cFDev];
 221   3                              FDBP.cFInAddr =0;
 222   3                              Flash_Sequent_Write(4,0);       
 223   3                      }
 224   2                      gw_TargetBlock = BMTTable_Backup[BMT.cFDev];    
 225   2                      gw_SourceBlock = TempBlock_Table[BMT.cFDev];
 226   2                      FDBP.wFBlock = gw_TargetBlock;
 227   2                      FDBP.wFPage  = 0;
 228   2                      FDBP.cFInAddr =0;  
 229   2                      Flash_EraseOneBlock_NO_ChkRdy();
 230   2                      ZSpare[0] = 0x3E;                                                       ZSpare[1] = 'B';
 231   2                      ZSpare[2] = 'M';                                                        ZSpare[3] = 'T';        
 232   2                      ZSpare[4] =  0x3E;                                                      ZSpare[5] = 'B';
 233   2                      ZSpare[6] = 'M';                                                        ZSpare[7] = 'T';
 234   2                      FLASH_Recover_Blcok(0 , SYS_ZONE.cDEV_ZONE_NUM ,  BMT.cFDev);
 235   2                      gw_TargetBlock = BMTTable[BMT.cFDev];   
 236   2                      gw_SourceBlock = TempBlock_Table[BMT.cFDev];
 237   2                      FDBP.wFBlock = gw_TargetBlock;
 238   2                      FDBP.wFPage  = 0;
 239   2                      FDBP.cFInAddr =0;  
C51 COMPILER V9.00   FLASH_ENHANCE                                                         07/10/2012 15:51:49 PAGE 5   

 240   2                      Flash_EraseOneBlock_NO_ChkRdy();
 241   2                      ZSpare[0] = 0x3E;                                                       ZSpare[1] = 'B';
 242   2                      ZSpare[2] = 'M';                                                        ZSpare[3] = 'T';        
 243   2                      ZSpare[4] =  0x3E;                                                      ZSpare[5] = 'B';
 244   2                      ZSpare[6] = 'M';                                                        ZSpare[7] = 'T';                
 245   2                      FLASH_Recover_Blcok(0 , SYS_ZONE.cDEV_ZONE_NUM , BMT.cFDev);
 246   2                      
 247   2              }
 248   1              else{
 249   2                      Mapping_Table[tw_Inx]=gw_TargetBlock;
 250   2                      tw_Cnt =Wear_Table[tw_Inx];     
 251   2                      Wear_Table[tw_Inx]=Wear_Table[SCNT];
 252   2                      FDBP.cFDev=gc_HDev;
 253   2                      FDBP.cFPlane = 0;
 254   2                      FDBP.wFBlock = gw_SourceBlock;
 255   2                      FDBP.wFPage  = 0;
 256   2                      FDBP.cFInAddr =0;
 257   2                      Flash_EraseOneBlock_NO_ChkRdy();
 258   2                      Mapping_Table [SBK] = gw_SourceBlock;
 259   2                      Wear_Table[SCNT] =tw_Cnt+1;     
 260   2              }
 261   1      
 262   1      
 263   1      }
 264          /*********************************************************************************
 265          * NAME:  void FLASH_Recover_Blcok(UWORD StartPage , UWORD EndPage , U8 TargetDev)
 266          * DESCRIPTION:
 267          *********************************************************************************/
 268          static  void FLASH_Recover_Blcok(UWORD StartPage , UWORD EndPage , U8 TargetDev){       
 269   1              U16 tw_Page;    
 270   1              FDBP.cFDev= TargetDev;
 271   1              for(tw_Page=StartPage; tw_Page<EndPage;tw_Page++){
 272   2                      //-------------------------------------- //
 273   2                      Device_Read_SRAM_Index.BY[0] = 0x80;
 274   2                      Device_Read_SRAM_Index.BY[1] = 0x00; 
 275   2                      FDBP.cFPlane = tw_Page%NAND_INFO.cPLANE_NUM;
 276   2                      FDBP.wFBlock = gw_SourceBlock;// source block 
 277   2                      FDBP.wFPage  = tw_Page/NAND_INFO.cPLANE_NUM;
 278   2                      FDBP.cFInAddr =0;
 279   2                      Flash_Sequent_Read(NAND_INFO.cINADDRMAX);
 280   2                      //--------------------------------------//
 281   2                      Device_Write_SRAM_Index.BY[0] = 0x80;
 282   2                      Device_Write_SRAM_Index.BY[1] = 0x00;
 283   2                      FDBP.cFPlane = tw_Page%NAND_INFO.cPLANE_NUM;
 284   2                      FDBP.wFBlock = gw_TargetBlock;// Target block
 285   2                      FDBP.wFPage  = tw_Page/NAND_INFO.cPLANE_NUM;
 286   2                      FDBP.cFInAddr =0;
 287   2                      Flash_Sequent_Write(NAND_INFO.cINADDRMAX,1);
 288   2                      
 289   2                      
 290   2              }
 291   1      }
 292                                                                                              


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1896    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.00   FLASH_ENHANCE                                                         07/10/2012 15:51:49 PAGE 6   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
