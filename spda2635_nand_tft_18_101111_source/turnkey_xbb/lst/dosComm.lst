C51 COMPILER V9.00   DOSCOMM                                                               07/10/2012 15:51:52 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DOSCOMM
OBJECT MODULE PLACED IN .\obj\dosComm.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\LIBSOURCE\DOS\dosComm.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\
                    -libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\dosComm.lst) OBJECT(.\obj\dosComm.obj)

line level    source

   1          #include <string.h>
   2          #include "SPDA2K.h"
   3          #include "dos\fs_struct.h"
   4          #include "dos\dosfat.h"
   5          #include "dos\dosfdb.h"
   6          #include "dos\dosrw.h"
   7          #include "Memalloc.h"
   8          #include "Rambase.h"
   9          #include "PROTOTYP.h"
  10          
  11          extern  U8              HOST_Read_Logicsector(U32 LBAaddr);
  12          extern  data    bit     gb_HostConnect;
  13          extern  xdata   U8      gc_HostSectorUnit;
  14          
  15          U32 DOS_GetNextCluster(U32 tdw_CurrentCluster, U32 tdw_ClusterNumber)
  16          {
  17   1              data    U16 tw_WordOffset;
  18   1              xdata   U8  tc_status;                                                                                  //Ching 081111
  19   1              xdata   U32 tdw_ClusterNumCounter=0;
  20   1              xdata   U32 tdw_fatOffset, tdw_DOS_FatSize;
  21   1              
  22   1              gb_ReadWriteDataArea=1;
  23   1              if(tdw_CurrentCluster<2)
  24   1              {//for rootdir
  25   2                              return(0xffffffff);     
  26   2              }
  27   1      
  28   1              if (tdw_ClusterNumber == 0) 
  29   1              {
  30   2                      return tdw_CurrentCluster;
  31   2              }
  32   1                                      
  33   1              tdw_fatOffset = tdw_CurrentCluster<< gc_DOS_FileSystemType;//fat16 or fat32     
  34   1              for(tdw_DOS_FatSize=(tdw_fatOffset>>9);tdw_DOS_FatSize<gdw_DOS_SectorPerFAT;tdw_DOS_FatSize++)//(JC)searc
             -h sectors in FAT from current cluster sector to FAT end
  35   1              {//find in fat
  36   2                      tc_status = DOS_Read_LogicSector((gdw_DOS_Fat1Addr+tdw_DOS_FatSize),1);
  37   2                      if(tc_status)                                                                           //read fail
  38   2                              tc_status = DOS_Read_LogicSector((gdw_DOS_Fat2Addr+tdw_DOS_FatSize), 1);
  39   2      
  40   2                      if(tc_status == 0)
  41   2                      {                       
  42   3                              while((tdw_fatOffset>>9)==tdw_DOS_FatSize)
  43   3                              {
  44   4                                      tw_WordOffset=tdw_fatOffset&0x1FF;
  45   4                                      if(gc_DOS_FileSystemType==1)
  46   4                                      {//FAT16
  47   5                                              if(tdw_CurrentCluster>=0xfff8)
  48   5                                              {                                               
  49   6                                                      return(0xffffffff);
  50   6                                              }                                       
  51   5                                              tdw_CurrentCluster=(((U32)gc_UserDataBuf[tw_WordOffset+1]<<8))|(U32)gc_UserDataBuf[tw_WordOffset];                      
             -                                        
  52   5                                      }
C51 COMPILER V9.00   DOSCOMM                                                               07/10/2012 15:51:52 PAGE 2   

  53   4                                      else if(gc_DOS_FileSystemType==2)
  54   4                                      {//fat32                                
  55   5                                              if(tdw_CurrentCluster>=0x0ffffff8)
  56   5                                              {                       
  57   6                                                      return(0xffffffff);
  58   6                                              }
  59   5                                      
  60   5                                              ((U8 *)(&tdw_CurrentCluster))[0]=gc_UserDataBuf[tw_WordOffset+3];
  61   5                                              ((U8 *)(&tdw_CurrentCluster))[1]=gc_UserDataBuf[tw_WordOffset+2];
  62   5                                              ((U8 *)(&tdw_CurrentCluster))[2]=gc_UserDataBuf[tw_WordOffset+1];
  63   5                                              ((U8 *)(&tdw_CurrentCluster))[3]=gc_UserDataBuf[tw_WordOffset]; 
  64   5                                              tdw_CurrentCluster &= 0x0FFFFFFF;
  65   5                                              }
  66   4                                              tdw_fatOffset = tdw_CurrentCluster<< gc_DOS_FileSystemType;
  67   4                                              tdw_ClusterNumCounter++;
  68   4      
  69   4                                              if(gc_CurrentCard==2)  //if SD not exist return DOS_CLUSTER_LINK_ERR chiayen0813
  70   4                                              {
  71   5                                                      if(SD_Detect)
  72   5                                                      {
  73   6                                                              return(0xffffffff);             
  74   6                                                      }
  75   5                                              }
  76   4      
  77   4                                              if((gc_CurrentCard==5) && (gb_HostConnect == 0))  //if Host not exist return DOS_CLUSTER_LINK_ERR chi
             -ayen 20081017
  78   4                                              {
  79   5                                                      return(0xffffffff);             
  80   5                                              }
  81   4      
  82   4                                              if(tdw_ClusterNumCounter==tdw_ClusterNumber)
  83   4                                              {               
  84   5                                                              return(tdw_CurrentCluster);
  85   5                                              }
  86   4                              }               
  87   3                              tdw_DOS_FatSize=(tdw_fatOffset>>9) - 1;                 //-1 是因為 for loop 會再 +1, Ching 081216
  88   3                      }
  89   2                      else
  90   2                      {
  91   3                              return(0xffffffff);
  92   3                      }       
  93   2              } 
  94   1      }
  95          
  96          
  97          U32 DOS_ClusterLogicAddr(U32 tdw_Cluster)
  98          {       
  99   1              U32 tdw_LogicAddr;
 100   1      
 101   1              if (tdw_Cluster == 0)
 102   1              {       //maybe Root dir
 103   2                      if (gc_DOS_FileSystemType == 2)
 104   2                      {//FAT32 cluster can not be 0
 105   3                              tdw_LogicAddr = 0;//mark error
 106   3                      }
 107   2                      else
 108   2                      {//FAT12&FAT16 root dir
 109   3                              tdw_LogicAddr = gdw_DOS_RootDirAddr;
 110   3                      }
 111   2              }
 112   1              else if (tdw_Cluster == 1)
 113   1              {       //cluster is disable to be 1
C51 COMPILER V9.00   DOSCOMM                                                               07/10/2012 15:51:52 PAGE 3   

 114   2                      //when cluster is 1,error is occur      
 115   2                      tdw_LogicAddr = 0;
 116   2              }
 117   1              else
 118   1              {//normal state
 119   2                      tdw_LogicAddr=gdw_DOS_DataAddr+((tdw_Cluster-2)*gc_DOS_SectorPerCluster*gc_HostSectorUnit);
 120   2              }
 121   1      
 122   1              return tdw_LogicAddr;
 123   1      }
 124          
 125          
 126          U8 DOS_Read_LogicSector(U32 tdw_LogicSectorAddr, U8 tc_ReadSectorNumber)
 127          {
 128   1              data    U8      tc_Status = DOS_FALSE;
 129   1              data    U8      tc_BufIndex;
 130   1              xdata   U32 tdw_tempLogicSectorAddr;
 131   1      
 132   1              if(gb_ReadWriteDataArea==0)
 133   1              {
 134   2                      tc_BufIndex=gc_PlayRecordDataBufHB;
 135   2              }
 136   1              else
 137   1              {
 138   2                      tc_BufIndex=gc_UserDataBufHB;
 139   2              }
 140   1              switch(gc_CurrentCard)
 141   1              {
 142   2                      case 0:
 143   2                              tdw_tempLogicSectorAddr=tdw_LogicSectorAddr;                    
 144   2                              while(tc_ReadSectorNumber)
 145   2                              {
 146   3                                      tc_Status = (U8)Dos_Read_LBA(tdw_tempLogicSectorAddr, tc_BufIndex); //Ching 081111
 147   3                                      tc_ReadSectorNumber--;
 148   3                                      tdw_tempLogicSectorAddr++;
 149   3                              }
 150   2                              break;
 151   2      
 152   2                      case 2:
 153   2                              tdw_tempLogicSectorAddr=tdw_LogicSectorAddr;                    
 154   2                              while(tc_ReadSectorNumber)
 155   2                              {
 156   3                                      SD_Read_LBA_Dos(tdw_tempLogicSectorAddr ,tc_BufIndex);
 157   3                                      tc_ReadSectorNumber--;
 158   3                                      tdw_tempLogicSectorAddr++;
 159   3                              }
 160   2      
 161   2                              if(SD_Detect)  //if SD not exist return false  //chiayen0813  
 162   2                              {
 163   3                                      tc_Status=DOS_FALSE;
 164   3                              }
 165   2                              else
 166   2                              {
 167   3                              tc_Status=DOS_SUCCESS;
 168   3                              }
 169   2                      break;
 170   2      
 171   2              case 5:
 172   2                              HOST_Read_Logicsector(tdw_LogicSectorAddr);
 173   2                              if(gb_HostConnect == 0x00)
 174   2                              {
 175   3                                      tc_Status=DOS_FALSE;            
C51 COMPILER V9.00   DOSCOMM                                                               07/10/2012 15:51:52 PAGE 4   

 176   3                              }
 177   2                              else
 178   2                              {
 179   3                                      tc_Status=DOS_SUCCESS;  
 180   3                              }
 181   2                              break;
 182   2              }
 183   1              return tc_Status;
 184   1      }
 185          
 186          
 187          //! Write some logical sectors from a given LBA.
 188          /*!     
 189           *      \param  tdw_LogicSectorAddr             The starting LBA to be written.
 190           *      \param  tc_WriteSectorNumber    Number of sectors to be written.
 191           *      \param  tc_AppendW                              The append write flag.
 192           *      \return DOS_SUCCESS or DOS_FALSE
 193           */
 194          U8 DOS_Write_LogicSector(U32 tdw_LogicSectorAddr, U8 tc_WriteSectorNumber, U8 tc_AppendW)
 195          {
 196   1              data    U8      tc_BufIndex;
 197   1              data    U8      tc_WrSectorNum;
 198   1              xdata   U32 tdw_tempLogicSectorAddr;
 199   1              
 200   1              tdw_tempLogicSectorAddr=tdw_LogicSectorAddr;
 201   1              tc_WrSectorNum=tc_WriteSectorNumber;
 202   1      
 203   1              if(gb_ReadWriteDataArea == 0)
 204   1              {
 205   2                      tc_BufIndex=gc_PlayRecordDataBufHB;
 206   2              }
 207   1              else
 208   1              {
 209   2                      tc_BufIndex=gc_UserDataBufHB;
 210   2              }
 211   1      
 212   1              switch(gc_CurrentCard)
 213   1              {
 214   2                      case 0:
 215   2                              if(!tc_WrSectorNum)
 216   2                              {
 217   3                                      return (DOS_FALSE);
 218   3                              }                       
 219   2                      
 220   2                              if(tc_AppendW)
 221   2                              {
 222   3                                      //============================================================
 223   3                                      if(gc_NeedNewBlock==1)
 224   3                                      {
 225   4                                              if(gb_NeedEraseUpdateBlock==1)
 226   4                                              {
 227   5                                                      //dbprintf("appdw-S+C+E\n");
 228   5                                                      Dos_Write_LBA(tdw_tempLogicSectorAddr, tc_BufIndex, 0x03);//(JC)start+continue+end
 229   5                                                      gb_NeedEraseUpdateBlock=0;
 230   5                                                      gc_NeedNewBlock=1;
 231   5                                              }
 232   4                                              else
 233   4                                              {
 234   5                                                      //dbprintf("appdw-S+C\n");
 235   5                                                      Dos_Write_LBA(tdw_tempLogicSectorAddr, tc_BufIndex, 0x00);//(JC)start+continue
 236   5                                                      gc_NeedNewBlock=0;
 237   5                                              }
C51 COMPILER V9.00   DOSCOMM                                                               07/10/2012 15:51:52 PAGE 5   

 238   4                                      }
 239   3                                      else if(gc_NeedNewBlock==0)
 240   3                                      {
 241   4                                              if(gb_NeedEraseUpdateBlock==1)
 242   4                                              {
 243   5                                                      while(tc_WrSectorNum>1)
 244   5                                                      {
 245   6                                                              //dbprintf("appdw-C\n");
 246   6                                                              Dos_Write_LBA(tdw_tempLogicSectorAddr, tc_BufIndex, 0x01);//(JC)continue
 247   6                                                              tc_WrSectorNum--;
 248   6                                                              tdw_tempLogicSectorAddr++;
 249   6                                                      }
 250   5                                                      //dbprintf("appdw-C+E\n");
 251   5                                                      Dos_Write_LBA(tdw_tempLogicSectorAddr, tc_BufIndex, 0x02);//(JC)continue+end
 252   5                                                      gb_NeedEraseUpdateBlock=0;
 253   5                                                      gc_NeedNewBlock=1;
 254   5                                              }
 255   4                                              else
 256   4                                              {
 257   5                                                      //dbprintf("appdw-C\n");
 258   5                                                      Dos_Write_LBA(tdw_tempLogicSectorAddr, tc_BufIndex, 0x01);//(JC)continue
 259   5                                              }
 260   4                                      }
 261   3                              }
 262   2                              else
 263   2                              {
 264   3                                      while(tc_WrSectorNum)//(JC)mostly normal write 1 sector
 265   3                                      {
 266   4                                              //dbprintf("Normw-S+C+E\n");
 267   4                                              Dos_Write_LBA(tdw_tempLogicSectorAddr, tc_BufIndex, 0x03);
 268   4                                              tc_WrSectorNum--;
 269   4                                              tdw_tempLogicSectorAddr++;      
 270   4                                      }
 271   3                              }
 272   2                              break;
 273   2      
 274   2                      case 2:
 275   2                              if(!tc_WrSectorNum)
 276   2                              {
 277   3                                      return 1;
 278   3                              }
 279   2                              
 280   2                              tdw_tempLogicSectorAddr=tdw_LogicSectorAddr;
 281   2                              if(tc_WrSectorNum==0x01)
 282   2                              {
 283   3                                      SD_Write_LBA_Dos(tdw_tempLogicSectorAddr,tc_BufIndex, 0x03);                            
 284   3                              }
 285   2                              else
 286   2                              {                                       
 287   3                                      SD_Write_LBA_Dos(tdw_tempLogicSectorAddr,tc_BufIndex, 0x00);
 288   3                                      tc_WrSectorNum--;
 289   3                                      tdw_tempLogicSectorAddr++;
 290   3                                      while(tc_WrSectorNum)
 291   3                                      {
 292   4                                              SD_Write_LBA_Dos(tdw_tempLogicSectorAddr,tc_BufIndex, 0x01);
 293   4                                              tc_WrSectorNum--;
 294   4                                              tdw_tempLogicSectorAddr++;
 295   4                                      }
 296   3                                      SD_Write_LBA_Dos(tdw_tempLogicSectorAddr,tc_BufIndex, 0x04);
 297   3                              }
 298   2                              break;
 299   2              }
C51 COMPILER V9.00   DOSCOMM                                                               07/10/2012 15:51:52 PAGE 6   

 300   1              return 0;
 301   1      }
 302          
 303          
*** WARNING C291 IN LINE 94 OF ..\LIBSOURCE\DOS\DOSCOMM.C: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1046    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      47
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
