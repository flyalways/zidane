C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SD_HW
OBJECT MODULE PLACED IN .\obj\SD_HW.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\libsource\SD\SD_HW.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\lib
                    -source\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\SD_HW.lst) OBJECT(.\obj\SD_HW.obj)

line level    source

   1          #include "SPDA2K.h"
   2          xdata U8  gc_SD_CSD[16];
   3          xdata U8  gc_RespBuff[17];
   4          
   5          
   6          void  SD_Interface_Initial(void)
   7          {
   8   1              DEVICE_REG[0x00] = 0x06;                            // switch to sd interface
   9   1              DEVICE_REG[0x50] = 0x03;                            // reset sd & crc interface;
  10   1              DEVICE_REG[0x51] = 0x03;                            // set SD CLK  1/128 per clk,1 bit mode  
  11   1              DEVICE_REG[0x57] = 0xFF;                            // set rsp time out
  12   1              DEVICE_REG[0x58] = 0xFF;                            // crc time out 
  13   1              DEVICE_REG[0x56] = 0x02;
  14   1              SDMMC_SDRCA.WD   = 0x0000;                          // default RCA is 0 
  15   1              SD_Capacity.LW   = 0x0001; 
  16   1              gbt_SDHC_Type =0;                                                                       // 0:Stand Capacity , 1: High Capicity
  17   1              gbt_MMC_Type =0;                                  // 0:SD , 1: MMC
  18   1      }
  19          
  20          
  21          void  SD_CMD0_Reset(void)
  22          {
  23   1              DEVICE_REG[0x5B] = 0x40;                            // 0x40 | 0x00(Cmd_0)
  24   1              DEVICE_REG[0x5C] = 0x00;                            //
  25   1              DEVICE_REG[0x5D] = 0x00;                            // 
  26   1              DEVICE_REG[0x5E] = 0x00;                            // 
  27   1              DEVICE_REG[0x5F] = 0x00;                            // 
  28   1              SD_Trigger_CMD();                                   //
  29   1              SD_Check_Idle();                                    // check done
  30   1              SD_Send_DummyCLK(8);                                // 8 clks before send cmd
  31   1      }
  32          
  33          
  34          void SD_CMD55_PreACmd(void)
  35          {                                                                                       // Command 55                              
  36   1              DEVICE_REG[0x5B] = 0x77;                                // 0x40 | 0x37(Cmd_55)
  37   1              DEVICE_REG[0x5C] = SDMMC_SDRCA.BY[0];
  38   1              DEVICE_REG[0x5D] = SDMMC_SDRCA.BY[1];
  39   1              DEVICE_REG[0x5E] = 0x00;
  40   1              DEVICE_REG[0x5F] = 0x00;
  41   1              SD_Trigger_CMD();
  42   1              SD_Check_Idle();
  43   1              SD_Receive_Respond(gc_RespBuff,0,0);
  44   1      }    
  45          
  46          
  47          bit SD_Check_Idle(void)
  48          {
  49   1              xdata   U16     tw_SD_CountDown; 
  50   1              
  51   1              tw_SD_CountDown=2000;
  52   1              while(DEVICE_REG[0x54]&0x0F)
  53   1              {
  54   2                      if(--tw_SD_CountDown==0)
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 2   

  55   2                      {
  56   3                              DEVICE_REG[0x52] = 0x00;
  57   3                              DEVICE_REG[0x50] = 0x03;
  58   3                              return 1;
  59   3                      }
  60   2      
  61   2                      if(SD_Detect)
  62   2                      {
  63   3                              return 0;
  64   3                      }
  65   2              }
  66   1              return 0;  
  67   1      }
  68                 
  69          
  70          bit SD_ACmd41_OCR(void)
  71          {
  72   1          U16 tw_SD_CountDown;
  73   1      
  74   1              if(gbt_USB_Detected)
  75   1              { 
  76   2                      tw_SD_CountDown=PseudoCard_TimeOut;
  77   2              }
  78   1              else
  79   1              {
  80   2                      tw_SD_CountDown=(PseudoCard_TimeOut/2); 
  81   2              }
  82   1      
  83   1              do{     
  84   2                      SD_CMD55_PreACmd();
  85   2                      DEVICE_REG[0x5B]=0x69;  // ACMD41
  86   2                      if(gbt_SDHC_Type)
  87   2                      {       
  88   3                              DEVICE_REG[0x5C] = 0x40;
  89   3                      }
  90   2                      else
  91   2                      {
  92   3                              DEVICE_REG[0x5C] = 0x00;     
  93   3                      }       
  94   2                      DEVICE_REG[0x5D] = 0xFC;
  95   2                      DEVICE_REG[0x5E] = 0x00;
  96   2                      DEVICE_REG[0x5F] = 0x00;
  97   2                      SD_Trigger_CMD();
  98   2                      SD_Check_Idle();
  99   2                      SD_Receive_Respond(gc_RespBuff,0,0);
 100   2                      if(SD_Detect)
 101   2                      {
 102   3                              return 0;
 103   3                      }    
 104   2              
 105   2                      if((--tw_SD_CountDown==0))
 106   2                      {               
 107   3                              return 0;
 108   3                      }
 109   2              }while(!(gc_RespBuff[1]&0x80));
 110   1      
 111   1              if(gbt_SDHC_Type)
 112   1              {
 113   2                      if(gc_RespBuff[1]&0x40)
 114   2                      {
 115   3                              gbt_SDHC_Type =1;       // High Capacity
 116   3                      }
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 3   

 117   2                      else
 118   2                      {
 119   3                              gbt_SDHC_Type =0;       // Standard Capicity
 120   3                      }
 121   2              }
 122   1              return 1;   
 123   1         
 124   1      }    
 125          
 126          
 127          void SD_Cmd2_CID(void)
 128          {
 129   1              DEVICE_REG[0x5B] = 0x42;
 130   1              DEVICE_REG[0x5C] = 0x00;
 131   1              DEVICE_REG[0x5D] = 0x00;
 132   1              DEVICE_REG[0x5E] = 0x00;
 133   1              DEVICE_REG[0x5F] = 0x00;
 134   1              SD_Trigger_CMD();
 135   1              SD_Check_Idle();
 136   1              SD_Receive_Respond(gc_RespBuff,1,0);                // 136 bit    
 137   1      } 
 138          
 139          
 140          void SD_Cmd3_RCA(void)
 141          {
 142   1              if(gbt_MMC_Type)
 143   1              {
 144   2                      SDMMC_SDRCA.BY[0]=0x1F;
 145   2                      SDMMC_SDRCA.BY[1]=0x3C;
 146   2              }
 147   1              else
 148   1              {
 149   2                      SDMMC_SDRCA.BY[0] = 0x00;
 150   2                      SDMMC_SDRCA.BY[1] = 0x00;
 151   2              }
 152   1              XBYTE[0xB45B] = 0x43;
 153   1              XBYTE[0xB45C] = SDMMC_SDRCA.BY[0];
 154   1              XBYTE[0xB45D] = SDMMC_SDRCA.BY[1];
 155   1              XBYTE[0xB45E] = 0x00;
 156   1              XBYTE[0xB45F] = 0x00;
 157   1              SD_Trigger_CMD();
 158   1              SD_Check_Idle();
 159   1              SD_Receive_Respond(gc_RespBuff,0,0);    // 48 bit 
 160   1              
 161   1              if(!gbt_MMC_Type)
 162   1              {
 163   2                      SDMMC_SDRCA.BY[0] = gc_RespBuff[1];
 164   2                      SDMMC_SDRCA.BY[1] = gc_RespBuff[2];
 165   2              }  
 166   1      }
 167          
 168          
 169          void SD_Cmd8_Send_If_Cond(void)
 170          {
 171   1              DEVICE_REG[0x5B] = 0x48;
 172   1              DEVICE_REG[0x5C] = 0x00;
 173   1              DEVICE_REG[0x5D] = 0x00;
 174   1              DEVICE_REG[0x5E] = 0x01;
 175   1              DEVICE_REG[0x5F] = 0xAA;
 176   1              SD_Trigger_CMD();
 177   1              SD_Check_Idle();
 178   1              if(SD_Receive_Respond(gc_RespBuff,0,0))
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 4   

 179   1              {
 180   2                      gbt_SDHC_Type = 0; // 0:Stand Capacity , 1: High Capicity
 181   2              }
 182   1              else
 183   1              {
 184   2                      gbt_SDHC_Type = 1; // 0:Stand Capacity , 1: High Capicity
 185   2              }
 186   1      }
 187          
 188          
 189          void SD_Cmd9_CSD(void)
 190          {
 191   1              data    U8      tc_ReadBl_Len;
 192   1              data    U8      tc_CSizeMult;   
 193   1              xdata   U8      tc_Counter;
 194   1              data    U16 tw_BlockLen;
 195   1              data    U16     tw_Mult;
 196   1              data    U16     tw_CSize;
 197   1              xdata   U32     tdw_CardTotalSize;
 198   1              xdata   U32     tdw_SD_BlockNum;    
 199   1          
 200   1              DEVICE_REG[0x5B] = 0x49;
 201   1              DEVICE_REG[0x5C] = SDMMC_SDRCA.BY[0];
 202   1              DEVICE_REG[0x5D] = SDMMC_SDRCA.BY[1];
 203   1              DEVICE_REG[0x5E] = 0x00;
 204   1              DEVICE_REG[0x5F] = 0x00;
 205   1              SD_Trigger_CMD();
 206   1              SD_Check_Idle();
 207   1              SD_Receive_Respond(gc_RespBuff,1,0);    // 136 bit  
 208   1         
 209   1          for(tc_Counter=0; tc_Counter<16; tc_Counter++)
 210   1              {
 211   2              gc_SD_CSD[tc_Counter]=gc_RespBuff[tc_Counter+1];
 212   2          }
 213   1      
 214   1          if(gbt_MMC_Type)
 215   1              {
 216   2              tc_ReadBl_Len=gc_SD_CSD[0x05]&0x0f;     
 217   2              tw_BlockLen=0x01<< (tc_ReadBl_Len);// 直接轉成sector
 218   2                      tw_CSize        =  (gc_SD_CSD[6]&0X03)<<10;
 219   2                      tw_CSize    =  tw_CSize|(gc_SD_CSD[7]<<2);
 220   2                      tw_CSize    =  tw_CSize|(gc_SD_CSD[8]>>6);
 221   2                      tc_CSizeMult=((gc_SD_CSD[9] & 0x03) << 1) | (gc_SD_CSD[10] >> 7); 
 222   2                      tw_Mult =       0x0001 << (tc_CSizeMult + 2);
 223   2                      tdw_SD_BlockNum = ((U32)(tw_CSize +     1) *tw_Mult);              
 224   2                      tdw_CardTotalSize = (U32)(tdw_SD_BlockNum * tw_BlockLen);
 225   2                      
 226   2                      if(gbt_SDHC_Type)
 227   2                      {
 228   3                              SD_Capacity.LW    =  (tdw_CardTotalSize);  // 直接就是Sector 
 229   3                              gdw_CARD_TotalSizeMB = (SD_Capacity.LW);
 230   3                      }
 231   2                      else
 232   2                      {
 233   3                              SD_Capacity.LW    =  (tdw_CardTotalSize>>9); 
 234   3                              gdw_CARD_TotalSizeMB = (SD_Capacity.LW); 
 235   3              }       
 236   2          }
 237   1          else
 238   1              {       
 239   2              if((gc_SD_CSD[0x00]&0xC0)==0x40)
 240   2                      {//SD2.0 or High Capicity        
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 5   

 241   3                              tdw_CardTotalSize =  ((gc_SD_CSD[7]&0x3F)<<16) |(gc_SD_CSD[8]<<8)|gc_SD_CSD[9];
 242   3                              SD_Capacity.LW    =  (tdw_CardTotalSize+1)<<10 ;    
 243   3                              gdw_CARD_TotalSizeMB = (SD_Capacity.LW);
 244   3              }
 245   2                  else
 246   2                      {   //SD1.1 or Standard Capicity    
 247   3                      tc_ReadBl_Len=gc_SD_CSD[0x05]&0x0f;     
 248   3                      tw_BlockLen=0x01<< (tc_ReadBl_Len);// 直接轉成sector
 249   3                              tw_CSize        =  (gc_SD_CSD[6]&0X03)<<10;
 250   3                              tw_CSize    =  tw_CSize|(gc_SD_CSD[7]<<2);
 251   3                              tw_CSize    =  tw_CSize|(gc_SD_CSD[8]>>6);
 252   3                              tc_CSizeMult=((gc_SD_CSD[9] & 0x03) << 1) | (gc_SD_CSD[10] >> 7); 
 253   3                              tw_Mult =       0x0001 << (tc_CSizeMult + 2);
 254   3                              tdw_SD_BlockNum = ((U32)(tw_CSize +     1) *tw_Mult);              
 255   3                              tdw_CardTotalSize = (U32)(tdw_SD_BlockNum * tw_BlockLen);
 256   3                              SD_Capacity.LW    =  (tdw_CardTotalSize>>9);    
 257   3                              gdw_CARD_TotalSizeMB = (SD_Capacity.LW); 
 258   3                      }
 259   2              }
 260   1      } 
 261          
 262          
 263          void SD_Trigger_CMD(void)
 264          {
 265   1              DEVICE_REG[0x52] = 0x20;        // 8 clks before send cmd 
 266   1          SD_Check_Idle();
 267   1          DEVICE_REG[0x50] = 0x03;    // reset crc                       
 268   1          DEVICE_REG[0x52] = 0x01;    // send command  
 269   1      }
 270          
 271          
 272          void SD_TrigCMD_Receive_Respond(void)
 273          {
 274   1              DEVICE_REG[0x52] = 0x20;        // 8 clks before send cmd 
 275   1          SD_Check_Idle();
 276   1          DEVICE_REG[0x50] = 0x03;    // reset crc 
 277   1          DEVICE_REG[0x56] = 0xE0;
 278   1          DEVICE_REG[0x51]&= 0xF7;  
 279   1              DEVICE_REG[0x52] = 0x01;        // send command
 280   1              SD_Check_Idle(); 
 281   1      }
 282          
 283          
 284          bit  SD_Identification_Flow(void)
 285          {    
 286   1          SD_Interface_Initial();
 287   1              if(SD_Detect)
 288   1              {
 289   2                      goto RET;
 290   2          }
 291   1          SD_Send_DummyCLK(80);                                                               // send 64 clk 
 292   1          SD_CMD0_Reset();
 293   1              if(SD_Detect)
 294   1              {
 295   2                      goto RET;
 296   2          } 
 297   1      
 298   1          SD_MMC_Check_Mode();
 299   1              if(SD_Detect)
 300   1              {
 301   2                      goto RET;
 302   2          }
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 6   

 303   1          
 304   1              if(gbt_MMC_Type)
 305   1              {//MMC card
 306   2              SD_CMD0_Reset();
 307   2              if(!MMC_Cmd01_OCR_Wait_Ready())
 308   2                      {
 309   3                              goto RET;
 310   3              }
 311   2              DEVICE_REG[0x51] |=0x40;  // MMC mode           
 312   2          }
 313   1          else
 314   1              {                       // SD card 
 315   2                      SD_CMD0_Reset();
 316   2              SD_Cmd8_Send_If_Cond();   
 317   2              if(!SD_ACmd41_OCR())
 318   2                      {
 319   3                              goto RET;
 320   3              }
 321   2          }
 322   1          SD_Cmd2_CID();
 323   1              if(SD_Detect)
 324   1              {
 325   2                      goto RET;
 326   2          }
 327   1          SD_Cmd3_RCA();              // get RCA
 328   1              if(SD_Detect)
 329   1              {
 330   2                      goto RET;
 331   2          }   
 332   1          SD_Cmd9_CSD();     // det CSD
 333   1              if(SD_Detect)
 334   1              {
 335   2                      goto RET;
 336   2          }
 337   1              SD_Cmd13_Status();
 338   1              if(SD_Detect)
 339   1              {
 340   2                      goto RET;
 341   2          }
 342   1              SD_Cmd7_Select();// pust to transfer stat
 343   1              if(SD_Detect)
 344   1              {
 345   2                      goto RET;
 346   2          }   
 347   1              if(!gbt_MMC_Type)
 348   1              {
 349   2                      DEVICE_REG[0x51]|= 0x04;  // set 4bit mode
 350   2              SD_ACmd6_BusWidth(1);   // form 1 bit to 4 bit
 351   2          }   
 352   1              if(SD_Detect)
 353   1              {
 354   2                      goto RET;
 355   2          }
 356   1          DEVICE_REG[0x51]&= 0xFD;  
 357   1          DEVICE_REG[0x56]|=0xA0;    
 358   1          SD_Cmd16_Blocklen();        // set 512 block length
 359   1              if(SD_Detect)
 360   1              {
 361   2                      goto RET;
 362   2          }
 363   1              return 1;
 364   1      RET:
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 7   

 365   1              USER_DelayDTms(150);
 366   1              return 0;
 367   1      }
 368          
 369          
 370          void SD_Cmd7_Select(void)
 371          {
 372   1              DEVICE_REG[0x5B] = 0x47;
 373   1              DEVICE_REG[0x5C] = SDMMC_SDRCA.BY[0];
 374   1              DEVICE_REG[0x5D] = SDMMC_SDRCA.BY[1];
 375   1              DEVICE_REG[0x5E] = 0x00;
 376   1              DEVICE_REG[0x5F] = 0x00;
 377   1              SD_Trigger_CMD();
 378   1              SD_Check_Idle();
 379   1              SD_Receive_Respond(gc_RespBuff,0,0);                // 48 bit  
 380   1      }                              
 381          
 382          
 383          void SD_Cmd13_Status(void)
 384          {
 385   1              DEVICE_REG[0x5B] = 0x4D;
 386   1              DEVICE_REG[0x5C] = SDMMC_SDRCA.BY[0];
 387   1              DEVICE_REG[0x5D] = SDMMC_SDRCA.BY[1];
 388   1              DEVICE_REG[0x5E] = 0x00;
 389   1              DEVICE_REG[0x5F] = 0x00;
 390   1              SD_Trigger_CMD();
 391   1              SD_Check_Idle();
 392   1              SD_Receive_Respond(gc_RespBuff,0,0);                // 48 bit        
 393   1      }
 394          
 395          
 396          void SD_ACmd6_BusWidth(bit _4bit)
 397          {
 398   1              SD_CMD55_PreACmd();
 399   1              DEVICE_REG[0x5B] = 0x46;
 400   1              DEVICE_REG[0x5C] = 0x00;
 401   1              DEVICE_REG[0x5D] = 0x00;
 402   1              DEVICE_REG[0x5E] = 0x00;
 403   1              if(_4bit)
 404   1              {
 405   2                      DEVICE_REG[0x5F] = 0x02;
 406   2              }
 407   1              else
 408   1              {
 409   2                      DEVICE_REG[0x5F] = 0x00;
 410   2              }
 411   1              SD_Trigger_CMD();
 412   1              SD_Check_Idle();
 413   1              SD_Receive_Respond(gc_RespBuff,0,0);                // 48 bit    
 414   1      }
 415          
 416          
 417          void SD_Cmd12_Stop(void)
 418          {
 419   1              DEVICE_REG[0x5B] = 0x4C;
 420   1              DEVICE_REG[0x5C] = 0x00;
 421   1              DEVICE_REG[0x5D] = 0x00;
 422   1              DEVICE_REG[0x5E] = 0x00;
 423   1              DEVICE_REG[0x5F] = 0x00;
 424   1              SD_TrigCMD_Receive_Respond(); 
 425   1      }            
 426          
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 8   

 427          
 428          void SD_Cmd16_Blocklen(void)
 429          {
 430   1              DEVICE_REG[0x5B] = 0x50;
 431   1              DEVICE_REG[0x5C] = 0x00;
 432   1              DEVICE_REG[0x5D] = 0x00;
 433   1              DEVICE_REG[0x5E] = 0x02;
 434   1              DEVICE_REG[0x5F] = 0x00;
 435   1              SD_Trigger_CMD();
 436   1              SD_Check_Idle();
 437   1              SD_Receive_Respond(gc_RespBuff,0,0);                // 48 bit    
 438   1              DEVICE_REG[0x55] =0x00;
 439   1              DEVICE_REG[0x56]|=0x02;
 440   1      }
 441          
 442          
 443          void SD_Send_DummyCLK(U8 CLK_Num)
 444          {
 445   1              U8 k;
 446   1      
 447   1              CLK_Num=CLK_Num>>3;
 448   1              for(k=0;k<CLK_Num;k++)
 449   1              {
 450   2                      DEVICE_REG[0x52] = 0x20;// 8 clks before send cmd 
 451   2              SD_Check_Idle();
 452   2          }         
 453   1      }
 454          
 455          
 456          U8 SD_Receive_Respond(U8 *tc_RespBuff,U8 tc_Resptype136bit, U8 tc_CRC)
 457          {
 458   1              data    U8      tc_FullFlag;
 459   1              data    U8      tc_CRC7;
 460   1              data    U8      tc_i;
 461   1              xdata   U16     tw_SD_CountDown;     
 462   1      
 463   1              tw_SD_CountDown = 80;
 464   1      
 465   1              if(tc_Resptype136bit)
 466   1              {
 467   2                      DEVICE_REG[0x51] |=0x08;                        
 468   2              }
 469   1              else
 470   1              {       
 471   2                      DEVICE_REG[0x51] &=~0x08;
 472   2              }       
 473   1              DEVICE_REG[0x57]  = 0xFF; 
 474   1              DEVICE_REG[0x56] |= 0x20; // auto send dummy clk
 475   1              DEVICE_REG[0x52]  = 0x02;
 476   1              do
 477   1              {
 478   2                      tc_FullFlag=(DEVICE_REG[0x53]&0x02);
 479   2                      if((DEVICE_REG[0x53]&0x40)||(--tw_SD_CountDown==0))
 480   2                      {
 481   3                              DEVICE_REG[0x50] =0x03; 
 482   3                              return 1;     // Time out
 483   3                      }               
 484   2              }while((tc_FullFlag==0));
 485   1              //48bit
 486   1              tc_RespBuff[0] = DEVICE_REG[0x60];
 487   1              tc_RespBuff[1] = DEVICE_REG[0x61];
 488   1              tc_RespBuff[2] = DEVICE_REG[0x62];
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 9   

 489   1              tc_RespBuff[3] = DEVICE_REG[0x63];
 490   1              tc_RespBuff[4] = DEVICE_REG[0x64];
 491   1              tc_RespBuff[5] = DEVICE_REG[0x65];      
 492   1      
 493   1              tc_CRC7=tc_RespBuff[5];
 494   1              if(tc_Resptype136bit)   //136 bit
 495   1              {
 496   2                      for(tc_i=0;tc_i<11;tc_i++) 
 497   2                      {
 498   3                              do
 499   3                              {
 500   4                                      tc_FullFlag=(DEVICE_REG[0x53]&0x02);
 501   4                                      if((DEVICE_REG[0x53]&0x40)||(--tw_SD_CountDown==0))
 502   4                                      {
 503   5                                              DEVICE_REG[0x50] =0x03; 
 504   5                                              return 1;     // Time out
 505   5                                      }               
 506   4                              }while((tc_FullFlag==0));               
 507   3                              tc_RespBuff[6+tc_i] = DEVICE_REG[0x65];         
 508   3                      }
 509   2                      tc_CRC7=tc_RespBuff[16];
 510   2              }
 511   1              if((tc_CRC7!=DEVICE_REG[0x66])&&tc_CRC)
 512   1              {//CRC error
 513   2                      DEVICE_REG[0x50] =0x03;
 514   2                      return 0x01;            
 515   2              }       
 516   1              return 0;       
 517   1      } 
 518          
 519          
 520          void  SD_MMC_Check_Mode(void)
 521          {
 522   1              SD_CMD0_Reset();
 523   1              if(MMC_Cmd01_OCR())
 524   1              {   // By CMD1     
 525   2                      gbt_MMC_Type =1;  // MMC Mode
 526   2              }
 527   1              else
 528   1              {
 529   2                      gbt_MMC_Type =0;  //SD Mode
 530   2              }
 531   1              SD_Send_DummyCLK(64);         
 532   1      }
 533          /***************************************************************************
 534          * NAME:         bit MMC_Cmd01_OCR(void)
 535          * DESCRIPTION:
 536          ***************************************************************************/
 537          bit MMC_Cmd01_OCR(void)
 538          {
 539   1              DEVICE_REG[0x5B] = 0x41;
 540   1              DEVICE_REG[0x5C] = 0x80;
 541   1              DEVICE_REG[0x5D] = 0xFF;                                //2.7~3.6 Volt
 542   1              DEVICE_REG[0x5E] = 0x00;
 543   1              DEVICE_REG[0x5F] = 0x00;
 544   1              SD_Trigger_CMD();
 545   1              SD_Check_Idle();
 546   1              if(SD_Receive_Respond(gc_RespBuff,0,0))
 547   1              {                       // Time out -->No Responce 
 548   2                      return 0;
 549   2              }
 550   1              else
C51 COMPILER V9.00   SD_HW                                                                 07/10/2012 15:51:45 PAGE 10  

 551   1              {               
 552   2                      return 1;               
 553   2              } 
 554   1      }
 555          
 556          
 557          bit MMC_Cmd01_OCR_Wait_Ready(void)
 558          {    
 559   1              xdata   U16     tw_SD_CountDown;
 560   1              
 561   1              if(gbt_USB_Detected)
 562   1              { 
 563   2                      tw_SD_CountDown = PseudoCard_TimeOut;
 564   2              }
 565   1              else
 566   1              {
 567   2                      tw_SD_CountDown = (PseudoCard_TimeOut/2);       
 568   2              }
 569   1              
 570   1              do{
 571   2                      DEVICE_REG[0x5B] = 0x41;
 572   2                      DEVICE_REG[0x5C] = 0x80;
 573   2                      DEVICE_REG[0x5D] = 0xFF;
 574   2                      DEVICE_REG[0x5E] = 0x00;
 575   2                      DEVICE_REG[0x5F] = 0x00;
 576   2                      SD_Trigger_CMD();
 577   2                      SD_Check_Idle();
 578   2                      SD_Receive_Respond(gc_RespBuff,0,0);
 579   2                      if(SD_Detect)
 580   2                      {
 581   3                              return 0;
 582   3                      }    
 583   2                      if((--tw_SD_CountDown==0))
 584   2                      {
 585   3                              return 0;
 586   3                      }
 587   2              }while(!(gc_RespBuff[1]&0x80));    
 588   1      
 589   1              if(gc_RespBuff[1]&0x40)
 590   1              {
 591   2                      gbt_SDHC_Type =1;       // High Capacity MMC Sector mode        
 592   2              }
 593   1              else
 594   1              {
 595   2                      gbt_SDHC_Type =0;       // Standard Capicity   MMC Byte mode
 596   2              }       
 597   1              return 1;       
 598   1      }  


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1431    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     33      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      11
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
