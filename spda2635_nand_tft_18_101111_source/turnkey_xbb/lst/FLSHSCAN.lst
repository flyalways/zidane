C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE FLSHSCAN
OBJECT MODULE PLACED IN .\obj\FLSHSCAN.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\libsource\FLASH\FLSHSCAN.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(
                    -..\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\FLSHSCAN.lst) OBJECT(.\obj\FLSHSCAN.obj)

line level    source

   1          /*
   2           *                          Sunplus mMedia Inc.
   3           *
   4           *   (c) Copyright 2008~, Sunplus mMedia Inc., Hsinchu, Taiwan R.O.C.
   5           *                          All Right Reserved
   6           */
   7          /*! \file       flshscan.c
   8           *      \brief  
   9           *
  10           *      \author jay
  11           */
  12          
  13          #include "SPDA2K.h"
  14          
  15          /*********************************************************************************
  16          * NAME:              void Create_Zone_Lookup_Table(void)
  17          * DESCRIPTION:   // SPDA26xx flash  plan
  18          *********************************************************************************/
  19          
  20          void Create_Zone_Lookup_Table(void) {   
  21   1              U16             tw_Zone_index,tw_Index_Temp, tw_HBlockCnt,tw_SwapCnt;  
  22   1              U8              tc_ExtCnt,tc_DmyCnt,tc_i,tc_j;
  23   1              bit     tbt_HBlock_Exist,tbt_DmyErr,tbt_RanErr,tbt_FastErr,tbt_ExtErr; 
  24   1              bit     tbt_Tempflag;
  25   1              U8      tc_PwrInx,tc_SwapInx;
  26   1              tw_HBlockCnt =0;
  27   1              //---------- initial variable value---/
  28   1              tc_ExtCnt  =0;
  29   1              tc_DmyCnt  =0;
  30   1              tw_SwapCnt =0;
  31   1              tbt_DmyErr=0;
  32   1              tbt_RanErr=0;
  33   1              tbt_FastErr=0;
  34   1              tbt_ExtErr=0; 
  35   1              tc_SwapInx =0;
  36   1      //      dbprintf("\n Create_Zone_Lookup_Table:%x",gw_WhichGroup);
  37   1              //------- clear table---------//  
  38   1              memset(Mapping_Table,0xFF,1024);
  39   1              ExtErrBlock[15] =0;                        
  40   1          DmyErrBlock[15] =0;                
  41   1          RanErrBlock[15] =0;                            
  42   1          FastErrBlock[15] =0;                        
  43   1              //------ load bmt table -----// 
  44   1              FDBP.cFDev =BMT.cFDev;
  45   1              FDBP.cFPlane = BMT.cFPlane;
  46   1              FDBP.wFBlock = BMT.wFBlock;
  47   1              FDBP.wFPage  = BMT.wFPage;
  48   1              FDBP.cFInAddr = BMT.cFInAddr;
  49   1              Device_Read_SRAM_Index.BY[0] = 0x90;    
  50   1              Device_Read_SRAM_Index.BY[1] = 0x00;
  51   1      
  52   1              if(Flash_Sequent_Read(2)){// bmt table fail -->read backup bmt block 
  53   2                      BMT.wFBlock = BMTTable_Backup[BMT.cFDev];               
  54   2                      FDBP.cFDev =BMT.cFDev;
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 2   

  55   2                      FDBP.cFPlane = BMT.cFPlane;
  56   2                      FDBP.wFBlock = BMT.wFBlock;
  57   2                      FDBP.wFPage  = BMT.wFPage;
  58   2                      FDBP.cFInAddr = BMT.cFInAddr;
  59   2                      Device_Read_SRAM_Index.BY[0] = 0x90;    
  60   2                      Device_Read_SRAM_Index.BY[1] = 0x00;
  61   2                      Flash_Sequent_Read(2); 
  62   2              }       
  63   1              for(tw_Index_Temp = 0; tw_Index_Temp < ( SYS_ZONE.wZONE_SIZE+ZONE_TOTAL_OTHER); tw_Index_Temp ++){ 
  64   2                      tbt_HBlock_Exist=0;
  65   2                      FDBP.wFBlock = Source_Table[tw_Index_Temp];
  66   2                      FDBP.cFPlane = 0;
  67   2                      FDBP.wFPage  = 0;
  68   2                      FDBP.cFInAddr=0;
  69   2                      Device_Read_SRAM_Index.BY[0] = 0x98;//0601 Jay change 0x80-->0x98
  70   2                      Device_Read_SRAM_Index.BY[1] = 0x00;
  71   2                      Flash_ReadSpare(4);                     
  72   2                      switch (ZSpare[0]){
  73   3                              case 0xA5:  // HBlock & External Block-->0xA5 |PW_Index|HBlock|Erase_Cnt|
  74   3                                      tw_Zone_index =ZSpare[2];
  75   3                                      if(Mapping_Table[tw_Zone_index]!=0xFFFF){
  76   4                                              APort_FBlock[1] = Source_Table[tw_Index_Temp];
  77   4                                              APort_FCNT  [1] = ZSpare[3];
  78   4                                              FDBP.wFBlock = Source_Table[tw_Index_Temp];
  79   4                                              FDBP.cFPlane=0;
  80   4                                              FDBP.wFPage  = NAND_INFO.wPAGE_NUM-1;
  81   4                                              FDBP.cFInAddr=0;
  82   4                                              Device_Read_SRAM_Index.BY[0] = 0x98;//0601 Jay change 0x80-->0x98
  83   4                                              Device_Read_SRAM_Index.BY[1] = 0x00;
  84   4                                              Flash_ReadSpare(4);
  85   4                                              //if((ZSpare[0]==0xA5)&& (ZSpare[2]==tw_Zone_index)){//最後一頁也有資料,需跟另一個block 比對
  86   4                                              if((ZSpare[0]==0xA5)){//0601 Jay fix 
  87   5                                                      tc_PwrInx = ZSpare[1];
  88   5                                                      FDBP.wFBlock = Mapping_Table[tw_Zone_index];
  89   5                                                      FDBP.cFPlane = 0;
  90   5                                                      FDBP.wFPage  = NAND_INFO.wPAGE_NUM-1;
  91   5                                                      FDBP.cFInAddr= 0;
  92   5                                                      Device_Read_SRAM_Index.BY[0] = 0x98;//0601 Jay change 0x80-->0x98
  93   5                                                      Device_Read_SRAM_Index.BY[1] = 0x00;
  94   5                                                      Flash_ReadSpare(4);     
  95   5                                                      //if((ZSpare[0]==0xA5)&& (ZSpare[2]==tw_Zone_index)){//糟糕兩個都是到最後一頁-->不正常斷電比對pwr in
             -dex或是有Dummy block 
  96   5                                                      if((ZSpare[0]==0xA5)){//0601 Jay fix  
  97   6                                                              if(tc_PwrInx!=(ZSpare[1]+1)){//source table的是Hblock 
  98   7                                                                      APort_FBlock[1] = Mapping_Table[tw_Zone_index];
  99   7                                                                      Mapping_Table[tw_Zone_index]= Source_Table[tw_Index_Temp];
 100   7                                                                      Wear_Table[tw_Zone_index] = APort_FCNT[1];
 101   7                                                                      APort_FCNT[1] = ZSpare[3];                                                      
 102   7                                                              }
 103   6                                                              else{//不用處理，原本就填完了
 104   7                                                                      tc_PwrInx = ZSpare[1];
 105   7                                                              }
 106   6                                                      }
 107   5                                                      else{//最後一頁沒資料所以原本HBlock 是EXT Block ,source table的是Hblock 
 108   6                                                              APort_FBlock[1] = Mapping_Table[tw_Zone_index];
 109   6                                                              Mapping_Table[tw_Zone_index]= Source_Table[tw_Index_Temp];
 110   6                                                              Wear_Table[tw_Zone_index] = APort_FCNT[1];
 111   6                                                              APort_FCNT[1] = ZSpare[3];              
 112   6                                                      }                                               
 113   5                                              }
 114   4                                              //-------- 處理EXT 排列問題-----------------//
 115   4                                              tbt_Tempflag =0;
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 3   

 116   4                                              for(tc_i=0;tc_i<Extend_NUM;tc_i++){  // 先尋找是否有相同EXT
 117   5                                                      if(tw_Zone_index==Mapping_Table[EINX+tc_i]){
 118   6                                                              if(Mapping_Table[EBK+tc_i]==0xFFFF){//先檢查是否已經有Blokck 佔住
 119   7                                                                      tbt_Tempflag=1;
 120   7                                                                      Mapping_Table[EBK+tc_i]=APort_FBlock[1];
 121   7                                                                      Wear_Table[ECNT+tc_i] =APort_FCNT[1];
 122   7                                                                      QTable.BY[0] = tc_PwrInx;
 123   7                                                                      QTable.BY[1] = tc_PwrInx+1;     
 124   7                                                                      Mapping_Table[PWR_INX+tc_i]= QTable.WD;
 125   7                                                                      tc_ExtCnt++;
 126   7                                                                      break;
 127   7                                                              }
 128   6                                                      }
 129   5                                              }
 130   4                                              //都沒有找到相同的Index-->a:  ALL oxFFFF, OR  B. 非oxFFFF,但是沒有符合的
 131   4                                              if(!tbt_Tempflag){// a :all 0xFFFF
 132   5                                                      for(tc_i=0;tc_i<Extend_NUM;tc_i++){
 133   6                                                              if(Mapping_Table[EINX+tc_i]==0xFFFF){
 134   7                                                                      Mapping_Table[EINX+tc_i]=tw_Zone_index; 
 135   7                                                                      Mapping_Table[EBK+tc_i]=APort_FBlock[1];
 136   7                                                                      Wear_Table[DCNT+tc_i] =APort_FCNT[1];
 137   7                                                                      QTable.BY[0] = tc_PwrInx;
 138   7                                                                      QTable.BY[1] = tc_PwrInx+1;     
 139   7                                                                      Mapping_Table[PWR_INX+tc_i]= QTable.WD;                                                         
 140   7                                                                      tc_ExtCnt++;
 141   7                                                                      tbt_Tempflag =1;
 142   7                                                                      break;
 143   7                                                              }
 144   6                                                      }                       
 145   5                                              }
 146   4                                              if(!tbt_Tempflag){//先記錄下來
 147   5                                                      tc_i=ExtErrBlock[15];
 148   5                                                      ExtErrBlock[tc_i] =APort_FBlock[1];
 149   5                                                      tc_i++;
 150   5                                                      ExtErrBlock[15]= tc_i;
 151   5                                                      tbt_ExtErr =1;
 152   5                                              }
 153   4                                      }       
 154   3                                      else{            
 155   4                                              Mapping_Table[tw_Zone_index] =  Source_Table[tw_Index_Temp];
 156   4                                              Wear_Table[tw_Zone_index] = ZSpare[3];
 157   4                                              tw_HBlockCnt++;
 158   4                                      }
 159   3                                      break;
 160   3                              case 0x5A: // Dummy Block  --> 0x5A | Zone |Erase_Cnt | E_page
 161   3                                      tw_Zone_index =ZSpare[2];
 162   3                                      tbt_Tempflag =0;
 163   3                                      for(tc_i=0;tc_i<Extend_NUM;tc_i++){  // 先尋找是否有相同EXT
 164   4                                              if(tw_Zone_index==Mapping_Table[EINX+tc_i]){
 165   5                                                      if(Mapping_Table[DBK+tc_i]==0xFFFF){// 先檢查是否是空的∼∼
 166   6                                                              tbt_Tempflag=1;
 167   6                                                              Mapping_Table[DBK+tc_i]=Source_Table[tw_Index_Temp];
 168   6                                                              Wear_Table[DCNT+tc_i] =ZSpare[3];
 169   6                                                              tc_DmyCnt++;
 170   6                                                              break;
 171   6                                                      }
 172   5                                              }
 173   4                                      }
 174   3                                      //都沒有找到相同的Index-->a:  ALL oxFFFF, OR  B. 非oxFFFF,但是沒有符合的
 175   3                                      if(!tbt_Tempflag){
 176   4                                              for(tc_i=0;tc_i<Extend_NUM;tc_i++){
 177   5                                                      if(Mapping_Table[EINX+tc_i]==0xFFFF){
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 4   

 178   6                                                              Mapping_Table[EINX+tc_i]=tw_Zone_index; 
 179   6                                                              Mapping_Table[DBK+tc_i]=Source_Table[tw_Index_Temp];
 180   6                                                              Wear_Table[DCNT+tc_i] =ZSpare[3];
 181   6                                                              tc_DmyCnt++;
 182   6                                                              tbt_Tempflag =1;
 183   6                                                              break;
 184   6                                                      }
 185   5                                              }                       
 186   4                                      }
 187   3                                      if(!tbt_Tempflag){//先記錄下來
 188   4                                              tc_i=DmyErrBlock[15];
 189   4                                              DmyErrBlock[tc_i] =Source_Table[tw_Index_Temp];
 190   4                                              tc_i++;
 191   4                                              DmyErrBlock[15]= tc_i;                          
 192   4                                              tbt_DmyErr =1;
 193   4                                      }
 194   3                                      break;
 195   3                              case 0x55: // Random Block --> 0x55 | Zone |HBlock | Erase_Cnt  
 196   3                                      if(Mapping_Table[RBK]==0xFFFF){
 197   4                                              Mapping_Table[RBK]=Source_Table[tw_Index_Temp];
 198   4                                              Wear_Table[RCNT] = ZSpare[3];
 199   4                                      }
 200   3                                      else{                   
 201   4                                              tc_i=RanErrBlock[15];
 202   4                                              RanErrBlock[tc_i] =Source_Table[tw_Index_Temp];
 203   4                                              tc_i++;
 204   4                                              RanErrBlock[15]= tc_i;                  
 205   4                                              tbt_RanErr =1;
 206   4                                      }                               
 207   3                                      break;
 208   3                              case 0xAA: // FastBMT Block --> 0xAA | Zone |XXXX |Erase_Cnt 
 209   3                                      if(FAST_BMTTable[gw_WhichGroup]==0xFFFF){                       
 210   4                                              FAST_BMTTable[gw_WhichGroup]=Source_Table[tw_Index_Temp];
 211   4                                              FAST_BMTPage_Table[gw_WhichGroup] =0x00;
 212   4                                              Wear_Table[FCNT] = (ZSpare[3]+1);
 213   4                                              FDBP.cFDev =BMT.cFDev;
 214   4                                              FDBP.wFBlock =  FAST_BMTTable[gw_WhichGroup];
 215   4                                              FDBP.cFPlane =0;
 216   4                                              Flash_EraseOneBlock_NO_ChkRdy();
 217   4                                                                              
 218   4                                      }
 219   3                                      else{                   
 220   4                                              tc_i=FastErrBlock[15];
 221   4                                              FastErrBlock[tc_i] =Source_Table[tw_Index_Temp];
 222   4                                              tc_i++;
 223   4                                              FastErrBlock[15]= tc_i;
 224   4                                              tbt_FastErr =1;
 225   4                                      }                               
 226   3                                      break;  
 227   3                                      
 228   3                              default: //  0xFF : SWAP Block  or other  status  
 229   3                                      SwapTemp_Table[tw_SwapCnt] = Source_Table[tw_Index_Temp];
 230   3                                      tw_SwapCnt++;                           
 231   3                                      break;
 232   3                      
 233   3                      }
 234   2              }
 235   1              //dbprintf("\n tw_Index_Temp:%x",tw_Index_Temp);
 236   1              //-------- Error Handle---------------------------//
 237   1              if(tbt_ExtErr){
 238   2              // 出現兩個相同的EX 可能是D＆E合併後，來不及Erase，
 239   2              // 任何一個Ext 都可以，只要在跟Dummy再一次       
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 5   

 240   2      //              dbprintf("\n External error");
 241   2                      for(tc_j=0; tc_j<ExtErrBlock[15];tc_j++){
 242   3                              FDBP.cFDev=BMT.cFDev;
 243   3                              FDBP.cFPlane =0;
 244   3                              FDBP.wFBlock = ExtErrBlock[tc_j]; 
 245   3                              FDBP.wFPage  = 0;
 246   3                              FDBP.cFInAddr =0;
 247   3                              Device_Read_SRAM_Index.WD =0x9800;//0601 Jay change 0x8000-->0x9800
 248   3                              Flash_ReadSpare (4);            
 249   3                              gw_TargetBlock = ExtErrBlock[tc_j];
 250   3                              QTable.WD = Search_Last_Page(gw_TargetBlock);           
 251   3                              tbt_Tempflag =0;
 252   3                              for(tc_i=0;tc_i<Extend_NUM;tc_i++){  
 253   4                                      if(ZSpare[2]==Mapping_Table[EINX+tc_i]){
 254   5                                              FDBP.cFDev=BMT.cFDev;
 255   5                                              SQTable.WD =Search_Last_Page(Mapping_Table[EBK+tc_i]);
 256   5                                              tbt_Tempflag=1;
 257   5                                              break;
 258   5                                      }
 259   4                              }
 260   3                              if(tbt_Tempflag){
 261   4                                      if(SQTable.WD<QTable.WD){// 原本的Ex 比較小需交換
 262   5                                              ExtErrBlock[tc_j]= Mapping_Table[EBK+tc_i];
 263   5                                              Mapping_Table[EBK+tc_i] = gw_TargetBlock;
 264   5                                              Wear_Table[ECNT+tc_i ] =ZSpare[3];                                      
 265   5                                      }                               
 266   4                              }
 267   3                              SwapTemp_Table[tw_SwapCnt] =ExtErrBlock[tc_j] ;
 268   3                              tw_SwapCnt++;                   
 269   3                      }
 270   2                                              
 271   2              
 272   2              }
 273   1              else if(tbt_DmyErr){
 274   2              // 出現兩個Dummy 可能是Dummy 已經滿了要搬移或是來不及Erase ,
 275   2              // 保留多的哪一個再來重新處理即可               
 276   2      //              dbprintf("\n dummy error");
 277   2                      for(tc_j=0; tc_j<DmyErrBlock[15];tc_j++){
 278   3                              FDBP.cFDev=BMT.cFDev;
 279   3                              FDBP.cFPlane =0;
 280   3                              FDBP.wFBlock = DmyErrBlock[tc_j]; 
 281   3                              FDBP.wFPage  = 0;
 282   3                              FDBP.cFInAddr =0;
 283   3                              Device_Read_SRAM_Index.WD =0x9800;//0601 Jay fix 0x80-->0x98
 284   3                              Flash_ReadSpare (4);            
 285   3                              gw_TargetBlock = DmyErrBlock[tc_j]; 
 286   3                              QTable.WD = Search_Last_Page(gw_TargetBlock);           
 287   3                              tbt_Tempflag =0;
 288   3                              for(tc_i=0;tc_i<Extend_NUM;tc_i++){  
 289   4                                      if(ZSpare[2]==Mapping_Table[EINX+tc_i]){
 290   5                                              FDBP.cFDev=BMT.cFDev;
 291   5                                              SQTable.WD =Search_Last_Page(Mapping_Table[DBK+tc_i]);
 292   5                                              tbt_Tempflag=1;
 293   5                                              break;
 294   5                                      }
 295   4                              }
 296   3                              if(tbt_Tempflag){
 297   4                                      if(SQTable.WD<QTable.WD){// 原本的Ex 比較小需交換
 298   5                                              DmyErrBlock[tc_j]= Mapping_Table[DBK+tc_i];
 299   5                                              Mapping_Table[DBK+tc_i] = gw_TargetBlock;;
 300   5                                              Wear_Table[DCNT+tc_i ] =ZSpare[3];                                      
 301   5                                      }                               
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 6   

 302   4                              }
 303   3                              SwapTemp_Table[tw_SwapCnt] =DmyErrBlock[tc_j] ;
 304   3                              tw_SwapCnt++;                   
 305   3                      }
 306   2              }               
 307   1              else if(tbt_RanErr){
 308   2              // 出現兩個Dummy 可能是Dummy 已經滿了要搬移或是來不及Erase ,
 309   2              // 保留多的哪一個再來重新處理即可
 310   2      //              dbprintf("\n random error");
 311   2                      for(tc_j=0; tc_j<RanErrBlock[15];tc_j++){
 312   3                              FDBP.cFDev=BMT.cFDev;
 313   3                              FDBP.cFPlane =0;
 314   3                              FDBP.wFBlock =RanErrBlock[tc_j]; 
 315   3                              FDBP.wFPage  = 0;
 316   3                              FDBP.cFInAddr =0;
 317   3                              Device_Read_SRAM_Index.WD =0x9800;//0601 Jay fix 0x80-->0x98
 318   3                              Flash_ReadSpare (4);            
 319   3                              gw_TargetBlock = RanErrBlock[tc_j]; 
 320   3                              QTable.WD = Search_Last_Page(gw_TargetBlock);           
 321   3                              tbt_Tempflag =0;
 322   3                              FDBP.cFDev=BMT.cFDev;
 323   3                              SQTable.WD =Search_Last_Page(Mapping_Table[RBK]);
 324   3                              if(SQTable.WD<QTable.WD){// 原本的Ex 比較小需交換
 325   4                                      RanErrBlock[tc_j]= Mapping_Table[RBK];
 326   4                                      Mapping_Table[RBK] = gw_TargetBlock;;
 327   4                                      Wear_Table[RCNT] =ZSpare[3];                                    
 328   4                                                                      
 329   4                              }
 330   3                              SwapTemp_Table[tw_SwapCnt] =RanErrBlock[tc_j];
 331   3                              tw_SwapCnt++;                   
 332   3                      }                                               
 333   2              }
 334   1              else if(tbt_FastErr){
 335   2      //              dbprintf("\n Fast error");                      
 336   2              //管他的反正都要重建了管那麼多幹嘛真接Erase當Swap 
 337   2                      for(tc_j=0; tc_j<FastErrBlock[15];tc_j++){
 338   3                              SwapTemp_Table[tw_SwapCnt] =FastErrBlock[tc_j];
 339   3                              tw_SwapCnt++;
 340   3                      }       
 341   2              }       
 342   1              //---------- build External& Dummy block page table----//
 343   1              for(tc_i=0;tc_i<Extend_NUM;tc_i++){ //Search external Q1 && Q2 
 344   2                      if(Mapping_Table[EBK+tc_i]!=0xFFFF){
 345   3                               Search_Q1Q2_Table(tc_i);                               
 346   3                      }       
 347   2              }       
 348   1              for(tc_i=0;tc_i<Dummy_NUM;tc_i++){ //Search external Q1 && Q2 
 349   2                      if(Mapping_Table[DBK+tc_i]!=0xFFFF){
 350   3                               Search_Dummy_Page(tc_i);                               
 351   3                      }       
 352   2              }
 353   1              //---------- build Random page table -----------------//
 354   1              if(Mapping_Table[RBK]!=0xFFFF){
 355   2                      Search_Random_Page();
 356   2              }       
 357   1              //--------- 整理 swap block 與補滿 所有空的位置--------//
 358   1              if(tw_HBlockCnt<SYS_ZONE.wZONE_SIZE){
 359   2                      memset(XBYTE_9800,0xFF,1024);//0601 Jay fix 0x80-->0x98
 360   2                      memset(XBYTE_9C00,0xFF,1024);
 361   2                      for(tw_Index_Temp = 0; tw_Index_Temp < SYS_ZONE.wZONE_SIZE; tw_Index_Temp ++){
 362   3                              if(Mapping_Table[tw_Index_Temp]==0xFFFF){
 363   4                                      FDBP.cFDev =BMT.cFDev;
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 7   

 364   4                                      FDBP.cFPlane =0;
 365   4                                      FDBP.wFBlock = SwapTemp_Table[tc_SwapInx]; 
 366   4                                      Flash_EraseOneBlock_NO_ChkRdy();                
 367   4                                      Mapping_Table[tw_Index_Temp]=SwapTemp_Table[tc_SwapInx];
 368   4                                      Wear_Table[tw_Index_Temp] = 0x7F;// 給一個中間值吧                                      
 369   4                                      tc_SwapInx++;
 370   4                                      Device_Write_SRAM_Index.BY[0] = 0x98;//0601 Jay fix 0x80-->0x98 
 371   4                                      Device_Write_SRAM_Index.BY[1] = 0x00;
 372   4                                      ZSpare[0] = 0xA5;// Hblock mark
 373   4                                      ZSpare[1] = 0x00; //default HBlock power inx
 374   4                                      ZSpare[2] = tw_Index_Temp; //Hblock num 
 375   4                                      ZSpare[3] = 0x7F; //erase times 
 376   4                                      ZSpare[4] = 'Q';
 377   4                                      ZSpare[5] = 0x00; 
 378   4                                      ZSpare[6] = 'Q'; 
 379   4                                      ZSpare[7] = 0x00;                                       
 380   4                                      FDBP.cFPlane = 0;
 381   4                                      FDBP.wFBlock = Mapping_Table[tw_Index_Temp]; 
 382   4                                      FDBP.wFPage  = 0;
 383   4                                      FDBP.cFInAddr = 0;
 384   4                                      Flash_Sequent_Write(4,1);//寫兩個mark 進去 
 385   4                                      Device_Write_SRAM_Index.BY[0] = 0x98;//0601 Jay fix 0x80-->0x98 
 386   4                                      Device_Write_SRAM_Index.BY[1] = 0x00;                           
 387   4                                      FDBP.cFPlane = 0;
 388   4                                      FDBP.wFBlock = Mapping_Table[tw_Index_Temp] ;
 389   4                                      FDBP.wFPage  = (NAND_INFO.wPAGE_NUM-1);
 390   4                                      FDBP.cFInAddr = 0;
 391   4                                      Flash_Sequent_Write(4,1);//寫兩個mark 進去      
 392   4                              }
 393   3                      }
 394   2              }       
 395   1              if(FAST_BMTTable[gw_WhichGroup]==0xFFFF){       
 396   2                      FDBP.cFDev =BMT.cFDev;
 397   2                      FDBP.cFPlane =0;
 398   2                      FDBP.wFBlock = SwapTemp_Table[tc_SwapInx]; 
 399   2                      Flash_EraseOneBlock_NO_ChkRdy();        
 400   2                      FAST_BMTTable[gw_WhichGroup]=SwapTemp_Table[tc_SwapInx];
 401   2                      FAST_BMTPage_Table[gw_WhichGroup] =0x00;                
 402   2                      Wear_Table[FCNT] = 0x7F;// 給一個中間值吧       
 403   2                      tc_SwapInx++;
 404   2              }
 405   1              if(tc_SwapInx>tw_SwapCnt){
 406   2      //              dbprintf("\n 1.lost block:%x,%x",tc_SwapInx,tw_SwapCnt);
 407   2              }               
 408   1              
 409   1              
 410   1              for(tc_i=0;tc_i<Extend_NUM;tc_i++){
 411   2                      if(Mapping_Table[EBK+tc_i]==0xFFFF){                    
 412   3                              FDBP.cFDev =BMT.cFDev;
 413   3                              FDBP.cFPlane =0;
 414   3                              FDBP.wFBlock = SwapTemp_Table[tc_SwapInx]; 
 415   3                              Flash_EraseOneBlock_NO_ChkRdy();                        
 416   3                              Mapping_Table[EBK+tc_i]=SwapTemp_Table[tc_SwapInx];
 417   3                              Wear_Table[ECNT+tc_i] =0x01;
 418   3                              Mapping_Table[EINX+tc_i]=0xFFFF;
 419   3                              Mapping_Table[Q2_INX+tc_i] =0x0000;
 420   3                              Mapping_Table[Q1_INX+tc_i]&=0x00FF;//只清除 Q1 sblock  inx                      
 421   3                              tc_SwapInx++;
 422   3                              //dbprintf("\nExT[%bX] :%X ",tc_i,Mapping_Table[EBK+tc_i]);
 423   3                      }
 424   2              }       
 425   1              for(tc_i=0;tc_i<Dummy_NUM;tc_i++){
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 8   

 426   2                      if(Mapping_Table[DBK+tc_i]==0xFFFF){                    
 427   3                              FDBP.cFDev =BMT.cFDev;
 428   3                              FDBP.cFPlane =0;
 429   3                              FDBP.wFBlock = SwapTemp_Table[tc_SwapInx]; 
 430   3                              Flash_EraseOneBlock_NO_ChkRdy();                        
 431   3                              Mapping_Table[DBK+tc_i]=SwapTemp_Table[tc_SwapInx];
 432   3                              Wear_Table[DCNT+tc_i] =0x01;
 433   3                              Mapping_Table[Q1_INX+tc_i]&=0xFF00;//只清除 dummy sblock  inx
 434   3                              tc_SwapInx++;
 435   3                              //dbprintf("\nDMY[%bX] :%X ",tc_i,Mapping_Table[DBK+tc_i]);
 436   3                      }
 437   2              }       
 438   1              for(tc_i=0;tc_i<RANDOM_NUM;tc_i++){
 439   2                      if(Mapping_Table[RBK+tc_i]==0xFFFF){                    
 440   3                              FDBP.cFDev =BMT.cFDev;
 441   3                              FDBP.cFPlane =0;
 442   3                              FDBP.wFBlock = SwapTemp_Table[tc_SwapInx]; 
 443   3                              Flash_EraseOneBlock_NO_ChkRdy();                        
 444   3                              Mapping_Table[RBK+tc_i]=SwapTemp_Table[tc_SwapInx];
 445   3                              Mapping_Table[RPAGEINX+tc_i]= 0x00;
 446   3                              for(tc_j=0; tc_j<MAX_RANDOM_HBLOCK;tc_j++){
 447   4                                      Wear_Table[RINX+tc_j]=0xFF;
 448   4                              }
 449   3                              Wear_Table[ECNT+tc_i] =0x01;
 450   3                              tc_SwapInx++;
 451   3                              //dbprintf("\nRandom[%bX] :%X ",tc_i,Mapping_Table[RBK+tc_i]);
 452   3                      }
 453   2              }        
 454   1              for(tc_i=0;tc_i<SWAP_NUM;tc_i++){
 455   2                      if(Mapping_Table[SBK+tc_i]==0xFFFF){                    
 456   3                              FDBP.cFDev =BMT.cFDev;
 457   3                              FDBP.cFPlane =0;
 458   3                              FDBP.wFBlock = SwapTemp_Table[tc_SwapInx]; 
 459   3                              Flash_EraseOneBlock_NO_ChkRdy();                        
 460   3                              Mapping_Table[SBK+tc_i]=SwapTemp_Table[tc_SwapInx];
 461   3                              Wear_Table[SCNT+tc_i] =0x01;
 462   3                              tc_SwapInx++;
 463   3                              //dbprintf("\nSwap_BLK[%bX] :%X ",tc_i,Mapping_Table[SBK+tc_i]);
 464   3                      }
 465   2              }
 466   1              if(tc_SwapInx>tw_SwapCnt){// 理論上不可能出現，萬一靈異出現後再想囉∼
 467   2      //              dbprintf("\n 2.lost block:%x,%x",tc_SwapInx,tw_SwapCnt);
 468   2              }
 469   1      }
 470          
 471          /*********************************************************************************
 472          * NAME:               void Search_Dummy_Page(U8 tc_ExtInx)
 473          * DESCRIPTION:// SPDA26xx flash  plan
 474          *********************************************************************************/
 475          void Search_Dummy_Page(U8 tc_ExtInx){
 476   1              bit             tbt_Data_0xFF_First;
 477   1              
 478   1              bit     tbt_Find_E_SBlock;
 479   1              U8   tc_i ,tc_Inx;
 480   1              U16  tw_Offset;
 481   1              FDBP.cFDev= BMT.cFDev;
 482   1              FDBP.cFPlane = 0;
 483   1              FDBP.wFBlock = Mapping_Table[DBK+tc_ExtInx];
 484   1              FDBP.wFPage  = 0;
 485   1              FDBP.cFInAddr= 0;
 486   1              QTable.WD =0;
 487   1              tw_Offset = tc_ExtInx*MAX_DUMMY_PAGE;
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 9   

 488   1              tc_i=0;
 489   1              tc_Inx =0;
 490   1              // 1. 先到最後一個空D_SBlock ,並將 E ＆  D SBlock  關係建立
 491   1              for(gc_D_SBlock=0; gc_D_SBlock<H_INFO.cSMALLBLOCK_NUM; gc_D_SBlock++){
 492   2                      gw_TargetPage = (U16)gc_D_SBlock*H_INFO.cSMALLPAGE_NUM;
 493   2                      FDBP.cFPlane  = gw_TargetPage&(NAND_INFO.cPLANE_NUM-1);
 494   2                      FDBP.wFPage   = gw_TargetPage/NAND_INFO.cPLANE_NUM;
 495   2                      FDBP.cFInAddr = 0;              
 496   2                      Device_Read_SRAM_Index.BY[0] = 0x98;// 0601 Jay change 0x80-->0x98
 497   2                      Device_Read_SRAM_Index.BY[1] = 0x00;
 498   2                      if(Flash_Sequent_Read(2)){//ECC fail 
 499   3                              gc_E_SBlock = FLASH_REG[0x61];  
 500   3                              if(CHK_ECCData_FF()){// 再次檢查是否為真的全部都是FF
 501   4                                      tbt_Data_0xFF_First =1;//ECC 全部都是0xFF
 502   4                              }
 503   3                              else{
 504   4                                      tbt_Data_0xFF_First=0;  // 非全部都是0xFF;
 505   4                              }                       
 506   3                      }
 507   2                      else{ //ECC pass
 508   3                              gc_E_SBlock = FLASH_REG[0x61]; // 
 509   3                              tbt_Data_0xFF_First=0;                                          
 510   3                      }
 511   2                      if(tbt_Data_0xFF_First){
 512   3                              SQTable.WD = Mapping_Table[Q1_INX+tc_ExtInx];   
 513   3                              SQTable.BY[1] = gc_D_SBlock;
 514   3                              Mapping_Table[Q1_INX+tc_ExtInx]=SQTable.WD;
 515   3                              break;
 516   3                      }
 517   2                      else{
 518   3                              tbt_Find_E_SBlock =0;
 519   3                              for(tc_i=0;tc_i<tc_Inx; tc_i++){
 520   4                                      if(gc_E_SBlock == (Mapping_Table[D_HPAGE+tw_Offset+tc_i]>>8)){
 521   5                                              Mapping_Table[D_HPAGE+tw_Offset+tc_i]= ((U16)gc_E_SBlock<<8)+gc_D_SBlock;
 522   5                                              tbt_Find_E_SBlock=1;
 523   5                                              break;                                  
 524   5                                      }                               
 525   4                              }
 526   3                              if(!tbt_Find_E_SBlock){
 527   4                                      if(tc_Inx<MAX_DUMMY_PAGE){
 528   5                                              Mapping_Table[D_HPAGE+tw_Offset+tc_Inx]= ((U16)gc_E_SBlock<<8)+gc_D_SBlock;
 529   5                                              tc_Inx++;
 530   5                                      }
 531   4                                      else{//應該不會發生這種問題還沒想到要如何處理∼∼
 532   5      //                                      dbprintf("\n Dummy Hpage have full : %bx " ,gc_D_SBlock);
 533   5                                      }                       
 534   4                              }
 535   3                      }
 536   2              }
 537   1              //if(!tbt_Data_0xFF_First){//0524 Jay mark 
 538   1                      SQTable.WD = Mapping_Table[Q1_INX+tc_ExtInx];   
 539   1                      SQTable.BY[1] = gc_D_SBlock;
 540   1                      Mapping_Table[Q1_INX+tc_ExtInx]=SQTable.WD;
 541   1              //}
 542   1              
 543   1              //2. 將每個有效的 D_SBlock 中相對應 E_ Spage 範圍找出來
 544   1              FDBP.cFDev= BMT.cFDev;
 545   1              FDBP.cFPlane = 0;
 546   1              FDBP.wFBlock = Mapping_Table[DBK+tc_ExtInx];
 547   1              FDBP.wFPage  = 0;
 548   1              FDBP.cFInAddr= 0;
 549   1              for(tc_i=0; tc_i<tc_Inx;tc_i++){
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 10  

 550   2                      gc_D_SBlock = (U8)Mapping_Table[D_HPAGE+tw_Offset+tc_i];        
 551   2                      tbt_Data_0xFF_First=0;  
 552   2                      for(gc_SPage=0; gc_SPage<H_INFO.cSMALLPAGE_NUM;gc_SPage++){
 553   3                              gw_TargetPage = ((U16)gc_D_SBlock*H_INFO.cSMALLPAGE_NUM)+gc_SPage;
 554   3                              FDBP.cFPlane  = gw_TargetPage&(NAND_INFO.cPLANE_NUM-1);
 555   3                              FDBP.wFPage   = gw_TargetPage/NAND_INFO.cPLANE_NUM;
 556   3                              FDBP.cFInAddr = 0;              
 557   3                              Device_Read_SRAM_Index.BY[0] = 0x98;//0601 Jay change 0x80-->0x98
 558   3                              Device_Read_SRAM_Index.BY[1] = 0x00;
 559   3                              if(Flash_Sequent_Read(2)){//ECC fail 
 560   4                                      if(gc_SPage==0){
 561   5                                              QTable.BY[0]= FLASH_REG[0x63];
 562   5                                      }
 563   4                                      if(CHK_ECCData_FF()){// 再次檢查是否為真的全部都是FF
 564   5                                              tbt_Data_0xFF_First =1;//ECC 全部都是0xFF
 565   5                                      }
 566   4                                      else{
 567   5                                              tbt_Data_0xFF_First=0;  // 非全部都是0xFF;
 568   5                                      }                       
 569   4                              }
 570   3                              else{ //ECC pass
 571   4                                      if(gc_SPage==0){
 572   5                                              QTable.BY[0]= FLASH_REG[0x63];
 573   5                                      }
 574   4                                      tbt_Data_0xFF_First=0;                                          
 575   4                              }               
 576   3                              if(tbt_Data_0xFF_First){
 577   4                                      QTable.BY[1] =QTable.BY[0]+gc_SPage;
 578   4                                      break;
 579   4                              }
 580   3                      }
 581   2                      //if(!tbt_Data_0xFF_First){//0524 jay mark
 582   2                              QTable.BY[1] =QTable.BY[0]+gc_SPage;
 583   2                      //}     
 584   2                      Mapping_Table[D_PAGE+tw_Offset+tc_i]=QTable.WD;
 585   2              }
 586   1              
 587   1      }
 588          /*********************************************************************************
 589          * NAME:                void Search_Q2_Table(void)
 590          * DESCRIPTION:// SPDA26xx flash  plan
 591          *********************************************************************************/
 592          void Search_Random_Page(void){ 
 593   1              U8       tbt_Data_0xFF;
 594   1              U8   tc_i,tc_j;
 595   1              U8   INX[MAX_RANDOM_HBLOCK];
 596   1              U16  tw_Offset;
 597   1              U16  tw_HPage;  
 598   1              FDBP.cFDev= BMT.cFDev;
 599   1              FDBP.cFPlane = 0;
 600   1              FDBP.wFBlock = Mapping_Table[RBK];
 601   1              FDBP.wFPage  = 0;
 602   1              FDBP.cFInAddr= 0;
 603   1              QTable.WD =0;
 604   1              tbt_Data_0xFF =0;
 605   1              for(QTable.WD=0; QTable.WD< H_INFO.wHBLOCKPAGE;QTable.WD++){
 606   2                      FDBP.cFPlane = QTable.WD%NAND_INFO.cPLANE_NUM;
 607   2                      FDBP.wFPage  = QTable.WD/NAND_INFO.cPLANE_NUM;
 608   2                      FDBP.cFInAddr= 0;
 609   2                      if(CHK_ECCData_FF()){
 610   3                              tbt_Data_0xFF =1;
 611   3                              break;
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 11  

 612   3                      }               
 613   2              }
 614   1              Mapping_Table[RPAGEINX] = QTable.WD;//Next random page index
 615   1      // 1.需先找出是哪個HBlock 是有效的
 616   1              for(tc_i=0;tc_i<MAX_RANDOM_HBLOCK;tc_i++){
 617   2                      INX[tc_i]=0x00;
 618   2              }
 619   1              if(QTable.WD==0){
 620   2                      for(tc_i=0;tc_i<MAX_RANDOM_HBLOCK;tc_i++){
 621   3                              Wear_Table[RINX+tc_i]=0xFF;
 622   3                              
 623   3                      }
 624   2                      return ;
 625   2              }
 626   1              else{   
 627   2                      QTable.WD--;
 628   2                      FDBP.wFBlock = Mapping_Table[RBK];
 629   2                      FDBP.cFPlane = QTable.WD%NAND_INFO.cPLANE_NUM;
 630   2                      FDBP.wFPage  = QTable.WD/NAND_INFO.cPLANE_NUM;
 631   2                      FDBP.cFInAddr= 2;       
 632   2                      Device_Read_SRAM_Index.BY[0] = 0x98;// 0601 Jay add
 633   2                      Device_Read_SRAM_Index.BY[1] = 0x00;
 634   2                      Flash_Sequent_Read(2);
 635   2                      for(tc_i=0;tc_i<MAX_RANDOM_HBLOCK;tc_i++){
 636   3                              Wear_Table[RINX+tc_i]=FLASH_REG[0x60+tc_i];
 637   3                      }
 638   2              }
 639   1      // 2. 重建出 Hblock ,HPage & RPage 關係
 640   1              FDBP.wFBlock = Mapping_Table[RBK];
 641   1              for(tw_HPage=0;tw_HPage<Mapping_Table[RPAGEINX];tw_HPage++){
 642   2                      FDBP.cFPlane = tw_HPage%NAND_INFO.cPLANE_NUM;
 643   2                      FDBP.wFPage  = tw_HPage/NAND_INFO.cPLANE_NUM;
 644   2                      FDBP.cFInAddr= 0;       
 645   2                      Device_Read_SRAM_Index.BY[0] = 0x98;//0601 Jay change 0x80 -->0x98
 646   2                      Device_Read_SRAM_Index.BY[1] = 0x00;
 647   2                      Flash_Sequent_Read(2);
 648   2                      if((FLASH_REG[0x61]==0xCC)&&(FLASH_REG[0x63]==0xCC)){// Clear flag
 649   3                              for(tc_i=0;tc_i<MAX_RANDOM_HBLOCK;tc_i++){
 650   4                                      if(Wear_Table[RINX+tc_i]==FLASH_REG[0x62]){// 相對應HBlock              
 651   5                                              tw_Offset=(tc_i*MAX_RANDOM_HPAGE);              
 652   5                                              for(tc_j=0;tc_j<MAX_RANDOM_HPAGE;tc_j++){
 653   6                                                      Mapping_Table[R_HPAGE+tw_Offset+tc_j]=0xFFFF;           
 654   6                                                      Mapping_Table[R_PAGE+tw_Offset+tc_j]=0xFFFF;            
 655   6                                              }
 656   5                                              INX[tc_i] =0x00;
 657   5                                              break;
 658   5                                      }
 659   4                              }
 660   3                      }               
 661   2                      else{
 662   3                              for(tc_i=0;tc_i<MAX_RANDOM_HBLOCK;tc_i++){
 663   4                                      if(Wear_Table[RINX+tc_i]==FLASH_REG[0x62]){// 相對應HBlock 
 664   5                                              tw_Offset=(tc_i*MAX_RANDOM_HPAGE);
 665   5                                              QTable.BY[0]=FLASH_REG[0x61];
 666   5                                              QTable.BY[1]=FLASH_REG[0x63];
 667   5                                              tbt_Data_0xFF =0;
 668   5                                              for(tc_j=0;tc_j<INX[tc_i];tc_j++){
 669   6                                                      if(Mapping_Table[R_HPAGE+tw_Offset+tc_j]==QTable.WD){
 670   7                                                              Mapping_Table[R_PAGE+tw_Offset+tc_j]=tw_HPage;
 671   7                                                              tbt_Data_0xFF=1;
 672   7                                                              break;
 673   7                                                      }
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 12  

 674   6                                              }
 675   5                                              if(!tbt_Data_0xFF){
 676   6                                                      if(INX[tc_i]<MAX_RANDOM_HPAGE){                         
 677   7                                                              Mapping_Table[R_HPAGE+tw_Offset+INX[tc_i]]=QTable.WD;           
 678   7                                                              Mapping_Table[R_PAGE+tw_Offset+INX[tc_i]]=tw_HPage;
 679   7                                                              INX[tc_i]+=1;
 680   7                                                      }
 681   6                                              }
 682   5                                              break;                                          
 683   5                                      }                       
 684   4                              }
 685   3                      }
 686   2              }
 687   1      }
 688          /*********************************************************************************
 689          * NAME:               void Search_Q1_Table(void)
 690          * DESCRIPTION:// SPDA26xx flash  plan
 691          *********************************************************************************/
 692          void Search_Q1Q2_Table(U8 tc_ExtInx){
 693   1              U8              tbt_Data_0xFF_First;
 694   1              U8     tbt_Data_0xFF_Last;
 695   1              U8     tbt_Find_Q1_SBlock;
 696   1              FDBP.cFDev= BMT.cFDev;
 697   1              FDBP.cFPlane = 0;
 698   1              FDBP.wFBlock = Mapping_Table[EBK+tc_ExtInx];
 699   1              FDBP.wFPage  = 0;
 700   1              FDBP.cFInAddr= 0;
 701   1              QTable.WD =0;
 702   1              tbt_Data_0xFF_First =0;
 703   1              tbt_Data_0xFF_Last =0;
 704   1              tbt_Find_Q1_SBlock= 0;
 705   1              //0. find out first Q1 SBlock 
 706   1              gc_E_SBlock =0; 
 707   1              gw_TargetPage = (U16)gc_E_SBlock*H_INFO.cSMALLPAGE_NUM;
 708   1              FDBP.cFPlane  = gw_TargetPage&(NAND_INFO.cPLANE_NUM-1);
 709   1              FDBP.wFPage   = gw_TargetPage/NAND_INFO.cPLANE_NUM;
 710   1              FDBP.cFInAddr = 0;              
 711   1              Device_Read_SRAM_Index.BY[0] = 0x98;//0601 jay change 
 712   1              Device_Read_SRAM_Index.BY[1] = 0x00;
 713   1              Flash_ReadSpare(8);
 714   1              if(ZSpare[0] ==0xA5){
 715   2                      if(ZSpare[4]=='Q'){
 716   3                              SQTable.BY[0] =ZSpare[5];
 717   3                              tbt_Find_Q1_SBlock= 1;
 718   3                      }
 719   2              }
 720   1                      
 721   1              if(!tbt_Find_Q1_SBlock){
 722   2      //              dbprintf("\n Not find Q1");
 723   2                      SQTable.BY[0] =0;
 724   2              }
 725   1              for(gc_E_SBlock=SQTable.BY[0]; gc_E_SBlock<H_INFO.cSMALLBLOCK_NUM; gc_E_SBlock++){
 726   2                      // chk 1st page
 727   2                      gw_TargetPage = (U16)gc_E_SBlock*H_INFO.cSMALLPAGE_NUM;
 728   2                      FDBP.cFPlane  = gw_TargetPage&(NAND_INFO.cPLANE_NUM-1);
 729   2                      FDBP.wFPage   = gw_TargetPage/NAND_INFO.cPLANE_NUM;
 730   2                      FDBP.cFInAddr = 0;              
 731   2                      Device_Read_SRAM_Index.BY[0] = 0x98;  //0601 Jay fix 
 732   2                      Device_Read_SRAM_Index.BY[1] = 0x00;
 733   2                      if(Flash_Sequent_Read(2)){//ECC fail 
 734   3                              if(CHK_ECCData_FF()){// 再次檢查是否為真的全部都是FF
 735   4                                      tbt_Data_0xFF_First =1;//ECC 全部都是0xFF
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 13  

 736   4                              }
 737   3                              else{
 738   4                                      tbt_Data_0xFF_First=0;  // 非全部都是0xFF;
 739   4                              }                       
 740   3                      }
 741   2                      else{ //ECC pass
 742   3                              tbt_Data_0xFF_First=0;
 743   3                                                                                      
 744   3                      }               
 745   2                      // Chk last page
 746   2                      gw_TargetPage = ((U16)gc_E_SBlock*H_INFO.cSMALLPAGE_NUM)+(H_INFO.cSMALLPAGE_NUM-1);
 747   2                      FDBP.cFPlane  = gw_TargetPage&(NAND_INFO.cPLANE_NUM-1);
 748   2                      FDBP.wFPage   = gw_TargetPage/NAND_INFO.cPLANE_NUM;
 749   2                      FDBP.cFInAddr = 0;              
 750   2                      Device_Read_SRAM_Index.BY[0] = 0x98;//0601 Jay fix
 751   2                      Device_Read_SRAM_Index.BY[1] = 0x00;
 752   2                      if(Flash_Sequent_Read(2)){//ECC fail 
 753   3                              if(CHK_ECCData_FF()){// 再次檢查是否為真的全部都是FF
 754   4                                      tbt_Data_0xFF_Last =1;//ECC 全部都是0xFF
 755   4                              }
 756   3                              else{
 757   4                                      tbt_Data_0xFF_Last=0;  // 非全部都是0xFF;
 758   4                              }                       
 759   3                      }
 760   2                      else{ //ECC pass
 761   3                              tbt_Data_0xFF_Last=0;                                           
 762   3                      }               
 763   2                      if(tbt_Data_0xFF_First||tbt_Data_0xFF_Last){
 764   3                              QTable.BY[0] =gc_E_SBlock;
 765   3                              break;
 766   3                      }
 767   2              }
 768   1              //2. find out E_Spage
 769   1              if(tbt_Data_0xFF_First&&tbt_Data_0xFF_Last){
 770   2                      QTable.BY[1] =0;
 771   2              }
 772   1              else if(tbt_Data_0xFF_Last){// Spage0不是空 但 Last Spage 是空的 這個SBlock 不是滿的 
 773   2                      tbt_Data_0xFF_First =0;
 774   2                      FDBP.wFBlock = Mapping_Table[EBK+tc_ExtInx];
 775   2                      for(gc_E_SPage=0; gc_E_SPage<H_INFO.cSMALLPAGE_NUM;gc_E_SPage++){
 776   3                              gw_TargetPage = ((U16)gc_E_SBlock*H_INFO.cSMALLPAGE_NUM)+gc_E_SPage;
 777   3                              FDBP.cFPlane  = gw_TargetPage&(NAND_INFO.cPLANE_NUM-1);
 778   3                              FDBP.wFPage   = gw_TargetPage/NAND_INFO.cPLANE_NUM;
 779   3                              FDBP.cFInAddr = 0;              
 780   3                              Device_Read_SRAM_Index.BY[0] = 0x98;//0601 Jay fix 0x80-->0x98
 781   3                              Device_Read_SRAM_Index.BY[1] = 0x00;
 782   3                              if(Flash_Sequent_Read(2)){//ECC fail 
 783   4                                      if(CHK_ECCData_FF()){// 再次檢查是否為真的全部都是FF
 784   5                                              tbt_Data_0xFF_First =1;//ECC 全部都是0xFF
 785   5                                      }
 786   4                                      else{
 787   5                                              tbt_Data_0xFF_First=0;  // 非全部都是0xFF;
 788   5                                      }                       
 789   4                              }
 790   3                              else{ //ECC pass
 791   4                                      tbt_Data_0xFF_First=0;                                          
 792   4                              }               
 793   3                              if(tbt_Data_0xFF_First){
 794   4                                      QTable.BY[1] =gc_E_SPage;
 795   4                                      break;
 796   4                              }
 797   3                      }
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 14  

 798   2                              
 799   2              } 
 800   1              else{// 這個狀況應該是整個 block 都是滿的有dummy 情況
 801   2                      QTable.BY[0] =H_INFO.cSMALLBLOCK_NUM;
 802   2                      QTable.BY[1] = 0;               
 803   2              }
 804   1      //      dbprintf("\n Search Q1_INX:%bx Q1 = %bx" , tc_ExtInx , SQTable.BY[0]);
 805   1      //      dbprintf("\n search Q2 INX:%bx Q2=%X", tc_ExtInx,QTable.WD);
 806   1              Mapping_Table[Q2_INX+tc_ExtInx] =QTable.WD;  //Q2 page
 807   1              Mapping_Table[Q1_INX+tc_ExtInx] =SQTable.WD;//Q1 sblock
 808   1      }
 809          /*********************************************************************************
 810          * NAME:                  U16 Search_Last_Page(U16 TBlock)                         
 811          * DESCRIPTION: 找尋最後一個有資料 page  // SPDA26xx flash  plan                                          
 812          *********************************************************************************/
 813          U16 Search_Last_Page(U16 TBlock){//090820  Jay add                                                 
 814   1          U8  tbt_Data_0xFF=0;                                                        
 815   1          FDBP.wFBlock = TBlock;
 816   1          gw_TargetPage=(H_INFO.wHBLOCKPAGE-1);
 817   1          while(gw_TargetPage){    
 818   2          //for(gw_TargetPage=0;gw_TargetPage<H_INFO.wHBLOCKPAGE;gw_TargetPage++){
 819   2              FDBP.cFPlane =gw_TargetPage%NAND_INFO.cPLANE_NUM;
 820   2              FDBP.wFPage = gw_TargetPage/NAND_INFO.cPLANE_NUM;
 821   2              if(CHK_ECCData_FF()){// 再次檢查是否為真的全部都是FF
 822   3                              tbt_Data_0xFF =1;//ECC 全部都是0xFF                     
 823   3                      }
 824   2                      else{
 825   3                              tbt_Data_0xFF=0;  // 非全部都是0xFF;
 826   3                              break;
 827   3                      }
 828   2                              
 829   2                      gw_TargetPage--;
 830   2          }
 831   1          return gw_TargetPage;            
 832   1                                                                                        
 833   1      }/*********************************************************************************
 834          * NAME:                bit CHK_ECCData_FF(void)
 835          * DESCRIPTION:
 836          *********************************************************************************/
 837          U8 CHK_ECCData_FF(void){ 
 838   1              bit tbt_Data_0xFF;
 839   1              U8 tc_i;
 840   1              Device_Read_SRAM_Index.BY[0] = 0x9C;//0601 Jay fix 0x80-->0x9C
 841   1              Device_Read_SRAM_Index.BY[1] = 0x00;
 842   1              Device_Xfer_DataLength.BY[0] = 0x00;
 843   1              Device_Xfer_DataLength.BY[1] = NAND_INFO.cECC_NUM;
 844   1              tbt_Data_0xFF      = 0;
 845   1              FLASH_REG[0xA3]  = 0x00;                                                                        // disable ECC  
 846   1              DEVICE_REG[0x0E] = 0x10;                                                                        // Enable Falsh data check oxFF
 847   1              SET_DEVICE_READ();
 848   1              FLASH_REG[0x06]  = 0x00;                                                                        // cmd1
 849   1              FLASH_REG[0x07]  = 0x30;                                                                        // cmd2 
 850   1              FLASH_REG[0x0C] =  0x00;                                                                        //column_L
 851   1              FLASH_REG[0x0B] =  0x04;                                                                        //column_H
 852   1              NAND_FBlock_FPage_FBank_To_PhyAddr_NAND();                                      // set FBank Fblock FPage       
 853   1              FLASH_REG[0x04]  = 0x01;                                                                        // CMD0+ADDR+CMD1       
 854   1              FLASH_REG[0x01] &= 0xF0;                                                                        // don't atuo read redunt
 855   1              CHK_Flash_Ready();
 856   1              TRIGGER_FLASH_CMD();    
 857   1              FLASH_REG[0x1A]  = 0x11; 
 858   1              CHK_Flash_Ready();
 859   1              Trigger_Data_Transfer_Done();           
C51 COMPILER V9.00   FLSHSCAN                                                              07/10/2012 15:51:47 PAGE 15  

 860   1              if(DEVICE_REG[0x0E]&0x20){ // Flash Data is not 0xFF  
 861   2                      gc_Global_I =0;
 862   2                      tbt_Data_0xFF= 0;
 863   2                      for(tc_i =0; tc_i<NAND_INFO.cECC_NUM;tc_i++){ // Double check 
 864   3                              if(XBYTE_9C00[tc_i] ==0xFF){//0601 Jay fix 0x80-->0x9c
 865   4                                      gc_Global_I ++;
 866   4                              }
 867   3                      }
 868   2                      if(gc_Global_I>(NAND_INFO.cECC_NUM>>1)){ //有可能只是flash bit error 誤判
 869   3                              tbt_Data_0xFF =1;
 870   3                      }
 871   2              }
 872   1              else{
 873   2                      tbt_Data_0xFF =1;
 874   2              }
 875   1              return tbt_Data_0xFF;
 876   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   5622    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      35
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       9
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
