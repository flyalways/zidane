C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SYSTEM
OBJECT MODULE PLACED IN .\obj\system.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE MAIN\system.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource\hea
                    -der) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\system.lst) OBJECT(.\obj\system.obj)

line level    source

   1          #include <string.h>
   2          #include <intrins.h>
   3          #include "SPDA2K.h"
   4          #include "global.h"
   5          #include "usb_data.h"
   6          #include "PROTOTYP.h"
   7          #include "dos\fs_struct.h"
   8          #include "Memalloc.h"
   9          #include "Flash_code.h"
  10          #include "..\Header\UI_CODETAB.h"
  11          #include "..\IR\remote.h"
  12          #include "..\header\host_init.h"
  13          #include "..\..\libsource\header\UI_config.h"
  14          #include "..\LCM\TFT_display.h"
  15          #include "..\LCM\LCM.h"
  16          #include "..\LCM\LCM_func.h"
  17          #include "..\LCM\UI_icon.h"
  18          #include "..\header\variables.h"
  19          
  20          extern  data    bit     gb_HostConnect;
  21          
  22          extern U8 Host_Initial(void);
  23          
  24          void UI_host_detect(void);
  25          void Timer0_init(void);
  26          void TimeOutHandle(void);
  27          void LCM_Disp_XBMPArray_USB(U8 *Condition,U8 *Data);
  28          
  29          U8 Key_Detect(void);
  30          U8 READ_SARADC(U8 tc_ADCChannel);
  31          
  32          extern void MainMenuProcess();
  33          extern void SetupMenuProcess();
  34          extern void PowerOffProcess();
  35          extern void Dir_Task();  //20090107 chiayen add
  36          extern void ProcKey_in_idle(void);
  37          extern void ProcKey_in_play(void);
  38          extern void ProcKey_in_rec(void);
  39          extern void ProcKey_in_voice(void);
  40          extern void ProcKey_in_jpeg(void);
  41          extern void ProcKey_in_mjpeg(void);
  42          extern void load_nand_bank(void);
  43          extern void init_system(void);
  44          extern void LCM_init_process(void); 
  45          extern void     FM_drive(void); 
  46          extern void     FM_initial(void);
  47          extern void USER_GetUISetIndex(void);  //20090107 chiayen add
  48          
  49          extern U8 DOS_DIRtable(void);  //20090107 chiayen add
  50          extern U8 Get_LogData_PageIndex(void);
  51          extern U8 USER_LogFile_ReadWrite(U8 tbt_ReadOrWrite);//use reserveblock for log
  52          extern   void  MediaChange(void);
  53          extern xdata U8 gc_LongKeyTimer;
  54          extern xdata U8 gc_LongKeyDelay;
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 2   

  55          
  56          extern  U8      gc_PseudoCard_Flag;
  57          extern  bit             gb_cmd_timeout;  //080925chiayen add
  58          extern  xdata   System_Struct gs_System_State;
  59          
  60          extern Host_register_INIT();
  61          U8      gc_clock_mode = CLOCK_MODE_XTL; // The current clock mode of the system.
  62          
  63          extern xdata    U32     gdw_HOSTStartSectorRead;
  64          
  65          extern data bit gb_Host_Exist; //20090803 chiayen add
  66          extern xdata    U32     gdw_HOSTStartSectorRead;  //20090803 chiayen add
  67          
  68          void main(void)
  69          {
  70   1      //      XBYTE[0xB091]=0x01;     // 1.8v/3.3v regulator turn on 
  71   1              XBYTE[0xB092]=0x78; // 3.2V & 2.0V
  72   1      //      XBYTE[0xB093]=0x00;     // LVR=2.4V
  73   1      
  74   1              // DSP initial
  75   1              XBYTE[0xB010]&=0xFE;    // Disable DSP clock, Jimi 080729 for pop noise as 1st time play
  76   1              XBYTE[0xB002]&=0xFE;    // Release DSP Reset, Jimi 080729 for pop noise as 1st time play
  77   1              XBYTE[0xB08a]|=0x08;    //(JC)MCU:audio DAC on
  78   1              XBYTE[0xB08a]|=0x10;    //(JC)MCU:Headphone driver on
  79   1              XBYTE[0xB08a]|=0x20;    //(JC)MCU:Headphone driver DD comm-mode bias o/p
  80   1              XBYTE[0xB0ED]|=0x02;    //(Jimi 091027)Audio DA zero cross reset bypass on
  81   1              XBYTE[0xB0C1]=0xB0;             //(Jimi 091027)Pre-mux , post-mux and internal XCK select
  82   1              XBYTE[0xB0C4]=2;                //(Jimi 091027)LCH speaker volume(i.e LCH OP Gain)
  83   1              XBYTE[0xB0C5]=2;                //(Jimi 091027)RCH speaker volume(i.e RCH OP Gain)
  84   1              
  85   1              //SAR ADC init
  86   1              XBYTE[0xB05E] = 0; // disable SAR FS clock
  87   1              XBYTE[0xB05F] = 0x5F; // SAR clock = 12MHz/16/6 = 125kHz = 8us
  88   1              
  89   1              //--------------------------------------------  // 
  90   1          gbt_Force_USB_FullSpeed =FALSE;
  91   1              gbt_USB_Detected = 0;
  92   1              gc_CardDetect = 0x00 ;
  93   1              gc_CardExist  = 0x00 ;                          // bit 0  : Nand Flash  bit 1: SD_Card
  94   1              gc_CardType   = 0x01 ;                          // default Flash Interface 
  95   1              gc_CardChangeStage =0x00;           // bit 0 : Nand  bit 1 : SD_Card    
  96   1              gw_FileSkipNumber=0;
  97   1              gb_TriggerFileSkip=0;
  98   1              gb_FindFile=0;
  99   1              gbt_Support_Dummy_Capacity =0;              // default disable dummy capacity function 
 100   1              gc_bCBWLUN=0; 
 101   1              gbt_enableCDROM =0;                                                     //09/04/24,joyce
 102   1              gc_CDROM_Size=0 ;
 103   1              init_system();  
 104   1              USB_PlugDetect();                               // Detect USB plug                                   
 105   1              //----------------------------------------------// Initial Flash module         
 106   1              Init_Flash_Reg();                                                           
 107   1              Init_Flash_Variable();
 108   1              //-------------- Need search Bank,Dsp ,hzk block info ,first---------//
 109   1              FDBP.cFDev = 0;
 110   1              XBYTE[0xB40F] = FDBP.cFDev;
 111   1              FlashReadID();
 112   1              Flash_State_Initial();
 113   1              Search_BankCode_Block();
 114   1      
 115   1              InitFlash();
 116   1      
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 3   

 117   1              Timer0_init();
 118   1              XBYTE[0xB09F]|=0x06;//(JC)Vref Fast setup mode 'n Internal reference voltage power control
 119   1              gc_Vrefinit_Timer=60;
 120   1              XBYTE[0xB421]=0x13;
 121   1      //      dbprintf("tftinit\n");
 122   1              TFT_init();
 123   1      #ifdef CAR_48
 124   1                      XBYTE[0xB102]|=0x3C;
 125   1      #else
                              XBYTE[0xB102] |= 0x01;
              #endif
 128   1      //      dbprintf("tftinit end\n");
 129   1              TFT_PowerOnlogo();
 130   1              if(gbt_USB_Detected)
 131   1              {                                                               
 132   2                      USB_Task();
 133   2              }
 134   1      
 135   1              gb_Host_Exist=1;
 136   1              gb_SD_Exist=1;          
 137   1              if(!Host_DetectDevice())
 138   1              {
 139   2                      if(!Host_Initial())
 140   2                      {
 141   3                              gc_CurrentCard = CURRENT_MEDIA_HOST;
 142   3                              gb_FindFlag = 0;
 143   3                      }
 144   2                      else
 145   2                      {
 146   3                              gc_CurrentCard=0;
 147   3                      }               
 148   2              }
 149   1              else
 150   1              {                                        
 151   2                      if(SD_Card_Detect())
 152   2                      {
 153   3                              if(SD_Identification_Flow())
 154   3                              {
 155   4                                      gc_CardExist |=0x02;
 156   4                                      gc_CurrentCard=2;           
 157   4                              }
 158   3                              else
 159   3                              {
 160   4                                      gc_CurrentCard=0;
 161   4                                      gc_CardExist &=0xFD;
 162   4                                      gb_FindFlag = 0;            
 163   4                              }     
 164   3                      }                                
 165   2                      else
 166   2                  {
 167   3                              gb_SD_Exist=0;
 168   3                              gc_CurrentCard = 0;
 169   3                  }
 170   2              }
 171   1              XBYTE[0xB400] =0x01;
 172   1              XBYTE[0xB010]&=0xFE;    // Disable DSP clock, Jimi 080729 for pop noise as 1st time play
 173   1              XBYTE[0xB002]&=0xFE;    // Release DSP Reset, Jimi 080729 for pop noise as 1st time play
 174   1              XBYTE[0xB08a]|=0x08;//(JC)MCU:audio DAC on
 175   1              XBYTE[0xB08a]|=0x10;//(JC)MCU:Headphone driver on
 176   1              XBYTE[0xB08a]|=0x20;//(JC)MCU:Headphone driver DD comm-mode bias o/p
 177   1      
 178   1              //SAR ADC init
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 4   

 179   1              XBYTE[0xB05E] = 0; // disable SAR FS clock
 180   1              XBYTE[0xB05F] = 0x5f; // SAR clock = 12MHz/16/6 = 125kHz = 8us
 181   1      
 182   1              Get_LogData_PageIndex();  //chiayen0808
 183   1              USER_LogFile_ReadWrite(0);//use reserveblock for log
 184   1              if((gw_FM_frequency<875) || (gw_FM_frequency>1080))
 185   1              {
 186   2                      gw_FM_frequency=875;
 187   2              }
 188   1              FM_initial(); 
 189   1              FM_drive();
 190   1              gc_SetNumber = gw_PagesPerBlock >> 2; //1set=4pages for dir management, Ching 080816  //20090107 chiayen 
             -add
 191   1              gc_SetIndex = 0; //Ching 080816  //20090107 chiayen add 
 192   1              USER_GetUISetIndex();   //for DIR table index  //20090107 chiayen add
 193   1      
 194   1              gb_FindFlag = 0;
 195   1              if (DOS_Initialize()) //20090803 chiayen modify
 196   1              {
 197   2                      gdw_HOSTStartSectorRead=0xFFFFFFF0; 
 198   2                      if(gc_CurrentCard==CURRENT_MEDIA_HOST)
 199   2                      {
 200   3                              if(SD_Card_Detect())
 201   3                              {
 202   4                                      gb_SD_Exist=1;  
 203   4                                      if(SD_Identification_Flow())
 204   4                                      {
 205   5                                              gc_CardExist |=0x02;
 206   5                                              gc_CurrentCard=2;           
 207   5                                      }
 208   4                                      else
 209   4                                      {
 210   5                                              DEVICE_REG[0x00]= 0x01;
 211   5                                              gc_CurrentCard=0;
 212   5                                              gc_CardExist &=0xFD;
 213   5                                              gb_FindFlag = 0;            
 214   5                                      }     
 215   4                              }                                
 216   3                              else
 217   3                          {
 218   4                                      DEVICE_REG[0x00]= 0x01;
 219   4                                      gb_SD_Exist=0;
 220   4                                      gc_CurrentCard = 0;
 221   4                          }                                   
 222   3                      }
 223   2                      else
 224   2                      {       
 225   3                              DEVICE_REG[0x00]= 0x01;  //20090730 chiayen add
 226   3                              gc_CurrentCard=0;
 227   3                              gc_CardExist &=0xFD;
 228   3                              gb_FindFlag = 0;
 229   3                              InitFlash();                                    
 230   3                      }
 231   2                      DOS_Initialize();
 232   2              }
 233   1              gc_CurrentCard_backup=gc_CurrentCard; //20090803 chiayen move here
 234   1              gs_File_FCB[0].dw_FDB_StartCluster = gdw_DOS_RootDirClus;
 235   1              DOS_Search_File(C_File_All|C_Cnt_FileNo, C_MusicFileType, C_CmpExtName|C_Next);//(JC)count music file no.
             - in root
 236   1              ir_init();
 237   1              EA  = 1;
 238   1              gc_Task_Current=C_Task_Play;
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 5   

 239   1              gc_Task_Next=C_Task_Play;
 240   1              gc_PhaseInx=0;
 241   1              gw_init_needed=0xffff;
 242   1              Detect_USB();
 243   1              Polling_TaskEvents();
 244   1              if(gc_Task_Current!=gc_Task_Next)
 245   1              {
 246   2                      gc_Task_Current=gc_Task_Next;   
 247   2              }
 248   1              while(1)
 249   1              {               
 250   2                      switch(gc_Task_Current)
 251   2                      {
 252   3                              case C_Task_Play:
 253   3                                      Play_Task();
 254   3                              break;                                  
 255   3      
 256   3                              case C_Task_USB:
 257   3                                      USB_Task();
 258   3                              break;
 259   3      
 260   3                              case C_Task_Dir:  //20090107 chiayen add
 261   3                                      Dir_Task();
 262   3                              break;
 263   3      
 264   3                              case C_Task_Jpeg:  //20090107 chiayen add
 265   3                                      Jpeg_Task();
 266   3                              break;
 267   3      
 268   3                              case C_Task_Mjpeg:  //20090107 chiayen add
 269   3                                      Mjpeg_Task();
 270   3                              break;
 271   3      
 272   3                              case C_Task_PlayMenu:  //20090107 chiayen add
 273   3      //                              PlayMenuProcess();
 274   3                              break;
 275   3      
 276   3                              case C_Task_PlayMenu_IR:  //20090107 chiayen add
 277   3      //                              PlayMenuProcess_IR();
 278   3                              break;
 279   3      
 280   3                              case C_Task_Setting:  //20090107 chiayen add
 281   3                                      SetupMenuProcess();
 282   3                              break;
 283   3      
 284   3                              case C_Task_Menu:
 285   3                                      MainMenuProcess();
 286   3                              break;                                  
 287   3      
 288   3                              case C_Task_PowerOff:
 289   3                                      PowerOffProcess();
 290   3                              break;
 291   3                      }
 292   2              }
 293   1      }
 294          
 295          
 296          U8 Key_Detect(void)
 297          {
 298   1              if(gc_KeyValue==0)
 299   1              {  
 300   2                      gc_KeyEvent=0;
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 6   

 301   2                      return 1;
 302   2              }
 303   1              else
 304   1              {
 305   2                      gc_KeyEvent = gc_KeyValue;
 306   2                      gc_KeyValue = 0;
 307   2      //#if 0                 //由于长按PLAY需要做成
 308   2              if(gc_KeyEvent==0x12) 
 309   2              { //sunzhk add power off 100809 
 310   3                              if( gs_System_State.c_Phase==TASK_PHASE_PAUSE)
 311   3                              {
 312   4                                      MediaChange(); 
 313   4                                      return 0; 
 314   4                              }
 315   3                      else 
 316   3                  { 
 317   4                          if(gc_Task_Current == C_Task_Play) 
 318   4                          { 
 319   5                                  play_stop(); 
 320   5                          } 
 321   4                          else if(gc_Task_Current == C_Task_Jpeg) 
 322   4                          { 
 323   5                                  jpeg_stop(); 
 324   5                          } 
 325   4                          else if(gc_Task_Current == C_Task_Mjpeg) 
 326   4                          { 
 327   5                                  mjpeg_stop(); 
 328   5                          }                   
 329   4                  }           
 330   3                  gc_Task_Next = C_Task_PowerOff; 
 331   3                  gc_PhaseInx = C_PowerOff; 
 332   3                  gc_KeyEvent = 0; 
 333   3                  return 0; 
 334   3              } 
 335   2      //#endif
 336   2                      if(gc_Task_Current==C_Task_Play)  //20090107 chiayen modify
 337   2                      {
 338   3                              ProcKey_in_play();
 339   3                      }
 340   2                      else if(gc_Task_Current==C_Task_Jpeg)  //20090107 chiayen modify
 341   2                      {
 342   3                              ProcKey_in_jpeg();
 343   3                      }
 344   2                      else if(gc_Task_Current==C_Task_Mjpeg)  //20090107 chiayen modify
 345   2                      {
 346   3                              ProcKey_in_mjpeg();
 347   3                      }
 348   2                      else
 349   2                      {
 350   3                              ProcKey_in_play();      
 351   3                      }
 352   2                      return 0;
 353   2              }
 354   1      }
 355          
 356          
 357          void USB_PlugDetect(void)
 358          {
 359   1              xdata   U8 tc_i;
 360   1              xdata   U8 tc_usb_detect;
 361   1      
 362   1              XBYTE[0xB0D1] = 0xf0;//(JC)from debounce ckt
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 7   

 363   1              tc_i =0x08;
 364   1              while(tc_i)
 365   1              {
 366   2                      tc_usb_detect = XBYTE[0xB0D1]&0x02;
 367   2                      tc_i--;
 368   2              }
 369   1              if(tc_usb_detect)
 370   1              {
 371   2                      if(gb_cmd_timeout==0)
 372   2                      {
 373   3                      gbt_USB_Detected = 1;     // USB_Detected
 374   3                      }
 375   2              }
 376   1              else
 377   1              {
 378   2                  gbt_USB_Detected = 0;
 379   2                      gb_cmd_timeout=0;
 380   2              }
 381   1      }
 382          
 383          
 384          U8 READ_SARADC(U8 tc_ADCChannel)
 385          {
 386   1              xdata   U8 tc_ADCValue;
 387   1      
 388   1              if(tc_ADCChannel==2)
 389   1              {
 390   2                      XBYTE[0xB094]=1;
 391   2              }
 392   1              XBYTE[0xB060]=(tc_ADCChannel<<2)|0x01;
 393   1              for(tc_ADCValue=0;tc_ADCValue<50;tc_ADCValue++);
 394   1              XBYTE[0xB05E]=1;        // enable SAR FS clock
 395   1              while((XBYTE[0xB061]&0x01)==0);
 396   1              tc_ADCValue=XBYTE[0xB062];
 397   1              XBYTE[0xB05E]=0;        // disable SAR FS clock
 398   1              XBYTE[0xB094]=0;
 399   1              return tc_ADCValue;
 400   1      }
 401          
 402          
 403          void Timer0_init()//(JC)Timer0 init;~7.5mS@24Mhz MCU 
 404          {
 405   1      //=========Timer0 init s============
 406   1              // set timer 0 and activete it.
 407   1              TR0 = 0;
 408   1      
 409   1              TH0 = gc_T0IntervalMSB;
 410   1              TL0 = gc_T0IntervalLSB;
 411   1      
 412   1              ET0 = 1;
 413   1              TR0 = 1;
 414   1      //=========Timer0 init f============
 415   1      }
 416          
 417          /* According to EVB, ideal key values are 0, 59, 88, 118, 163, 203, 237 and 255(No key press).
 418           * To identify key presses, we use middle values to discriminate between keys.
 419           */
 420          //! Mapping ADC value to a key.
 421          void Get_KeyValue(U8 ADCValue)
 422          {
 423   1              if(ADCValue>246)
 424   1              {               
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 8   

 425   2                      gc_key_Pressed=C_Key_None;
 426   2              }       
 427   1              else if(ADCValue>220)
 428   1              {       
 429   2                      gc_key_Pressed=C_Key_Vol;       
 430   2              }
 431   1              else if(ADCValue>183)
 432   1              {       
 433   2                      gc_key_Pressed=C_Key_Rec;       
 434   2              }
 435   1              else if(ADCValue>140)
 436   1              {       
 437   2                      gc_key_Pressed=C_Key_Voldn;     
 438   2              }
 439   1              else if(ADCValue>103)
 440   1              {
 441   2                      gc_key_Pressed=C_Key_Volup;     
 442   2              }
 443   1              else if(ADCValue>74)
 444   1              {
 445   2                      gc_key_Pressed=C_Key_Next;              
 446   2              }
 447   1              else if(ADCValue>30)
 448   1              {
 449   2                      gc_key_Pressed=C_Key_Prev;                              
 450   2              }
 451   1              else
 452   1              {
 453   2                      gc_key_Pressed=C_Key_Mode;
 454   2              }
 455   1      }
 456          
 457          
 458          void TimeOutHandle()
 459          {
 460   1              if(gbLKeyTimer_Timeout==1)//(JC)Long key detect period 
 461   1              {
 462   2                      gbLKeyTimer_Timeout=0;
 463   2                      if(gc_LongKeyTimer)
 464   2                      {
 465   3                              gc_LongKeyTimer++;
 466   3                      }
 467   2              }
 468   1      
 469   1              if(gbGetKey_Timeout==1)//(JC)Read ADC value(get key) period 
 470   1              {
 471   2                      gbGetKey_Timeout=0;     
 472   2                      if((!gc_KeyValue)&&(!gc_KeyDet_Mask))//(JC)Key event determined //20090107 chiayen modify
 473   2                      {
 474   3                      /*      #ifndef CAR_64
 475   3                              if(!P1_3)  //chiayenmark for car
 476   3                              {
 477   3                                      gc_key_Pressed=C_Key_Play;
 478   3                              }
 479   3                              else
 480   3                              #endif*/
 481   3                              {
 482   4                                      Get_KeyValue(READ_SARADC(0));
 483   4                              }
 484   3      
 485   3                              if((gc_key_PrevPressed&0x0f)==gc_key_Pressed)
 486   3                              {
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 9   

 487   4                                      if(gc_key_Pressed != C_Key_None)
 488   4                                      {
 489   5                                              if(gc_LongKeyTimer>gc_LongKeyDelay)
 490   5                                              {
 491   6                                                      gc_key_PrevPressed |= 0x10;//(JC)long key determined    
 492   6      
 493   6                                                      if((gc_key_Pressed==C_Key_Mode) && (gc_LongKeyCount==0))
 494   6                                                      {
 495   7                                                      gc_KeyValue = gc_key_PrevPressed & 0x7f;
 496   7                                                              gc_LongKeyCount=1;
 497   7                                                      }
 498   6                                                      if(gc_key_Pressed!=C_Key_Mode) 
 499   6                                                      {
 500   7                                                                      gc_KeyValue = gc_key_PrevPressed & 0x7f;
 501   7                                                      }
 502   6      
 503   6                                                      gc_LongKeyTimer = REPEATKEY_DELAYVALUE; //(JC)16, for long key over-pressed, counting from 16 to 29.
             -.. and determining long key again
 504   6                                                      gc_LongKeyDelay = (gc_LongKeyDelay < MIN_REPEATKEYDELAY)?MIN_REPEATKEYDELAY:/*(gc_LongKeyDelay-3)*/(
             -REPEATKEY_DELAYVALUE+6);  //20090107 chiayen modify   
 505   6                                              }
 506   5                                              else
 507   5                                              {
 508   6                                                      gc_key_PrevPressed |= 0x80;
 509   6                                              }       
 510   5                                      }
 511   4                              }
 512   3                              else if(gc_key_Pressed==C_Key_None)//(JC)key released
 513   3                              {
 514   4                                      if((gc_key_PrevPressed & 0x90) == 0x80)//(JC)short key released
 515   4                                      {
 516   5                                              gc_KeyValue = gc_key_PrevPressed & 0x7f;
 517   5                                      }
 518   4                                      else if((gc_key_PrevPressed & 0x90) == 0x90)//(JC)long key released
 519   4                                      {
 520   5                                              gc_KeyValue = (gc_key_PrevPressed | 0x20) & 0x6f;//(JC)key value will be 0x2x,long-pressed key releas
             -ed
 521   5                                              gc_LongKeyCount=0; //chiayen0807
 522   5                                      }
 523   4                                      gc_key_PrevPressed = C_Key_None;
 524   4                                      gc_LongKeyTimer = 0;
 525   4                                      gc_LongKeyDelay = 0;    
 526   4                              }
 527   3                              else//(JC)new key pressed
 528   3                              {
 529   4                                      gc_key_PrevPressed = gc_key_Pressed;
 530   4                                      gc_LongKeyTimer = 1;//(JC)long key timer launching
 531   4                                      if (!gc_LongKeyDelay)
 532   4                                  {
 533   5                                              gc_LongKeyDelay = MAX_REPEATKEYDELAY;
 534   5                                      }
 535   4                              }
 536   3                      }
 537   2              }
 538   1      }
 539          
 540          
 541          
 542          void Polling_TaskEvents(void)
 543          {
 544   1              if(gc_Vrefinit_Timer==0)
 545   1              {
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 10  

 546   2                      TimeOutHandle();
 547   2                      Key_Detect();
 548   2                      gc_Vrefinit_Timer=2;
 549   2              }
 550   1      }
 551          
 552          
 553          #define CK2_FLAG        (0<<6)
 554          #define CK1_FLAG        (1<<6)
 555          
 556          static U8 code gac_clock_table[][8] = 
 557          { 
 558           //0xB006,    0xB009, 0xB024, 0xB025, 0xB026, TH1  TH0            TL0             
 559           { 0x00,      0,      0,      0,      0,      243, C_T0_12MhzMSB, C_T0_12MhzLSB}, // No PLL,  MCU=12M, PER
             -I=12M, DSP=12M        CLOCK_MODE_XTL 
 560           { 0x08|0x40, 0x42,   1,      1,      0,      243, C_T0_12MhzMSB, C_T0_12MhzLSB}, // PLL=24M, MCU=12M, PER
             -I=12M, DSP=19M        CLOCK_MODE_MP3 
 561           { 0x08|0x40, 0,      0,      0,      0,      230, C_T0_24MhzMSB, C_T0_24MhzLSB}, // PLL=24M, MCU=24M, PER
             -I=24M, DSP=24M        CLOCK_MODE_MP3LRC 
 562           { 0x10|0x40, 0,      3,      3,      0,      243, C_T0_12MhzMSB, C_T0_12MhzLSB}, // PLL=48M, MCU=12M, PER
             -I=12M, DSP=48M                CLOCK_MODE_WMA 
 563           { 0x10|0x40, 0,      1,      1,      0,      230, C_T0_24MhzMSB, C_T0_24MhzLSB}, // PLL=48M, MCU=24M, PER
             -I=24M, DSP=48M        CLOCK_MODE_JPEG 
 564           { 0x18|0x40, 0,      0,      0,      0,      178, C_T0_72MhzMSB, C_T0_72MhzLSB}, // PLL=72M, MCU=72M, PER
             -I=72M, DSP=72M        CLOCK_MODE_MJPEG 
 565           { 0x18|0x40, 0,      0,      0,      2,      178, C_T0_72MhzMSB, C_T0_72MhzLSB}, // PLL=72M, MCU=72M, PER
             -I=72M, DSP=24M        CLOCK_MODE_USB 
 566          }; 
 567          
 568          
 569          
 570          
 571          
 572          //! Set CPU/Peripheral/DSP clock divider in PLL mode.
 573          static void change_clock_ratio(U8 r)
 574          {
 575   1              // disable auto wait
 576   1              XBYTE[0xB021] = 0;
 577   1              // set new divide ratio
 578   1              XBYTE[0xB009] = gac_clock_table[r][1];  // cpu_mask_sel, per_mask_sel, dsp_mask_sel & n_mask
 579   1              XBYTE[0xB024] = gac_clock_table[r][2];  // CPUfreq
 580   1              XBYTE[0xB025] = gac_clock_table[r][3];  // PERfreq
 581   1              XBYTE[0xB026] = gac_clock_table[r][4];  // DSPfreq
 582   1              // Trigger the switch
 583   1              XBYTE[0xB020] = 0;      // cpu_protect = dsp_protect = per_protect = 0
 584   1              XBYTE[0xB020] = 1;      // freqchange = 1
 585   1              _nop_();
 586   1      }
 587          
 588          
 589          static void xtl_to_pll(U8 tc_clock_mode)
 590          {
 591   1              XBYTE[0xB006] = gac_clock_table[tc_clock_mode][0];
 592   1              XBYTE[0xB006] = gac_clock_table[tc_clock_mode][0] | (1<<5);
 593   1              USER_DelayDTms(2);
 594   1              XBYTE[0xB008] = 2;      // PLLS_SWRSTN = 1
 595   1              XBYTE[0xB008] = 3;      // PLLS_MODE = 1(PLL clock output)
 596   1              change_clock_ratio(tc_clock_mode);
 597   1      }
 598          
 599          //! Change clock source from PLL to crystal.
 600          static void pll_to_xtl(void)
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 11  

 601          {
 602   1              change_clock_ratio(CLOCK_MODE_XTL);
 603   1              XBYTE[0xB008] = 2;      // PLLS_SWRSTN = 1, PLLS_MODE = 0(PLL clock output)
 604   1      }
 605          
 606          U8 set_clock_mode(U8 mode)
 607          {
 608   1              U8 tc_old_mode;
 609   1      
 610   1              if (gc_clock_mode == mode)
 611   1              {
 612   2                      return gc_clock_mode;
 613   2              }
 614   1      
 615   1              if (gac_clock_table[gc_clock_mode][0] != gac_clock_table[mode][0])
 616   1              {
 617   2                      if (gc_clock_mode != CLOCK_MODE_XTL)
 618   2                      {
 619   3                              pll_to_xtl();
 620   3                      }
 621   2                      if (mode != CLOCK_MODE_XTL)
 622   2                      {
 623   3                              xtl_to_pll(mode);
 624   3                      }
 625   2              }
 626   1              else
 627   1              {
 628   2                      change_clock_ratio(CLOCK_MODE_XTL);
 629   2                      change_clock_ratio(mode);
 630   2              }
 631   1              TH1 = gac_clock_table[mode][5];
 632   1              tc_old_mode = gc_clock_mode;
 633   1              gc_clock_mode = mode;
 634   1              gc_T0IntervalMSB = gac_clock_table[gc_clock_mode][6];
 635   1              gc_T0IntervalLSB = gac_clock_table[gc_clock_mode][7];
 636   1      
 637   1              return tc_old_mode;
 638   1      }
 639          
 640          
 641          /***************************************************************************
 642          * NAME:         bit  SD_Card_Detect(void)
 643          * DESCRIPTION:
 644          ***************************************************************************/
 645          bit SD_Card_Detect(void)
 646          {
 647   1      #ifdef CAR_64
                  P1|=0x02;
                      XBYTE[0xB102]&=0xFD;
              #elif defined(CAR_48)
 651   1          P1|=0x02;
 652   1              XBYTE[0xB102]&=0xFD;
 653   1      #elif defined(EVB_128)  
                  P1|=0x80;
                      XBYTE[0xB102]&=0x7F;
              #endif  
 657   1      
 658   1              if(!SD_Detect)
 659   1              {
 660   2                      if(gc_PseudoCard_Flag==0)
 661   2                      {
 662   3                              gc_CardDetect |= 0x02;
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 12  

 663   3                              return 1;
 664   3                      }
 665   2                      else
 666   2                      {
 667   3                              return 0;       
 668   3                      }
 669   2              }
 670   1              else
 671   1              {
 672   2                  gc_CardDetect &= 0xFD; 
 673   2                  gc_CardExist &=0xFD;
 674   2                  gc_Start_Stop_Flag &= 0xFD;
 675   2                  gc_PseudoCard_Flag=0;
 676   2                  return 0;
 677   2              }       
 678   1      }
 679          
 680          
 681          U8 CheckUSBPlugIN(void)
 682          {
 683   1              U8 i;
 684   1      
 685   1              XBYTE[0xB011] |= 0x20;   //bit 4   turn on usb_device clk
 686   1      
 687   1          XBYTE[0xB016]  = 0x04;                       // power on default is 0x04
 688   1          XBYTE[0xB0E9] &= 0xFE;                       // Enable usb pll clk 
 689   1          USER_DelayDTms(5);                              // ㄏノDelay よΑぃノpollingよΑ
 690   1          XBYTE[0xB01D]  =0x00;
 691   1      
 692   1              XBYTE[0xB002] |= 0x04;   //bit 3   turn on USB_SW_RESET
 693   1          XBYTE[0xB002] &= 0xFB;   //bit 3   trun off USB_SW_RESET
 694   1          XBYTE[0xB002]  |= 0x02;   //bit 2   turn on USB_host_SW_RESET
 695   1              XBYTE[0xB5e6]  = 0x00;   //bulksram gated clock
 696   1              XBYTE[0xB522]  = 0x01;   //USB2.0 UTMI clock mode set   
 697   1              XBYTE[0xB018]  = 0x01;          //USB clock select                              //TONY
 698   1              XBYTE[0xB002] &= 0xFD;   //bit 2   turn off USB_host_SW_RESET
 699   1      
 700   1              Syn_Reset();
 701   1              XBYTE[0xB018]  = 0x01;          //USB clock select                              //TONY  
 702   1              XBYTE[0xB019]  = 0x01;   //host mode
 703   1              if(XBYTE[0xB615]==0x01)
 704   1              {
 705   2                      i=100;
 706   2                      while(i)        i--;    
 707   2                      if(XBYTE[0xB615]==0x01)
 708   2                      {
 709   3                              return 1;
 710   3                      }
 711   2              }
 712   1              return 0;
 713   1      }
 714          
 715          
 716          U8 Host_DetectDevice(void)
 717          {
 718   1              xdata   U8 sts;
 719   1      
 720   1              if(gc_CurrentCard == CURRENT_MEDIA_HOST)
 721   1              {
 722   2                      if(gb_HostConnect==0)
 723   2                      {
 724   3                              return 1;
C51 COMPILER V9.00   SYSTEM                                                                07/10/2012 15:51:49 PAGE 13  

 725   3                      }
 726   2                      else
 727   2                      {
 728   3                              return 0;
 729   3                      }
 730   2              }
 731   1              else
 732   1              {
 733   2                      sts = CheckUSBPlugIN();
 734   2                      if(sts) 
 735   2                      {
 736   3                              return 0;
 737   3                      }
 738   2                      else
 739   2                      {
 740   3                              gb_HostConnect = 0;
 741   3                              return 1;
 742   3                      }
 743   2              }
 744   1      }
 745          
 746          
 747          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1638    ----
   CONSTANT SIZE    =    672    ----
   XDATA SIZE       =    794       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13    ----
   IDATA SIZE       =     44    ----
   BIT SIZE         =     30    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
