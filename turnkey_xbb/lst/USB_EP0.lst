C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE USB_EP0
OBJECT MODULE PLACED IN .\obj\USB_EP0.obj
COMPILER INVOKED BY: F:\Keil C 7.10\chengxu\C51\BIN\C51.EXE ..\libsource\USB\USB_EP0.c LARGE OPTIMIZE(9,SIZE) BROWSE NOA
                    -REGS INCDIR(..\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\USB_EP0.lst) OBJECT(.\obj\USB_EP0.
                    -obj)

line level    source

   1          #include "SPDA2K.h"
   2          
   3          void Control_Transfer_Process(void) 
   4          {
   5   1              if (gbt_EP0SETUP_int_flag){                              //EP0SETUP
   6   2                      USB_REG[0xC0] &= 0xFE;
   7   2                      Read_Setup_Packet();                     //Get the 8-byte setup packet and decode these commands                                
   8   2                      gbt_EP0SETUP_int_flag = 0;
   9   2                      return;
  10   2              }
  11   1              if (gbt_EP0TX_int_flag){                                                                // EP0TX     
  12   2                      while(USB_REG[0xA0]&0x01)
  13   2                      {
  14   3                              USB_PlugDetect();
  15   3                              if(!gbt_USB_Detected) break;
  16   3                      }
  17   2                      USB_REG[0xC0] &= 0xFD;                  
  18   2                      gbt_EP0TX_int_flag = 0; 
  19   2                      return;
  20   2              }
  21   1              if (gbt_EP0RX_int_flag){                                 // EP0RX    IN Packet    // DEVICE <===== HOST                         
  22   2                      while(USB_REG[0xA0]&0x02)
  23   2                      {
  24   3                              USB_PlugDetect();
  25   3                              if(!gbt_USB_Detected) break;
  26   3                      } 
  27   2              USB_REG[0xC0] &= 0xFB;          
  28   2                      gbt_EP0RX_int_flag = 0;
  29   2                      return;
  30   2              }
  31   1              if (gbt_USBRST_int_flag) 
  32   1              {                             // USB Reset & Software Reset     
  33   2                      gbt_USBRST_int_flag = 0;                        
  34   2                      gbt_Have_set_configuration= 0;
  35   2                      GLOBAL_REG[0x02]|= 0x04;          //S/W RST USB Module
  36   2                      GLOBAL_REG[0x02] = 0x02;                                                        // 081015 Joyce fix don't reset DSP
  37   2                      USB_I2C();          
  38   2                  if(gbt_Force_USB_FullSpeed)
  39   2                      {
  40   3                      USB_REG[0x50]    = 0x01;        //USB 1.1
  41   3                  }
  42   2                      else
  43   2                      {
  44   3                      USB_REG[0x50]    = 0x00;        //Default USB 2.0
  45   3                  }   
  46   2                      USB_REG[0x27] = 0x00;   // 080304 Jay fix for new fpga code      
  47   2                      USB_REG[0xC0]   &= 0xF7; 
  48   2                      USB_REG[0xE9]    = 0xFF;                //Clear ALL USB Buffer.
  49   2                      USB_REG[0xEA]    = 0xFF;
  50   2                      USB_REG[0xA0]   &= 0xFC;
  51   2                      USB_REG[0xD2]    = 0x02;                //因為Reset完後要收Host端的Command.             
  52   2                      USB_REG[0xA1]    = 0x02;
  53   2                      return;
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 2   

  54   2              }
  55   1      
  56   1              if (gbt_USB_CONFIG_Chg_int_flag) 
  57   1              {
  58   2                      gbt_USB_CONFIG_Chg_int_flag = 0;
  59   2                      USB_REG[0xC0] = 0x4F;
  60   2                      if (USB_REG[0xB1] & 0xF0) 
  61   2                      {
  62   3                              USB_REG[0xD0] |= 0x10;
  63   3                      }
  64   2                      gbt_Have_set_configuration = 0;
  65   2                      return;
  66   2              }
  67   1      
  68   1              if (gbt_SUSPEND_int_flag) 
  69   1              {                       //Suspend status
  70   2                      gbt_SUSPEND_int_flag = 0;
  71   2                      USB_REG[0xC0] = 0x4F;
  72   2                      if (USB_REG[0xB1] & 0xF0) 
  73   2                      {
  74   3                              USB_REG[0xD0] |= 0x10;
  75   3                      }
  76   2                      
  77   2                      if(gbt_USB_Connect_Flag)
  78   2                      {  // 081208 Jay add
  79   3                          gbt_USER_Remove_Flag=1;
  80   3                      }       
  81   2                      return;
  82   2              }
  83   1              if (gbt_RESUME_int_flag) 
  84   1              {                       //Resume status
  85   2                      gbt_RESUME_int_flag   = 0;
  86   2                      USB_REG[0xC0]  = 0xEF;  //Clear Suspend event
  87   2                      USB_REG[0xD0] &= 0xEF;  //Disable Suspend INT
  88   2                      USB_REG[0xD0] |= 0x80;  //Enable Resume INT
  89   2                      gbt_USB_Connect_Flag    = 0;  // 081208 Jay add
  90   2                      gbt_USER_Remove_Flag    = 0;// 081208 Jay
  91   2                      return;
  92   2              }
  93   1      }
  94          
  95          
  96          void Read_Setup_Packet(void) 
  97          {
  98   1              //Read(Get) 8-byte setup packet from FIFO
  99   1              //Endpoint 0 Data Port Register = 0x0C
 100   1              ControlCmd.RequestType         =  USB_REG[0xF0];               // get 1st byte
 101   1              ControlCmd.Direction           =  ControlCmd.RequestType & 0x80;// xfer Direction(IN, OUT)
 102   1              ControlCmd.Type                =  ControlCmd.RequestType & 0x60;// type(Standard, Class, Vendor)
 103   1              ControlCmd.Object              =  ControlCmd.RequestType & 0x03;// Device, Interface, Endpoint
 104   1              ControlCmd.Request             =  USB_REG[0xF1];               // get 2st byte
 105   1          ControlCmd.Value_L             =  USB_REG[0xF2];               // get 3st byte
 106   1          ControlCmd.Value_H             =  USB_REG[0xF3];               // get 4th byte  
 107   1          ControlCmd.Index_L             =  USB_REG[0xF4];               // get 5th byte
 108   1              ControlCmd.Index_H             =  USB_REG[0xF5];               // get 6th byte
 109   1              ControlCmd.Length.BY[1]        =  USB_REG[0xF6];               // get 7th byte
 110   1              ControlCmd.Length.BY[0]        =  USB_REG[0xF7];               // get 8th byte                  
 111   1              if (ControlCmd.Type == 0x00) {                                  // standard command
 112   2                    USB_REG[0xEA]=0x01;
 113   2                    StandardCommand();
 114   2                      gbt_USB_Connect_Flag =1; //090521 Jay add for usb connect
 115   2              }       
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 3   

 116   1              else if (ControlCmd.Type == 0x10){                              // class command
 117   2                         //ClassCommand();
 118   2          }              
 119   1          else if (ControlCmd.Type == 0x20){                         // vendor command
 120   2                       USB_REG[0xEA]=0x01; 
 121   2                      VendorCommand();                                                                        // GetMaxLogicUnitNumber is 0xA1 0xFE 0 0 0 0 0x01 0
 122   2          }
 123   1              else{
 124   2                      gc_CX_Status_flag |= CX_STL;                       // Invalid(bad) command, Return EP0_STALL flag 
 125   2              }
 126   1      }
 127          
 128          
 129          void StandardCommand(void) 
 130          {
 131   1              switch (ControlCmd.Request) 
 132   1              {                      // by Standard Request codes     
 133   2                      case 0:                                  
 134   2                              get_status();                    // get status
 135   2                              gc_CX_Status_flag |= CX_DONE;       // EP0_Done
 136   2                              break;                           // EP0 Control Register's address --> 0x0B
 137   2                      case 1:             
 138   2                              clear_feature();                 // clear feature
 139   2                              gc_CX_Status_flag |= CX_DONE;
 140   2                              break;                       
 141   2                      case 2:             
 142   2                              gc_CX_Status_flag |= CX_DONE;       // Reserved for future use
 143   2                              break;
 144   2                      case 3:             
 145   2                              set_feature(); 
 146   2                              break;         
 147   2                      case 4:                                  // Reserved for future use
 148   2                              gc_CX_Status_flag |= CX_DONE;
 149   2                              break;                       
 150   2                      case 5:
 151   2                              set_address();                   // set address
 152   2                              gc_CX_Status_flag |= CX_DONE;
 153   2                              break;                       
 154   2                      case 6:                 
 155   2                              get_descriptor();                // get descriptor
 156   2                              gc_CX_Status_flag |= CX_DONE;
 157   2                              break;                       
 158   2              case 7:            
 159   2                  set_descriptor();                // set descriptor
 160   2                              gc_CX_Status_flag |= CX_DONE;
 161   2                  break;                       
 162   2                      case 8:            
 163   2                              get_configuration();             // get configuration 
 164   2                              gc_CX_Status_flag |= CX_DONE;
 165   2                              break;                       
 166   2                      case 9:            
 167   2                              set_configuration();             // set configuration
 168   2                              gc_CX_Status_flag |= CX_DONE;
 169   2                              break;
 170   2                      case 10:                                 
 171   2                      get_interface();                 // get interface
 172   2                              gc_CX_Status_flag |= CX_DONE;
 173   2                      break;                       
 174   2              case 11:           
 175   2                              set_interface();                 // set interface
 176   2                              gc_CX_Status_flag |= CX_DONE;
 177   2                              break;                       
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 4   

 178   2                      case 12:                                 
 179   2                              synch_frame();                   // synch frame
 180   2                              gc_CX_Status_flag |= CX_DONE;
 181   2                              break;                       
 182   2                      default:
 183   2                              gc_CX_Status_flag |= CX_STL;        // Invalid(Bad) command, Return EP0_STALL flag
 184   2              }
 185   1      }
 186          
 187          
 188          void get_status(void)
 189          {
 190   1              U8      i;
 191   1              
 192   1              switch (ControlCmd.Object)
 193   1              { //Judge which recipient type is at first    
 194   2                      case 0 ://Device
 195   2                              //Return 2-byte's Device status (Bit1:Remote_Wakeup, Bit0:Self_Powered) to Host
 196   2                              //Notice that the programe sequence of RecipientStatus
 197   2                                  //Bit1:Device_Remote_Wakeup(RMWKUP)", Main Control Register's address --> 0x00              
 198   2                              if(USB_REG[0xC0]&0x40)
 199   2                              {
 200   3                                      if(Configuration_DescriptorTable[0x07] & 0x40)
 201   3                                      {
 202   4                                              i=3;
 203   4                                      }
 204   3                                      else
 205   3                                      {
 206   4                                              i=2;
 207   4                              }
 208   3                              }
 209   2                              else
 210   2                              {
 211   3                                      if(Configuration_DescriptorTable[0x07] & 0x40)
 212   3                                      {
 213   4                                              i=1;
 214   4                              }
 215   3                                      else
 216   3                                      {
 217   4                                              i=0;
 218   4                          }
 219   3                              }
 220   2                              USB_REG[0x00]=i; 
 221   2                              USB_REG[0x00]=0x00;     
 222   2              break;                          
 223   2                      
 224   2                      case 1 ://Interface
 225   2                              //Return 2-byte Interface status to Host Endpoint 0 Data Port Register = 0x0C
 226   2                              USB_REG[0x00] = 0x00;//Zero_packet;         //Low Byte
 227   2                              USB_REG[0x00] = 0x00;//Zero_packet;         //High Byte
 228   2                      break;  
 229   2      
 230   2                      case 2 ://Endpoint
 231   2                              switch(ControlCmd.Index_L)
 232   2                              {
 233   3                                      case 0x01:      //OUT
 234   3                                      break;                                  
 235   3      
 236   3                                      case 0x81:      //IN
 237   3                                              USB_REG[0x00] = ((USB_REG[0xE8] & 0x04) >> 2);        //Low Byte
 238   3                                              USB_REG[0x00] = 0x00;//Zero_packet;                     //High Byte
 239   3                                      break;
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 5   

 240   3                                              
 241   3                                      case 0x02:      //OUT
 242   3                                              USB_REG[0x00] = ((USB_REG[0xE8] & 0x08) >> 3);        //Low Byte
 243   3                                              USB_REG[0x00] = 0x00;//Zero_packet;                     //High Byte
 244   3                                      break;                          
 245   3                                              
 246   3                                      case 0x82:      //IN
 247   3                                      break;
 248   3                                              
 249   3                                      case 0x83:
 250   3                                              USB_REG[0x00] = ((USB_REG[0xE8] & 0x10) >> 4);
 251   3                                              USB_REG[0x00] = 0x00;
 252   3                              break;
 253   3      
 254   3                                      default:
 255   3                                              gc_CX_Status_flag |= CX_STL;
 256   3                                      break;
 257   3                      }
 258   2              break;
 259   2                      
 260   2                      default :
 261   2                              gc_CX_Status_flag |= CX_STL;
 262   2                      break;
 263   2              }
 264   1      }
 265          
 266          
 267          void clear_feature(void)
 268          {
 269   1          switch (ControlCmd.Value_L){    
 270   2              case 0 :                
 271   2                      //Clear "Endpoint_Halt", Turn off the "STALL" bit in Endpoint Control Function Register
 272   2                      switch(ControlCmd.Index_L){             
 273   3                              case 0x01:      //OUT,No Used
 274   3                                      break;
 275   3                              case 0x81:      //IN
 276   3                                      //Clear Toggle Bit
 277   3                                      //IN:TX Endpoint 1 Config and Status Register's address --> 0x41
 278   3                                      //Bit 4 : CLRTG_EP1TX
 279   3                                      //Bit 3 : STALL_EP1TX
 280   3                                      USB_REG[0xE9] |= 0x01;     // Reset Toggle Seeting
 281   3                                      USB_REG[0xEB] &= 0xFB;     // Clear Stall Bit
 282   3                                      USB_REG[0xE9] &= 0xFE;     // Disable Toggle Seeting
 283   3                                      break;
 284   3                                              
 285   3                              case 0x02:      //OUT
 286   3                                      //Clear Toggle Bit
 287   3                                      //OUT:RX Endpoint 2 Config and Status Register's address --> 0x63
 288   3                                      //Bit 4 : CLRTG_EP2RX
 289   3                                      //Bit 3 : STALL_EP2RX 
 290   3                                      USB_REG[0xE9] |= 0x02;     // Reset Toggle Seeting
 291   3                                      USB_REG[0xEB] &= 0xF7;     // Clear Stall Bit
 292   3                                      USB_REG[0xE9] &= 0xFD;     // Reset Toggle Seeting
 293   3                                      break;
 294   3                              case 0x82:      //IN
 295   3                                      break;
 296   3                              case 0x83:
 297   3                                      USB_REG[0xE9] |= 0x04;     // Reset Toggle Seeting
 298   3                                      USB_REG[0xEB] &= 0xEF;     // Clear Stall Bit
 299   3                                      USB_REG[0xE9] &= 0xFB;     // Disable Toggle Seeting                            
 300   3                                      break;
 301   3                              default:
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 6   

 302   3                                      // Invalid(bad) command, Return EP0_STALL flag
 303   3                                      // EndPoint 0 Control Register's address --> 0x2C
 304   3                                      gc_CX_Status_flag |= CX_STL;
 305   3                              }
 306   2                      break;
 307   2                              
 308   2              case 1 :// Device Remote Wakeup
 309   2                      // Clear "Device_Remote_Wakeup", Turn off the"RMWKUP" bit in Main Control Register
 310   2                      // Main Control Register's address --> 0x00
 311   2                      // Bit 0 : RMWKUP
 312   2                      USB_REG[0xC0] &= 0xBF; 
 313   2                      gc_CX_Status_flag |= CX_DONE;
 314   2                      break;
 315   2              case 2 :// Test Mode
 316   2                      // The Test_Mode feature cannot be cleared by the ClearFeature() request.
 317   2                      // Invalid(bad) command, Return EP0_STALL flag
 318   2                      // EndPoint 0 Control Register's address --> 0x0B
 319   2                      gc_CX_Status_flag |= CX_STL;
 320   2                      break;
 321   2              default :
 322   2                      // Invalid(bad) command, Return EP0_STALL flag
 323   2                      // EndPoint 0 Control Register's address --> 0x0B
 324   2                              gc_CX_Status_flag |= CX_STL;
 325   2              }
 326   1      }
 327          
 328          
 329          /*****************************************************************************
 330          * NAME:         void set_feature(void)
 331          * DESCRIPTION:
 332          *               Setup -- Standard Command -- set feature (0x02)
 333          *****************************************************************************/
 334          void set_feature(void){
 335   1          switch (ControlCmd.Value_L){ //Judge which recipient is at first    
 336   2              case 0 :                // Endpoint Halt
 337   2                      //Set "Endpoint_Halt", Turn on the "STALL" bit in Endpoint Control Function Register
 338   2                      switch(ControlCmd.Index_L){             
 339   3                              case 0x01:      //OUT
 340   3                                      //OUT:RX Endpoint 1 Config and Status Register's address --> 0x61
 341   3                                      //Bit 2 : STALL_EP1RX
 342   3                                      break;
 343   3                              case 0x81:      //IN
 344   3                                      //N:TX Endpoint 1 Config and Status Register's address --> 0x41
 345   3                                              //Bit 2 : STALL_EP1RX/
 346   3                                      USB_REG[0xE8] |= 0x04;
 347   3                                              gc_CX_Status_flag |= CX_DONE;
 348   3                                      break;
 349   3                              case 0x02:      //OUT
 350   3                                      //OUT:RX Endpoint 2 Config and Status Register's address --> 0x63
 351   3                                      //Bit 2 : STALL_EP2RX
 352   3                                      USB_REG[0xE8] |= 0x08;
 353   3                                              gc_CX_Status_flag |= CX_DONE;
 354   3                                      break;
 355   3                              case 0x82:      //IN
 356   3                                      //IN:TX Endpoint 2 Config and Status Register's address --> 0x43
 357   3                                      //Bit 2 : STALL_EP2RX
 358   3                                      break;
 359   3                              case 0x83:
 360   3                                      USB_REG[0xE8] |= 0x10;
 361   3                                              gc_CX_Status_flag |= CX_DONE;
 362   3                                      break;
 363   3                              default:
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 7   

 364   3                                      // Invalid(bad) command, Return EP0_STALL flag
 365   3                                      // EndPoint 0 Control Register's address --> 0x0B
 366   3                                      gc_CX_Status_flag |= CX_STL;
 367   3                                      return;
 368   3                      }
 369   2                      break;
 370   2                      
 371   2              case 1 ://Device Remote Wakeup
 372   2                      //Set "Device_Remote_Wakeup", Turn on the"RMWKUP" bit in Mode Register
 373   2                      //Main Control Register's address --> 0x00
 374   2                      //Bit 0 : RMWKUP
 375   2                      USB_REG[0xC0] |= 0x40; 
 376   2                      gc_CX_Status_flag |= CX_DONE;     // EP0_Done
 377   2                  break;
 378   2      
 379   2              default :
 380   2                      // Invalid(bad) command, Return EP0_STALL flag
 381   2                      // EndPoint 0 Control Register's address --> 0x0B
 382   2                              gc_CX_Status_flag |= CX_STL;   
 383   2          }
 384   1      }
 385          
 386          
 387          void set_address(void){  // HW做掉了
 388   1              //the legal device address is from 0 to 127
 389   1              if (ControlCmd.Value_L > 127){        
 390   2                    // Illegal device address
 391   2                    // Invalid(bad) command, Return EP0_STALL flag
 392   2                    // EndPoint 0 Control Register's address --> 0x0B
 393   2                       gc_CX_Status_flag |= CX_STL;
 394   2                       return;
 395   2              }
 396   1              // Write this 2-byte gc_Device_Address into "Address Register"
 397   1              // Address Register's address --> 0x01
 398   1              if (gbt_Have_set_configuration){
 399   2                    gc_Device_Address = ControlCmd.Value_L;
 400   2                    gbt_Have_set_configuration = 1;
 401   2              }
 402   1              else{
 403   2                      gc_Device_Address = ControlCmd.Value_L;
 404   2              }     
 405   1      }
 406          
 407          
 408          void get_descriptor(void) 
 409          {
 410   1              U8      i;
 411   1      
 412   1              //Decide the display descriptor length(range)
 413   1              if (USB_REG[0x02] & 0x01) 
 414   1              {   
 415   2                      gbt_USBHostIsHighSpeed = 1;
 416   2              }
 417   1              else 
 418   1              {
 419   2                      gbt_USBHostIsHighSpeed = 0;
 420   2              }       
 421   1              
 422   1              if (gbt_USBHostIsHighSpeed) 
 423   1              {
 424   2                      EndPoint0Table[Device_DescriptorTable_Begine        +  2] = 0x00;
 425   2                      EndPoint0Table[Device_DescriptorTable_Begine        +  3] = 0x02; // USB 2.0
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 8   

 426   2                      EndPoint0Table[Configuration_DescriptorTable_Begine + 22] = 0x00;
 427   2                      EndPoint0Table[Configuration_DescriptorTable_Begine + 23] = 0x02; // for endpoint 1 , MaxPacket 512 b
             -ytes
 428   2              EndPoint0Table[Configuration_DescriptorTable_Begine + 29] = 0x00;
 429   2              EndPoint0Table[Configuration_DescriptorTable_Begine + 30] = 0x02; // for endpoint 1 , MaxPacket 51
             -2 bytes
 430   2          }
 431   1          else
 432   1              {
 433   2              EndPoint0Table[Other_Speed_Configuration_DescriptorTable_Begine+22] = 0x00;
 434   2              EndPoint0Table[Other_Speed_Configuration_DescriptorTable_Begine+23] = 0x02;
 435   2              EndPoint0Table[Other_Speed_Configuration_DescriptorTable_Begine+29] = 0x00;
 436   2              EndPoint0Table[Other_Speed_Configuration_DescriptorTable_Begine+30] = 0x02;
 437   2          }    
 438   1          
 439   1          switch (ControlCmd.Value_H) 
 440   1              {
 441   2                      case 1:         //Device descriptor
 442   2                              for(i=Device_DescriptorTable_Begine;i<Device_DescriptorTable_End;i++) 
 443   2                              {                       
 444   3                                      USB_REG[0x00]=EndPoint0Table[i];
 445   3                                      ControlCmd.Length.WD--;
 446   3                                      if (ControlCmd.Length.WD == 0) 
 447   3                                      {
 448   4                                              break;
 449   4                                      }
 450   3                              }                       
 451   2                              break;
 452   2                      
 453   2                      case 2:         //Configuration descriptor
 454   2                              for(i=Configuration_DescriptorTable_Begine;i<Configuration_DescriptorTable_End;i++) 
 455   2                              {
 456   3                                      USB_REG[0x00]=EndPoint0Table[i];
 457   3                                      ControlCmd.Length.WD--;
 458   3                                      if (ControlCmd.Length.WD == 0) 
 459   3                                      {
 460   4                                              break;
 461   4                                      }
 462   3                              }
 463   2                              break;
 464   2              
 465   2                      case 3:         //String descriptor
 466   2                              switch(ControlCmd.Value_L) 
 467   2                              {                       
 468   3                                      case 0x00:
 469   3                                              for(i=iLANGID_DescriptorTable_Begine;i<iLANGID_DescriptorTable_End;i++) 
 470   3                                              {                                        
 471   4                                                      USB_REG[0x00]=EndPoint0Table[i];
 472   4                                                      ControlCmd.Length.WD--;
 473   4                                                      if (ControlCmd.Length.WD == 0)
 474   4                                                      {  
 475   5                                                              break;
 476   5                                                      }                                               
 477   4                                              }
 478   3                                              break;
 479   3      
 480   3                                      case 0x10:
 481   3                                              for(i=iManufacturer_DescriptorTable_Begine;i<iManufacturer_DescriptorTable_End;i++) 
 482   3                                              {                                        
 483   4                                                      USB_REG[0x00]=EndPoint0Table[i];
 484   4                                                      ControlCmd.Length.WD--;
 485   4                                                      if (ControlCmd.Length.WD== 0)
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 9   

 486   4                                                      {  
 487   5                                                              break;
 488   5                                                      }
 489   4                                              }
 490   3                                              break;
 491   3                                      
 492   3                                      case 0x20:
 493   3                                              for(i=iProduct_DescriptorTable_Begine;i<iProduct_DescriptorTable_End;i++) 
 494   3                                              {                                        
 495   4                                                      USB_REG[0x00]=EndPoint0Table[i];
 496   4                                                      ControlCmd.Length.WD--;
 497   4                                                      if (ControlCmd.Length.WD== 0)
 498   4                                                      {  
 499   5                                                              break;
 500   5                                                      }
 501   4                                              }
 502   3                                              break;
 503   3                                      
 504   3                                      case 0x30:
 505   3                                              gc_USB_ADDR =(gc_USB_ADDR&0x7F);
 506   3                                              for(i=iSerialNumber_DescriptorTable_Begine;i< iSerialNumber_DescriptorTable_End;i++) 
 507   3                                              {                                        
 508   4                                                      if(i==(iSerialNumber_DescriptorTable_End-3))
 509   4                                                      {
 510   5                                      //SN 需介於 0x30~0x39 / 0x41 ~ 0x49 
 511   5                                  USB_REG[0x00]= (gc_USB_ADDR/100)+0x30;                                        
             -               //
 512   5                              }
 513   4                              else if(i==(iSerialNumber_DescriptorTable_End-2))
 514   4                                                      {
 515   5                                      if((gc_USB_ADDR&0x7F) <= 0x09 )
 516   5                                                              {
 517   6                                              USB_REG[0x00] =0x30;
 518   6                                      }
 519   5                                      else
 520   5                                                              {                               
 521   6                                              USB_REG[0x00]= ((gc_USB_ADDR%100)/10)+0x40;
 522   6                                      }
 523   5                              }
 524   4                              else if(i == (iSerialNumber_DescriptorTable_End-1))
 525   4                                                      { 
 526   5                                      USB_REG[0x00]= (gc_USB_ADDR%10)+0x30;     
 527   5                              }                                                                               //
 528   4                              else
 529   4                                                      {
 530   5                                                              USB_REG[0x00]=EndPoint0Table[i];
 531   5                              }                                               
 532   4                                                      ControlCmd.Length.WD--;
 533   4                                                      if (ControlCmd.Length.WD== 0)
 534   4                                                      {  
 535   5                                                              break;
 536   5                                                      }
 537   4                                              }
 538   3                                              break;
 539   3      
 540   3                                      case 0x40:
 541   3                                              for(i=iConfiguraiton_DescriptorTable_Begine;i<iConfiguraiton_DescriptorTable_End;i++) 
 542   3                                              {                                        
 543   4                                                      USB_REG[0x00]=EndPoint0Table[i];
 544   4                                                      ControlCmd.Length.WD--;
 545   4                                                      if (ControlCmd.Length.WD== 0)
 546   4                                                      {  
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 10  

 547   5                                                              break;
 548   5                                                      }
 549   4                                              }
 550   3                                              break;
 551   3      
 552   3                                      case 0x50:
 553   3                                              for(i=iDeviceQualifierString_DescriptorTable_Begine;i<iDeviceQualifierString_DescriptorTable_End;i++)
             - 
 554   3                                              {                                        
 555   4                                                      USB_REG[0x00]=EndPoint0Table[i];
 556   4                                                      ControlCmd.Length.WD--;
 557   4                                                      if (ControlCmd.Length.WD== 0)
 558   4                                                      {  
 559   5                                                              break;
 560   5                                                      }
 561   4                                              }
 562   3                                              break;
 563   3      
 564   3                                      case 0x60:
 565   3                                              for(i=iInterface_DescriptorTable_Begine;i<iInterface_DescriptorTable_End;i++)
 566   3                                              {                                        
 567   4                                                      USB_REG[0x00]=EndPoint0Table[i];
 568   4                                                      ControlCmd.Length.WD--;
 569   4                                                      if (ControlCmd.Length.WD == 0) 
 570   4                                                      {  
 571   5                                                              break;
 572   5                                                      }
 573   4                                              }
 574   3                                              break;
 575   3                              }
 576   2                              break;  
 577   2      
 578   2                      case 4:         //Interface descriptor
 579   2                              //It cannot be accessed individually, it must follow "Configuraton"
 580   2                              break;
 581   2                      
 582   2                      case 5:         //Endpoint descriptor
 583   2                              //It cannot be accessed individually, it must follow "Configuraton"
 584   2                              break;
 585   2                      
 586   2                      case 6:         //Device_Qualifier descritor
 587   2                              for(i=DeviceQualifier_DescriptorTable_Begine;i<DeviceQualifier_DescriptorTable_End;i++) 
 588   2                              {
 589   3                                      USB_REG[0x00]=EndPoint0Table[i];
 590   3                                      ControlCmd.Length.WD--;
 591   3                                      if (ControlCmd.Length.WD == 0) 
 592   3                                      {  
 593   4                                              break;
 594   4                                      }
 595   3                              }
 596   2                              break;
 597   2      
 598   2                      case 7:         // Other_Speed_Configuration
 599   2                              for(i=Other_Speed_Configuration_DescriptorTable_Begine;i<Other_Speed_Configuration_DescriptorTable_End;
             -i++)
 600   2                              {                        
 601   3                                      USB_REG[0x00]=EndPoint0Table[i];
 602   3                                      ControlCmd.Length.WD--;
 603   3                                      if (ControlCmd.Length.WD== 0)
 604   3                                      {  
 605   4                                              break;
 606   4                                      }
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 11  

 607   3                              }
 608   2                              break;
 609   2      
 610   2                      case 8:        // INTERFACE_POWER
 611   2                              break;
 612   2      
 613   2                      default:
 614   2                              // Invalid(bad) command, Return EP0_STALL flag 
 615   2                              // EndPoint 0 Control Register's address --> 0x0B
 616   2                              gc_CX_Status_flag |= CX_STL;
 617   2                      break;
 618   2              }
 619   1      }
 620          
 621          
 622          void set_descriptor(void)
 623          {
 624   1      #if 0
                      U8      i;
              
                      switch (ControlCmd.Value_H)
                      {
                              case 1:         // device descriptor
                                      for(i=Device_DescriptorTable_Begine;i<Device_DescriptorTable_End;i++)
                                      {
                                              EndPoint0Table[i]=USB_REG[0x00];
                                              ControlCmd.Length.WD--;
                                              if(ControlCmd.Length.WD == 0)
                                              {
                                                      break;
                                              }
                                      }
                              break;
              
                              case 2:         // configuration descriptor
                                      for(i=Configuration_DescriptorTable_Begine;i<Configuration_DescriptorTable_End;i++) 
                                      {                        
                                              EndPoint0Table[i]=USB_REG[0x00];
                                              ControlCmd.Length.WD--;
                                              if ( ControlCmd.Length.WD == 0)
                                              {
                                                      break;
                                              }
                                      }
                              break;
              
                              case 3:         // string descriptor
                                      switch (ControlCmd.Value_L) 
                                      {
                                              case 0x00:
                                                      for(i=iLANGID_DescriptorTable_Begine;i<iLANGID_DescriptorTable_End;i++)
                                                      {                                        
                                                              EndPoint0Table[i]=USB_REG[0x00];
                                                              ControlCmd.Length.WD--;
                                                              if ( ControlCmd.Length.WD == 0)
                                                              {
                                                                      break;
                                                              }
                                                      }
                                              break;
              
                                              case 0x10:
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 12  

                                                      for(i=iManufacturer_DescriptorTable_Begine;i<iManufacturer_DescriptorTable_End;i++)
                                                      {                                        
                                                              EndPoint0Table[i]=USB_REG[0x00];
                                                              ControlCmd.Length.WD--;
                                                              if ( ControlCmd.Length.WD == 0)
                                                              {
                                                                      break;
                                                              }
                                                      }
                                              break;
              
                                              case 0x20:
                                                      for(i=iProduct_DescriptorTable_Begine;i<iProduct_DescriptorTable_End;i++)
                                                      {                                        
                                                              EndPoint0Table[i]=USB_REG[0x00];
                                                              ControlCmd.Length.WD--;
                                                              if ( ControlCmd.Length.WD == 0)
                                                              {
                                                                      break;
                                                              }
                                                      }
                                              break;
                                              
                                              case 0x30:
                                                      for(i=iSerialNumber_DescriptorTable_Begine;i<iSerialNumber_DescriptorTable_End;i++)
                                                      {                                        
                                                              EndPoint0Table[i]=USB_REG[0x00];
                                                              ControlCmd.Length.WD--;
                                              if ( ControlCmd.Length.WD == 0)
                                                              {
                                                      break;
                                              }
                                      }
                                              break;
              
                                              case 0x40:
                                                      for(i=iConfiguraiton_DescriptorTable_Begine;i<iConfiguraiton_DescriptorTable_End;i++)
                                                      {                                        
                                                              EndPoint0Table[i]=USB_REG[0x00];
                                                      ControlCmd.Length.WD--;
                                              if ( ControlCmd.Length.WD == 0)
                                                              {
                                                      break;
                                              }
                                                      }
                                              break;
              
                                              case 0x50:
                                                      for(i=iDeviceQualifierString_DescriptorTable_Begine;i<iDeviceQualifierString_DescriptorTable_End;i++
             -)
                                                      {                                        
                                                              EndPoint0Table[i]=USB_REG[0x00];
                                                      ControlCmd.Length.WD--;
                                              if ( ControlCmd.Length.WD == 0)
                                                              {
                                                      break;
                                              }
                                                      }
                                              break;
              
                                              case 0x60:
                                                      for(i=iInterface_DescriptorTable_Begine;i<iInterface_DescriptorTable_End;i++)
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 13  

                                                      {                                        
                                                              EndPoint0Table[i]=USB_REG[0x00];
                                                      ControlCmd.Length.WD--;
                                              if ( ControlCmd.Length.WD == 0)
                                                              {
                                                      break;
                                              }
                                      }
                                      break;  
                                      }
                              break;  
              
                              case 4:         // interface descriptor
                                      //It cannot be accessed individually, it must follow "Configuraton"
                      break;
              
                              case 5:         // endpoint descriptor
                                      //It cannot be accessed individually, it must follow "Configuraton"
                      break;
              
                              case 6:         // Device_Qualifier descritor
                                      for(i=DeviceQualifier_DescriptorTable_Begine;i<DeviceQualifier_DescriptorTable_End;i++)
                                      {                        
                                              EndPoint0Table[i]=USB_REG[0x00];
                                      ControlCmd.Length.WD--;
                              if ( ControlCmd.Length.WD == 0)
                                              {
                                                      break;
                                              }
                                      }
                              break;
              
                              case 7:         // Other_Speed_Configuration
                                      for(i=Other_Speed_Configuration_DescriptorTable_Begine;i<Other_Speed_Configuration_DescriptorTable_End;
             -i++)
                                      {                        
                                              EndPoint0Table[i]=USB_REG[0x00];
                                      ControlCmd.Length.WD--;
                              if ( ControlCmd.Length.WD == 0)
                                              {
                                                      break;
                                              }
                                      }
                              break;
              
                              case 8:        // INTERFACE_POWER
                              break;
              
                              default:
                                      // Invalid(bad) command, Return EP0_STALL flag 
                                      // EndPoint 0 Control Register's address --> 0x0B
                                      gc_CX_Status_flag |= CX_STL;
                              break;
                      }//End-of-switch loop//
              #endif
 784   1      }
 785          
 786          
 787          void get_configuration(void)
 788          {
 789   1              // Is it correct to get data in this way?
 790   1              // Offset 5, bConfigurationValue of Table 9-10 Standard Configuration Descriptor
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 14  

 791   1              // It has no related define register on our FUSB200 Spec,
 792   1              // so we must keep & maintain this value on my program all the time
 793   1              // Get the Configuration Value from the descriptor and our register
 794   1              
 795   1              if (gbt_Have_set_configuration){
 796   2                    USB_REG[0x00] = EndPoint0Table[Configuration_DescriptorTable_Begine+5]; //ConfigurationValue;
 797   2              }
 798   1              else{                       // 若為Address State時的回應
 799   2                    USB_REG[0x00] = 0x00;
 800   2              }      
 801   1              // Endpoint 0 Data Port Register = 0x0C
 802   1              // If this value is zero(0), it means hadn't been configurated.
 803   1      }
 804          
 805          
 806          void set_configuration(void)
 807          {
 808   1              // unsigned char ConfigurationValue;
 809   1              // Endpoint 0 Data Port Register = 0x00
 810   1              // It has no related define register on our FUSB200 Spec, 
 811   1              // so we must keep & maintain this value on my program all the time
 812   1              if(ControlCmd.Value_L!=0x00)
 813   1              {
 814   2                    // 必需符合Configuration_DescriptorTable的對應欄位，方可進入Configured state      
 815   2              if(EndPoint0Table[Configuration_DescriptorTable_Begine+5]==ControlCmd.Value_L)
 816   2                      {               
 817   3                         gbt_Have_set_configuration = 1;
 818   3                    }
 819   2                      else
 820   2                      {
 821   3                         //Device should responds with a Request Error
 822   3                      }
 823   2              }
 824   1              else
 825   1              {
 826   2                    gbt_Have_set_configuration = 0;
 827   2              }
 828   1              // Set the Configuration Value into our register
 829   1              // Offset 5, bConfigurationValue of Table 9-10 Standard Configuration Descriptor
 830   1              // If this value is zero(0), it means hadn't been configurated.
 831   1              // Must set(turn on) the after_configuration bit after setting gc_Device_Address and set_configuration
 832   1              // After_Config bit(Bit 7) in the Device address register --> 0x01
 833   1      }
 834          
 835          /*****************************************************************************
 836          * NAME:         void get_interface(void)
 837          * DESCRIPTION:
 838          *               Setup -- Standard Command -- get interface (0x0A)
 839          *****************************************************************************/
 840          void get_interface(void){
 841   1              // If there exists many interfaces, Interface0,1,2,...N, 
 842   1              // You must check & select the specific one
 843   1              switch (ControlCmd.Index_L)          //switch by CurrentInterfaceNumber
 844   1              {       
 845   2                      case 0: // Interface0
 846   2                      USB_REG[0x00] = EndPoint0Table[Configuration_DescriptorTable_Begine+12];                      
 847   2                              // Offset 3, bAlternateSetting of Table 9-12 Standard Interface Descriptor
 848   2                              break;
 849   2                      case 1: // Interface1
 850   2                              break;
 851   2                      case 2: // Interface2
 852   2                              break;
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 15  

 853   2                      default:
 854   2                              break;
 855   2              }
 856   1      }
 857          
 858          /*****************************************************************************
 859          * NAME:         void set_interface(void)
 860          * DESCRIPTION:
 861          *               Setup -- Standard Command -- set interface (0x0B)
 862          *****************************************************************************/
 863          void set_interface(void){
 864   1              // If there exists many interfaces, Interface0,1,2,...N, 
 865   1              // You must check & select the specific one
 866   1              switch (ControlCmd.Index_L)          //switch by CurrentInterfaceNumber
 867   1              {       
 868   2                      case 0: // Interface0
 869   2                              // Set the AlternateSetting Value into our register
 870   2                              EndPoint0Table[Configuration_DescriptorTable_Begine+12] = ControlCmd.Value_L;
 871   2                              // Offset 3, bAlternateSetting of Table 9-12 Standard Interface Descriptor
 872   2                              // It has no related define register on our FUSB200 Spec, 
 873   2                              // so we must keep & maintain this value on my program all the time
 874   2                              break;
 875   2                      case 1: // Interface1
 876   2                              break;          
 877   2                      case 2: // Interface2
 878   2                              break;
 879   2                      default:
 880   2                              break;
 881   2              }
 882   1              // Clear All EPx Toggle Bit
 883   1              // OUT:RX Endpoint x Config and Status Register's address --> 0x63
 884   1              USB_REG[0xE9] |= 0x02;     // Reset Toggle Seeting
 885   1              USB_REG[0xE9] &= 0xFD;     // Reset Toggle Seeting
 886   1              // IN:TX Endpoint x Config and Status Register's address --> 0x41
 887   1              USB_REG[0xE9] |= 0x01;     // Reset Toggle Seeting
 888   1              USB_REG[0xE9] &= 0xFE;     // Disable Toggle Seeting
 889   1      }
 890          
 891          /*****************************************************************************
 892          * NAME:         void synch_frame(void)
 893          * DESCRIPTION:
 894          *               Setup -- Standard Command -- synch frame(0x0C)
 895          *****************************************************************************/
 896          void synch_frame(void){
 897   1              //unsigned char EndpointIndex=0, TransferType=0;
 898   1              //EndpointIndex =  ControlCmd.Index_L;
 899   1              //Endpoint Index, Low Byte
 900   1              //Does the Endpoint support Isochronous transfer type? 
 901   1              switch(ControlCmd.Index_L){     
 902   2                      case 1: // EP1
 903   2                              // TransferType = DescriptorTable[0x27] & 0x03;
 904   2                              if (0){ // Isochronous
 905   3                                      // Read 2-byte's Frame Number from "Frame Number Register"
 906   3                                      // Frame Number Register's address(Low Byte) ==> 0x04
 907   3                                      // Frame Number Register's address(High Byte) ==> 0x05
 908   3                              }
 909   2                              else{    // Not Isochronous                     
 910   3                                      // Invalid(bad) command, Return EP0_STALL flag
 911   3                                      // EndPoint 0 Control Register's address --> 0x0B
 912   3                                      gc_CX_Status_flag |=CX_STL;                             
 913   3                                      return;
 914   3                              }
C51 COMPILER V7.10   USB_EP0                                                               02/28/2011 10:30:06 PAGE 16  

 915   2                              break;
 916   2                      case 2: // EP2
 917   2                              // TransferType = DescriptorTable[0x2E] & 0x03;
 918   2                              if (0){ // Isochronous                  
 919   3                                      // Read 2-byte's Frame Number from "Frame Number Register"
 920   3                                      // Frame Number Register's address(Low Byte) ==> 0x04
 921   3                                      // Frame Number Register's address(High Byte) ==> 0x05
 922   3                              }
 923   2                              else{    // Not Isochronous                     
 924   3                                      // Invalid(bad) command, Return EP0_STALL flag
 925   3                                      // EndPoint 0 Control Register's address --> 0x0B
 926   3                                      gc_CX_Status_flag |= CX_STL;
 927   3                                      return;
 928   3                              }
 929   2                              break;
 930   2              }
 931   1      }
 932          
 933          
 934          void VendorCommand(void) 
 935          {
 936   1              switch (ControlCmd.Request) 
 937   1              {
 938   2                      case 0xFE:
 939   2                              if(gbt_enableCDROM)                                                             //20090526 chiayen add
 940   2                              {
 941   3                                      USB_REG[0x00] = 0x2;
 942   3                              }
 943   2                              else
 944   2                              {
 945   3                                      USB_REG[0x00] = 0x1;
 946   3                              }                                                             
 947   2                              gc_CX_Status_flag |= CX_DONE;       // EP0_Done
 948   2                      break;                           // EP0 Control Register's address --> 0x0B     
 949   2      
 950   2                      default:
 951   2                              gc_CX_Status_flag |= CX_STL;        // Invalid(Bad) command, Return EP0_STALL flag 
 952   2                      break;
 953   2              } 
 954   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1572    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----       1
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
