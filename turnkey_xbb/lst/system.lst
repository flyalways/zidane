C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE SYSTEM
OBJECT MODULE PLACED IN .\obj\system.obj
COMPILER INVOKED BY: F:\Keil C 7.10\chengxu\C51\BIN\C51.EXE MAIN\system.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(.
                    -.\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\system.lst) OBJECT(.\obj\system.obj)

line level    source

   1          #include <string.h>
   2          #include <intrins.h>
   3          #include "SPDA2K.h"
   4          #include "global.h"
   5          #include "usb_data.h"
   6          #include "PROTOTYP.h"
   7          #include "dos\fs_struct.h"
   8          #include "Memalloc.h"
   9          #include "Flash_code.h"
  10          #include "..\Header\UI_CODETAB.h"
  11          #include "..\IR\remote.h"
  12          #include "..\header\host_init.h"
  13          #include "..\..\libsource\header\UI_config.h"
  14          #include "..\LCM\TFT_display.h"
  15          #include "..\LCM\LCM.h"
  16          #include "..\LCM\LCM_func.h"
  17          #include "..\LCM\UI_icon.h"
  18          #include "..\header\variables.h"
  19          
  20          extern  data    bit     gb_HostConnect;
  21          
  22          extern U8 Host_Initial(void);
  23          
  24          void UI_host_detect(void);
  25          void Timer0_init(void);
  26          void TimeOutHandle(void);
  27          void LCM_Disp_XBMPArray_USB(U8 *Condition,U8 *Data);
  28          
  29          U8 Key_Detect(void);
  30          U8 READ_SARADC(U8 tc_ADCChannel);
  31          
  32          extern void MainMenuProcess();
  33          extern void SetupMenuProcess();
  34          extern void PowerOffProcess();
  35          extern void Dir_Task();  //20090107 chiayen add
  36          extern void ProcKey_in_idle(void);
  37          extern void ProcKey_in_play(void);
  38          extern void ProcKey_in_rec(void);
  39          extern void ProcKey_in_voice(void);
  40          extern void ProcKey_in_jpeg(void);
  41          extern void ProcKey_in_mjpeg(void);
  42          extern void load_nand_bank(void);
  43          extern void init_system(void);
  44          extern void LCM_init_process(void); 
  45          extern void     FM_drive(void); 
  46          extern void     FM_initial(void);
  47          extern void USER_GetUISetIndex(void);  //20090107 chiayen add
  48          
  49          extern U8 DOS_DIRtable(void);  //20090107 chiayen add
  50          extern U8 Get_LogData_PageIndex(void);
  51          extern U8 USER_LogFile_ReadWrite(U8 tbt_ReadOrWrite);//use reserveblock for log
  52          
  53          extern xdata U8 gc_LongKeyTimer;
  54          extern xdata U8 gc_LongKeyDelay;
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 2   

  55          
  56          extern  U8      gc_PseudoCard_Flag;
  57          extern  bit             gb_cmd_timeout;  //080925chiayen add
  58          extern  xdata   System_Struct gs_System_State;
  59          
  60          extern Host_register_INIT();
  61          U8      gc_clock_mode = CLOCK_MODE_XTL; // The current clock mode of the system.
  62          
  63          extern xdata    U32     gdw_HOSTStartSectorRead;
  64          
  65          extern data bit gb_Host_Exist; //20090803 chiayen add
  66          extern xdata    U32     gdw_HOSTStartSectorRead;  //20090803 chiayen add
  67          
  68          void main(void)
  69          {
  70   1      //      XBYTE[0xB091]=0x01;     // 1.8v/3.3v regulator turn on 
  71   1              XBYTE[0xB092]=0x77; // 3.2V & 1.9V
  72   1      //      XBYTE[0xB093]=0x00;     // LVR=2.4V
  73   1      
  74   1              // DSP initial
  75   1              XBYTE[0xB010]&=0xFE;    // Disable DSP clock, Jimi 080729 for pop noise as 1st time play
  76   1              XBYTE[0xB002]&=0xFE;    // Release DSP Reset, Jimi 080729 for pop noise as 1st time play
  77   1              XBYTE[0xB08a]|=0x08;    //(JC)MCU:audio DAC on
  78   1              XBYTE[0xB08a]|=0x10;    //(JC)MCU:Headphone driver on
  79   1              XBYTE[0xB08a]|=0x20;    //(JC)MCU:Headphone driver DD comm-mode bias o/p
  80   1              XBYTE[0xB0ED]|=0x02;    //(Jimi 091027)Audio DA zero cross reset bypass on
  81   1              XBYTE[0xB0C1]=0xB0;             //(Jimi 091027)Pre-mux , post-mux and internal XCK select
  82   1              XBYTE[0xB0C4]=2;                //(Jimi 091027)LCH speaker volume(i.e LCH OP Gain)
  83   1              XBYTE[0xB0C5]=2;                //(Jimi 091027)RCH speaker volume(i.e RCH OP Gain)
  84   1              
  85   1              //SAR ADC init
  86   1              XBYTE[0xB05E] = 0; // disable SAR FS clock
  87   1              XBYTE[0xB05F] = 0x5F; // SAR clock = 12MHz/16/6 = 125kHz = 8us
  88   1              
  89   1              //--------------------------------------------  // 
  90   1          gbt_Force_USB_FullSpeed =FALSE;
  91   1              gbt_USB_Detected = 0;
  92   1              gc_CardDetect = 0x00 ;
  93   1              gc_CardExist  = 0x00 ;                          // bit 0  : Nand Flash  bit 1: SD_Card
  94   1              gc_CardType   = 0x01 ;                          // default Flash Interface 
  95   1              gc_CardChangeStage =0x00;           // bit 0 : Nand  bit 1 : SD_Card    
  96   1              gw_FileSkipNumber=0;
  97   1              gb_TriggerFileSkip=0;
  98   1              gb_FindFile=0;
  99   1              gbt_Support_Dummy_Capacity =0;              // default disable dummy capacity function 
 100   1              gc_bCBWLUN=0; 
 101   1              gbt_enableCDROM =0;                                                     //09/04/24,joyce
 102   1              gc_CDROM_Size=0 ;
 103   1              init_system();  
 104   1              USB_PlugDetect();                               // Detect USB plug                                   
 105   1              //----------------------------------------------// Initial Flash module         
 106   1              Init_Flash_Reg();                                                           
 107   1              Init_Flash_Variable();
 108   1              //-------------- Need search Bank,Dsp ,hzk block info ,first---------//
 109   1              FDBP.cFDev = 0;
 110   1              XBYTE[0xB40F] = FDBP.cFDev;
 111   1              FlashReadID();
 112   1              Flash_State_Initial();
 113   1              Search_BankCode_Block();
 114   1      
 115   1              InitFlash();
 116   1      
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 3   

 117   1              Timer0_init();
 118   1      //home   just for test
 119   1              Get_LogData_PageIndex();  //chiayen0808 
 120   1              USER_LogFile_ReadWrite(0);//use reserveblock for log 
 121   1      
 122   1              XBYTE[0xB09F]|=0x06;//(JC)Vref Fast setup mode 'n Internal reference voltage power control
 123   1              gc_Vrefinit_Timer=60;
 124   1              XBYTE[0xB421]=0x13;
 125   1              TFT_init();
 126   1              #ifdef CAR_48
 127   1                      XBYTE[0xB102]|=0x3d;//p10=0;
 128   1              #else
                              XBYTE[0xB102] |= 0x01;
                      #endif
 131   1      
 132   1              TFT_PowerOnlogo();
 133   1              if(gbt_USB_Detected)
 134   1              {                                                               
 135   2                      USB_Task();
 136   2              }
 137   1      
 138   1              gb_Host_Exist=1;
 139   1              gb_SD_Exist=1;          
 140   1              if(!Host_DetectDevice())
 141   1              {
 142   2                      if(!Host_Initial())
 143   2                      {
 144   3                              gc_CurrentCard = CURRENT_MEDIA_HOST;
 145   3                              gb_FindFlag = 0;
 146   3                      }
 147   2                      else
 148   2                      {
 149   3                              gc_CurrentCard=0;
 150   3                      }               
 151   2              }
 152   1              else
 153   1              {                                        
 154   2                      if(SD_Card_Detect())
 155   2                      {
 156   3                              if(SD_Identification_Flow())
 157   3                              {
 158   4                                      gc_CardExist |=0x02;
 159   4                                      gc_CurrentCard=2;           
 160   4                              }
 161   3                              else
 162   3                              {
 163   4                                      gc_CurrentCard=0;
 164   4                                      gc_CardExist &=0xFD;
 165   4                                      gb_FindFlag = 0;            
 166   4                              }     
 167   3                      }                                
 168   2                      else
 169   2                  {
 170   3                              gb_SD_Exist=0;
 171   3                              gc_CurrentCard = 0;
 172   3                  }
 173   2              }
 174   1              XBYTE[0xB400] =0x01;
 175   1              XBYTE[0xB010]&=0xFE;    // Disable DSP clock, Jimi 080729 for pop noise as 1st time play
 176   1              XBYTE[0xB002]&=0xFE;    // Release DSP Reset, Jimi 080729 for pop noise as 1st time play
 177   1              XBYTE[0xB08a]|=0x08;//(JC)MCU:audio DAC on
 178   1              XBYTE[0xB08a]|=0x10;//(JC)MCU:Headphone driver on
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 4   

 179   1              XBYTE[0xB08a]|=0x20;//(JC)MCU:Headphone driver DD comm-mode bias o/p
 180   1      
 181   1              //SAR ADC init
 182   1              XBYTE[0xB05E] = 0; // disable SAR FS clock
 183   1              XBYTE[0xB05F] = 0x5f; // SAR clock = 12MHz/16/6 = 125kHz = 8us
 184   1      
 185   1              Get_LogData_PageIndex();  //chiayen0808
 186   1              USER_LogFile_ReadWrite(0);//use reserveblock for log
 187   1              if((gw_FM_frequency<875) || (gw_FM_frequency>1080))
 188   1              {
 189   2                      gw_FM_frequency=875;
 190   2              }
 191   1              FM_initial(); 
 192   1              FM_drive();
 193   1              gc_SetNumber = gw_PagesPerBlock >> 2; //1set=4pages for dir management, Ching 080816  //20090107 chiayen 
             -add
 194   1              gc_SetIndex = 0; //Ching 080816  //20090107 chiayen add 
 195   1              USER_GetUISetIndex();   //for DIR table index  //20090107 chiayen add
 196   1      
 197   1              gb_FindFlag = 0;
 198   1              if (DOS_Initialize()) //20090803 chiayen modify
 199   1              {
 200   2                      gdw_HOSTStartSectorRead=0xFFFFFFF0; 
 201   2                      if(gc_CurrentCard==CURRENT_MEDIA_HOST)
 202   2                      {
 203   3                              if(SD_Card_Detect())
 204   3                              {
 205   4                                      gb_SD_Exist=1;  
 206   4                                      if(SD_Identification_Flow())
 207   4                                      {
 208   5                                              gc_CardExist |=0x02;
 209   5                                              gc_CurrentCard=2;           
 210   5                                      }
 211   4                                      else
 212   4                                      {
 213   5                                              DEVICE_REG[0x00]= 0x01;
 214   5                                              gc_CurrentCard=0;
 215   5                                              gc_CardExist &=0xFD;
 216   5                                              gb_FindFlag = 0;            
 217   5                                      }     
 218   4                              }                                
 219   3                              else
 220   3                          {
 221   4                                      DEVICE_REG[0x00]= 0x01;
 222   4                                      gb_SD_Exist=0;
 223   4                                      gc_CurrentCard = 0;
 224   4                          }                                   
 225   3                      }
 226   2                      else
 227   2                      {       
 228   3                              DEVICE_REG[0x00]= 0x01;  //20090730 chiayen add
 229   3                              gc_CurrentCard=0;
 230   3                              gc_CardExist &=0xFD;
 231   3                              gb_FindFlag = 0;
 232   3                              InitFlash();                                    
 233   3                      }
 234   2                      DOS_Initialize();
 235   2              }
 236   1              gc_CurrentCard_backup=gc_CurrentCard; //20090803 chiayen move here
 237   1              gs_File_FCB[0].dw_FDB_StartCluster = gdw_DOS_RootDirClus;
 238   1              DOS_Search_File(C_File_All|C_Cnt_FileNo, C_MusicFileType, C_CmpExtName|C_Next);//(JC)count music file no.
             - in root
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 5   

 239   1              ir_init();
 240   1              EA  = 1;
 241   1              gc_Task_Current=C_Task_Play;
 242   1              gc_Task_Next=C_Task_Play;
 243   1              gc_PhaseInx=0;
 244   1              gw_init_needed=0xffff;
 245   1              Detect_USB();
 246   1              Polling_TaskEvents();
 247   1              if(gc_Task_Current!=gc_Task_Next)
 248   1              {
 249   2                      gc_Task_Current=gc_Task_Next;   
 250   2              }
 251   1              while(1)
 252   1              {               
 253   2                      switch(gc_Task_Current)
 254   2                      {
 255   3                              case C_Task_Play:
 256   3                                      Play_Task();
 257   3                              break;                                  
 258   3      
 259   3                              case C_Task_USB:
 260   3                                      USB_Task();
 261   3                              break;
 262   3      
 263   3                              case C_Task_Dir:  //20090107 chiayen add
 264   3                                      Dir_Task();
 265   3                              break;
 266   3      
 267   3                              case C_Task_Jpeg:  //20090107 chiayen add
 268   3                                      Jpeg_Task();
 269   3                              break;
 270   3      
 271   3                              case C_Task_Mjpeg:  //20090107 chiayen add
 272   3                                      Mjpeg_Task();
 273   3                              break;
 274   3      
 275   3                              case C_Task_PlayMenu:  //20090107 chiayen add
 276   3      //                              PlayMenuProcess();
 277   3                              break;
 278   3      
 279   3                              case C_Task_PlayMenu_IR:  //20090107 chiayen add
 280   3      //                              PlayMenuProcess_IR();
 281   3                              break;
 282   3      
 283   3                              case C_Task_Setting:  //20090107 chiayen add
 284   3                                      SetupMenuProcess();
 285   3                              break;
 286   3      
 287   3                              case C_Task_Menu:
 288   3                                      MainMenuProcess();
 289   3                              break;                                  
 290   3      
 291   3                              case C_Task_PowerOff:
 292   3                                      PowerOffProcess();
 293   3                              break;
 294   3                      }
 295   2              }
 296   1      }
 297          //1
 298          
 299          U8 Key_Detect(void)
 300          {
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 6   

 301   1              if(gc_KeyValue==0)
 302   1              {  
 303   2                      gc_KeyEvent=0;
 304   2                      return 1;
 305   2              }
 306   1              else
 307   1              {
 308   2                      gc_KeyEvent = gc_KeyValue;
 309   2                      gc_KeyValue = 0;
 310   2              if(gc_KeyEvent==0x12) 
 311   2              { //sunzhk add power off 100809 
 312   3                  if(gs_System_State.c_Phase!=TASK_PHASE_STOP) 
 313   3                  { 
 314   4                          if(gc_Task_Current == C_Task_Play) 
 315   4                          { 
 316   5                                  play_stop();
 317   5                          } 
 318   4                          else if(gc_Task_Current == C_Task_Jpeg) 
 319   4                          { 
 320   5                                  jpeg_stop();
 321   5                          } 
 322   4                          else if(gc_Task_Current == C_Task_Mjpeg) 
 323   4                          { 
 324   5                                  mjpeg_stop();
 325   5                          }                   
 326   4                  }           
 327   3                  gc_Task_Next = C_Task_PowerOff; 
 328   3                  gc_PhaseInx = C_PowerOff; 
 329   3                  gc_KeyEvent = 0; 
 330   3                  return 0; 
 331   3              } 
 332   2                      if(gc_Task_Current==C_Task_Play)  //20090107 chiayen modify
 333   2                      {
 334   3                              ProcKey_in_play();
 335   3                      }
 336   2                      else if(gc_Task_Current==C_Task_Jpeg)  //20090107 chiayen modify
 337   2                      {
 338   3                              ProcKey_in_jpeg();
 339   3                      }
 340   2                      else if(gc_Task_Current==C_Task_Mjpeg)  //20090107 chiayen modify
 341   2                      {
 342   3                              ProcKey_in_mjpeg();
 343   3                      }
 344   2                      else
 345   2                      {
 346   3                              ProcKey_in_play();
 347   3                      }
 348   2                      return 0;
 349   2              }
 350   1      }
 351          
 352          
 353          void USB_PlugDetect(void)
 354          {
 355   1              xdata   U8 tc_i;
 356   1              xdata   U8 tc_usb_detect;
 357   1      
 358   1              XBYTE[0xB0D1] = 0xf0;//(JC)from debounce ckt
 359   1              tc_i =0x08;
 360   1              while(tc_i)
 361   1              {
 362   2                      tc_usb_detect = XBYTE[0xB0D1]&0x02;
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 7   

 363   2                      tc_i--;
 364   2              }
 365   1              if(tc_usb_detect)
 366   1              {
 367   2                      if(gb_cmd_timeout==0)
 368   2                      {
 369   3                      gbt_USB_Detected = 1;     // USB_Detected
 370   3                      }
 371   2              }
 372   1              else
 373   1              {
 374   2                  gbt_USB_Detected = 0;
 375   2                      gb_cmd_timeout=0;
 376   2              }
 377   1      }
 378          
 379          
 380          U8 READ_SARADC(U8 tc_ADCChannel)
 381          {
 382   1              xdata   U8 tc_ADCValue;
 383   1      
 384   1              if(tc_ADCChannel==2)
 385   1              {
 386   2                      XBYTE[0xB094]=1;
 387   2              }
 388   1              XBYTE[0xB060]=(tc_ADCChannel<<2)|0x01;
 389   1              for(tc_ADCValue=0;tc_ADCValue<50;tc_ADCValue++);
 390   1              XBYTE[0xB05E]=1;        // enable SAR FS clock
 391   1              while((XBYTE[0xB061]&0x01)==0);
 392   1              tc_ADCValue=XBYTE[0xB062];
 393   1              XBYTE[0xB05E]=0;        // disable SAR FS clock
 394   1              XBYTE[0xB094]=0;
 395   1              return tc_ADCValue;
 396   1      }
 397          
 398          
 399          void Timer0_init()//(JC)Timer0 init;~7.5mS@24Mhz MCU 
 400          {
 401   1      //=========Timer0 init s============
 402   1              // set timer 0 and activete it.
 403   1              TR0 = 0;
 404   1      
 405   1              TH0 = gc_T0IntervalMSB;
 406   1              TL0 = gc_T0IntervalLSB;
 407   1      
 408   1              ET0 = 1;
 409   1              TR0 = 1;
 410   1      //=========Timer0 init f============
 411   1      }
 412          
 413          /* According to EVB, ideal key values are 0, 59, 88, 118, 163, 203, 237 and 255(No key press).
 414           * To identify key presses, we use middle values to discriminate between keys.
 415           */
 416          //! Mapping ADC value to a key.
 417          void Get_KeyValue(U8 ADCValue)
 418          {
 419   1              if(ADCValue>246)
 420   1              {               
 421   2                      gc_key_Pressed=C_Key_None;
 422   2              }       
 423   1              else if(ADCValue>220)
 424   1              {       
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 8   

 425   2                      gc_key_Pressed=C_Key_Vol;       
 426   2              }
 427   1              else if(ADCValue>183)
 428   1              {       
 429   2                      gc_key_Pressed=C_Key_Rec;       
 430   2              }
 431   1              else if(ADCValue>140)
 432   1              {       
 433   2                      gc_key_Pressed=C_Key_Voldn;     
 434   2              }
 435   1              else if(ADCValue>103)
 436   1              {
 437   2                      gc_key_Pressed=C_Key_Volup;     
 438   2              }
 439   1              else if(ADCValue>74)
 440   1              {
 441   2                      gc_key_Pressed=C_Key_Next;              
 442   2              }
 443   1              else if(ADCValue>30)
 444   1              {
 445   2                      gc_key_Pressed=C_Key_Prev;                              
 446   2              }
 447   1              else
 448   1              {
 449   2                      gc_key_Pressed=C_Key_Mode;
 450   2              }
 451   1      }
 452          
 453          
 454          void TimeOutHandle()
 455          {
 456   1              if(gbLKeyTimer_Timeout==1)//(JC)Long key detect period 
 457   1              {
 458   2                      gbLKeyTimer_Timeout=0;
 459   2                      if(gc_LongKeyTimer)
 460   2                      {
 461   3                              gc_LongKeyTimer++;
 462   3                      }
 463   2              }
 464   1      
 465   1              if(gbGetKey_Timeout==1)//(JC)Read ADC value(get key) period 
 466   1              {
 467   2                      gbGetKey_Timeout=0;     
 468   2                      if((!gc_KeyValue)&&(!gc_KeyDet_Mask))//(JC)Key event determined //20090107 chiayen modify
 469   2                      {
 470   3                      /*      #ifndef CAR_64
 471   3                              if(!P1_3)  //chiayenmark for car
 472   3                              {
 473   3                                      gc_key_Pressed=C_Key_Play;
 474   3                              }
 475   3                              else
 476   3                              #endif*/
 477   3                              {
 478   4                                      Get_KeyValue(READ_SARADC(0));
 479   4                              }
 480   3      
 481   3                              if((gc_key_PrevPressed&0x0f)==gc_key_Pressed)
 482   3                              {
 483   4                                      if(gc_key_Pressed != C_Key_None)
 484   4                                      {
 485   5                                              if(gc_LongKeyTimer>gc_LongKeyDelay)
 486   5                                              {
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 9   

 487   6                                                      gc_key_PrevPressed |= 0x10;//(JC)long key determined    
 488   6      
 489   6                                                      if((gc_key_Pressed==C_Key_Mode) && (gc_LongKeyCount==0))
 490   6                                                      {
 491   7                                                      gc_KeyValue = gc_key_PrevPressed & 0x7f;
 492   7                                                              gc_LongKeyCount=1;
 493   7                                                      }
 494   6                                                      if(gc_key_Pressed!=C_Key_Mode) 
 495   6                                                      {
 496   7                                                                      gc_KeyValue = gc_key_PrevPressed & 0x7f;
 497   7                                                      }
 498   6      
 499   6                                                      gc_LongKeyTimer = REPEATKEY_DELAYVALUE; //(JC)16, for long key over-pressed, counting from 16 to 29.
             -.. and determining long key again
 500   6                                                      gc_LongKeyDelay = (gc_LongKeyDelay < MIN_REPEATKEYDELAY)?MIN_REPEATKEYDELAY:/*(gc_LongKeyDelay-3)*/(
             -REPEATKEY_DELAYVALUE+6);  //20090107 chiayen modify   
 501   6                                              }
 502   5                                              else
 503   5                                              {
 504   6                                                      gc_key_PrevPressed |= 0x80;
 505   6                                              }       
 506   5                                      }
 507   4                              }
 508   3                              else if(gc_key_Pressed==C_Key_None)//(JC)key released
 509   3                              {
 510   4                                      if((gc_key_PrevPressed & 0x90) == 0x80)//(JC)short key released
 511   4                                      {
 512   5                                              gc_KeyValue = gc_key_PrevPressed & 0x7f;
 513   5                                      }
 514   4                                      else if((gc_key_PrevPressed & 0x90) == 0x90)//(JC)long key released
 515   4                                      {
 516   5                                              gc_KeyValue = (gc_key_PrevPressed | 0x20) & 0x6f;//(JC)key value will be 0x2x,long-pressed key releas
             -ed
 517   5                                              gc_LongKeyCount=0; //chiayen0807
 518   5                                      }
 519   4                                      gc_key_PrevPressed = C_Key_None;
 520   4                                      gc_LongKeyTimer = 0;
 521   4                                      gc_LongKeyDelay = 0;    
 522   4                              }
 523   3                              else//(JC)new key pressed
 524   3                              {
 525   4                                      gc_key_PrevPressed = gc_key_Pressed;
 526   4                                      gc_LongKeyTimer = 1;//(JC)long key timer launching
 527   4                                      if (!gc_LongKeyDelay)
 528   4                                  {
 529   5                                              gc_LongKeyDelay = MAX_REPEATKEYDELAY;
 530   5                                      }
 531   4                              }
 532   3                      }
 533   2              }
 534   1      }
 535          
 536          
 537          
 538          void Polling_TaskEvents(void)
 539          {
 540   1              if(gc_Vrefinit_Timer==0)
 541   1              {
 542   2                      TimeOutHandle();
 543   2                      Key_Detect();
 544   2              }
 545   1      }
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 10  

 546          
 547          
 548          
 549          #define CK2_FLAG        (0<<6)
 550          #define CK1_FLAG        (1<<6)
 551          
 552          static U8 code gac_clock_table[][8] = 
 553          { 
 554           //0xB006,    0xB009, 0xB024, 0xB025, 0xB026, TH1  TH0            TL0             
 555           { 0x00,      0,      0,      0,      0,      243, C_T0_12MhzMSB, C_T0_12MhzLSB}, // No PLL,  MCU=12M, PER
             -I=12M, DSP=12M        CLOCK_MODE_XTL 
 556           { 0x08|0x40, 0x42,   1,      1,      0,      243, C_T0_12MhzMSB, C_T0_12MhzLSB}, // PLL=24M, MCU=12M, PER
             -I=12M, DSP=19M        CLOCK_MODE_MP3 
 557           { 0x08|0x40, 0,      0,      0,      0,      230, C_T0_24MhzMSB, C_T0_24MhzLSB}, // PLL=24M, MCU=24M, PER
             -I=24M, DSP=24M        CLOCK_MODE_MP3LRC 
 558           { 0x10|0x40, 0,      3,      3,      0,      243, C_T0_12MhzMSB, C_T0_12MhzLSB}, // PLL=48M, MCU=12M, PER
             -I=12M, DSP=48M                CLOCK_MODE_WMA 
 559           { 0x10|0x40, 0,      1,      1,      0,      230, C_T0_24MhzMSB, C_T0_24MhzLSB}, // PLL=48M, MCU=24M, PER
             -I=24M, DSP=48M        CLOCK_MODE_JPEG 
 560           { 0x18|0x40, 0,      0,      0,      0,      178, C_T0_72MhzMSB, C_T0_72MhzLSB}, // PLL=72M, MCU=72M, PER
             -I=72M, DSP=72M        CLOCK_MODE_MJPEG 
 561           { 0x18|0x40, 0,      0,      0,      2,      178, C_T0_72MhzMSB, C_T0_72MhzLSB}, // PLL=72M, MCU=72M, PER
             -I=72M, DSP=24M        CLOCK_MODE_USB 
 562           {      20 |0x40, 0,      0,      0,      0,      217, C_T0_48MhzMSB, C_T0_48MhzLSB},           // 5-MJPG PLL=60M, MCU=6
             -0M, PERI=60M, DSP=48M  CLOCK_MODE_MJPEG 
 563           //{    20 |0x40,                       0,                                0,                            0,                        0,                            217, C_T0_48MhzMSB, C_T0_48MhzLSB},             // 5
             --MJPG PLL=60M, MCU=60M,
 564           }; 
 565          
 566          
 567          
 568          
 569          
 570          
 571          //! Set CPU/Peripheral/DSP clock divider in PLL mode.
 572          static void change_clock_ratio(U8 r)
 573          {
 574   1              // disable auto wait
 575   1              XBYTE[0xB021] = 0;
 576   1              // set new divide ratio
 577   1              XBYTE[0xB009] = gac_clock_table[r][1];  // cpu_mask_sel, per_mask_sel, dsp_mask_sel & n_mask
 578   1              XBYTE[0xB024] = gac_clock_table[r][2];  // CPUfreq
 579   1              XBYTE[0xB025] = gac_clock_table[r][3];  // PERfreq
 580   1              XBYTE[0xB026] = gac_clock_table[r][4];  // DSPfreq
 581   1              // Trigger the switch
 582   1              XBYTE[0xB020] = 0;      // cpu_protect = dsp_protect = per_protect = 0
 583   1              XBYTE[0xB020] = 1;      // freqchange = 1
 584   1              _nop_();
 585   1      }
 586          
 587          
 588          static void xtl_to_pll(U8 tc_clock_mode)
 589          {
 590   1              XBYTE[0xB006] = gac_clock_table[tc_clock_mode][0];
 591   1              XBYTE[0xB006] = gac_clock_table[tc_clock_mode][0] | (1<<5);
 592   1              USER_DelayDTms(2);
 593   1              XBYTE[0xB008] = 2;      // PLLS_SWRSTN = 1
 594   1              XBYTE[0xB008] = 3;      // PLLS_MODE = 1(PLL clock output)
 595   1              change_clock_ratio(tc_clock_mode);
 596   1      }
 597          
 598          //! Change clock source from PLL to crystal.
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 11  

 599          static void pll_to_xtl(void)
 600          {
 601   1              change_clock_ratio(CLOCK_MODE_XTL);
 602   1              XBYTE[0xB008] = 2;      // PLLS_SWRSTN = 1, PLLS_MODE = 0(PLL clock output)
 603   1      }
 604          
 605          U8 set_clock_mode(U8 mode)
 606          {
 607   1              U8 tc_old_mode;
 608   1      
 609   1              if (gc_clock_mode == mode)
 610   1              {
 611   2                      return gc_clock_mode;
 612   2              }
 613   1      
 614   1              if (gac_clock_table[gc_clock_mode][0] != gac_clock_table[mode][0])
 615   1              {
 616   2                      if (gc_clock_mode != CLOCK_MODE_XTL)
 617   2                      {
 618   3                              pll_to_xtl();
 619   3                      }
 620   2                      if (mode != CLOCK_MODE_XTL)
 621   2                      {
 622   3                              xtl_to_pll(mode);
 623   3                      }
 624   2              }
 625   1              else
 626   1              {
 627   2                      change_clock_ratio(CLOCK_MODE_XTL);
 628   2                      change_clock_ratio(mode);
 629   2              }
 630   1              TH1 = gac_clock_table[mode][5];
 631   1              tc_old_mode = gc_clock_mode;
 632   1              gc_clock_mode = mode;
 633   1              gc_T0IntervalMSB = gac_clock_table[gc_clock_mode][6];
 634   1              gc_T0IntervalLSB = gac_clock_table[gc_clock_mode][7];
 635   1      
 636   1              return tc_old_mode;
 637   1      }
 638          
 639          
 640          /***************************************************************************
 641          * NAME:         bit  SD_Card_Detect(void)
 642          * DESCRIPTION:
 643          ***************************************************************************/
 644          bit SD_Card_Detect(void)
 645          {
 646   1      #ifdef CAR_64
                  P1|=0x02;
                      XBYTE[0xB102]&=0xFD;
              #elif defined(CAR_48)
 650   1          P1|=0x02;
 651   1              XBYTE[0xB102]&=0xFD;
 652   1      #elif defined(EVB_128)  
                  P1|=0x80;
                      XBYTE[0xB102]&=0x7F;
              #endif  
 656   1      
 657   1              if(!SD_Detect)
 658   1              {
 659   2                      if(gc_PseudoCard_Flag==0)
 660   2                      {
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 12  

 661   3                              gc_CardDetect |= 0x02;
 662   3                              return 1;
 663   3                      }
 664   2                      else
 665   2                      {
 666   3                              return 0;       
 667   3                      }
 668   2              }
 669   1              else
 670   1              {
 671   2                  gc_CardDetect &= 0xFD; 
 672   2                  gc_CardExist &=0xFD;
 673   2                  gc_Start_Stop_Flag &= 0xFD;
 674   2                  gc_PseudoCard_Flag=0;
 675   2                  return 0;
 676   2              }       
 677   1      }
 678          
 679          
 680          U8 CheckUSBPlugIN(void)
 681          {
 682   1              U8 i;
 683   1      
 684   1              XBYTE[0xB011] |= 0x20;   //bit 4   turn on usb_device clk
 685   1      
 686   1          XBYTE[0xB016]  = 0x04;                       // power on default is 0x04
 687   1          XBYTE[0xB0E9] &= 0xFE;                       // Enable usb pll clk 
 688   1          USER_DelayDTms(5);                              // 使用Delay 方式不用polling方式
 689   1          XBYTE[0xB01D]  =0x00;
 690   1      
 691   1              XBYTE[0xB002] |= 0x04;   //bit 3   turn on USB_SW_RESET
 692   1          XBYTE[0xB002] &= 0xFB;   //bit 3   trun off USB_SW_RESET
 693   1          XBYTE[0xB002]  |= 0x02;   //bit 2   turn on USB_host_SW_RESET
 694   1              XBYTE[0xB5e6]  = 0x00;   //bulksram gated clock
 695   1              XBYTE[0xB522]  = 0x01;   //USB2.0 UTMI clock mode set   
 696   1              XBYTE[0xB018]  = 0x01;          //USB clock select                              //TONY
 697   1              XBYTE[0xB002] &= 0xFD;   //bit 2   turn off USB_host_SW_RESET
 698   1      
 699   1              Syn_Reset();
 700   1              XBYTE[0xB018]  = 0x01;          //USB clock select                              //TONY  
 701   1              XBYTE[0xB019]  = 0x01;   //host mode
 702   1              if(XBYTE[0xB615]==0x01)
 703   1              {
 704   2                      i=100;
 705   2                      while(i)        i--;    
 706   2                      if(XBYTE[0xB615]==0x01)
 707   2                      {
 708   3                              return 1;
 709   3                      }
 710   2              }
 711   1              return 0;
 712   1      }
 713          
 714          
 715          U8 Host_DetectDevice(void)
 716          {
 717   1              xdata   U8 sts;
 718   1      
 719   1              if(gc_CurrentCard == CURRENT_MEDIA_HOST)
 720   1              {
 721   2                      if(gb_HostConnect==0)
 722   2                      {
C51 COMPILER V7.10   SYSTEM                                                                02/28/2011 10:30:13 PAGE 13  

 723   3                              return 1;
 724   3                      }
 725   2                      else
 726   2                      {
 727   3                              return 0;
 728   3                      }
 729   2              }
 730   1              else
 731   1              {
 732   2                      sts = CheckUSBPlugIN();
 733   2                      if(sts) 
 734   2                      {
 735   3                              return 0;
 736   3                      }
 737   2                      else
 738   2                      {
 739   3                              gb_HostConnect = 0;
 740   3                              return 1;
 741   3                      }
 742   2              }
 743   1      }
 744          
 745          
 746          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1635    ----
   CONSTANT SIZE    =    680    ----
   XDATA SIZE       =    794       2
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     13    ----
   IDATA SIZE       =     44    ----
   BIT SIZE         =     30    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
