C51 COMPILER V7.10   L51_BANKINGLOADER                                                     03/02/2011 09:21:38 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE L51_BANKINGLOADER
OBJECT MODULE PLACED IN ..\LIBSOURCE\ASM\L51_BankingLoader.OBJ
COMPILER INVOKED BY: F:\Keil C 7.10\chengxu\C51\BIN\C51.EXE ..\LIBSOURCE\ASM\L51_BankingLoader.c LARGE OPTIMIZE(9,SIZE) 
                    -BROWSE NOAREGS INCDIR(..\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\L51_BankingLoader.lst) S
                    -RC(.\obj\L51_BankingLoader.SRC)

line level    source

   1          #include <stdio.h>
   2          #include "SPDA2K.h"
   3          
   4          #define SECTORS_PER_BANK        32  //1 sector = 1K Byte
   5          
   6          U8 data gc_bank_number = 0;     //!< The current banking number in instruction SRAM.
   7          U8 tgc_InAddr; //0602 Jay add for  
   8          bit FLASH_MultRead_DRAM(bit tbt_Backup, U8 tc_FPage, UBYTE tc_Block1, UBYTE tc_Block0, UBYTE tc_PageNum);
   9          void Banking_NAND_InAddr_To_Column_NAND(UBYTE tc_InAddr);
  10          void Banking_NAND_FBlock_FPage_FBank_To_PhyAddr_NAND(U8  tc_FPage, UBYTE tc_FBank, UBYTE tc_Block1, UBYTE 
             -tc_Block0);
  11          
  12          //! Entry of the banking loader.
  13          void perform_nand_bank_call(void)
  14          {
  15   1      #pragma asm
  16   1      Using3_R0 EQU   018H
  17   1      Using3_R1 EQU   019H
  18   1      Using3_R2 EQU   01AH
  19   1      Using3_R3 EQU   01BH
  20   1      Using3_R4 EQU   01CH
  21   1      Using3_R5 EQU   01DH
  22   1      Using3_R6 EQU   01EH
  23   1      Using3_R7 EQU   01FH
  24   1      
  25   1      
  26   1              cjne A, gc_bank_number, ?_need_to_load_nand_bank
  27   1              push DPL
  28   1              push DPH
  29   1              ret
  30   1      
  31   1      ?_need_to_load_nand_bank:
  32   1              //Target Bank Number is in register A
  33   1              push gc_bank_number
  34   1              mov  gc_bank_number, A
  35   1      
  36   1              //push the bank recover function for returning use
  37   1              mov  A, #LOW return_from_nand_bank
  38   1              push ACC
  39   1              mov  A, #HIGH return_from_nand_bank
  40   1              push ACC
  41   1              //push target address
  42   1              push DPL
  43   1              push DPH
  44   1              //push PSW and IE
  45   1              push PSW
  46   1              mov  PSW, #18   //use register bank3
  47   1              push IE
  48   1              clr  EA                 //disable IRQ
  49   1      
  50   1              call load_nand_bank
  51   1      
  52   1              //recover IE and PSW
C51 COMPILER V7.10   L51_BANKINGLOADER                                                     03/02/2011 09:21:38 PAGE 2   

  53   1              pop  IE
  54   1              pop  PSW
  55   1              ret
  56   1      #pragma endasm
  57   1      }
  58          
  59          //! Exit of the banking loader.
  60          void return_from_nand_bank(void)
  61          {
  62   1      #pragma asm
  63   1              mov  A, gc_bank_number  //A is current bank
  64   1              pop  gc_bank_number             //gc_bank_number is return bank
  65   1              push PSW
  66   1              cjne A, gc_bank_number, ?_recover_need_load_nand
  67   1              pop PSW
  68   1              ret
  69   1      ?_recover_need_load_nand:
  70   1              mov  PSW, #18                   //use register bank3
  71   1              push IE
  72   1              clr  EA                                 //disable IRQ
  73   1      
  74   1              call load_nand_bank
  75   1      
  76   1              //pop PSW and IE
  77   1              pop  IE
  78   1              pop  PSW
  79   1              ret
  80   1      #pragma endasm
  81   1      }
  82          
  83          
  84          //! NAND banking loader.
  85          void load_nand_bank(void) using 3
  86          {
  87   1              U8 tc_banks_per_block, tc_bank_number;
  88   1              U8  tc_FPage;
  89   1              U8  tc_InAddr;
  90   1              union WORDDataType u_FBlock;
  91   1              U8 tc_pages_per_bank;
  92   1              U8 tc_bank_block, tc_bank_offset,tc_InAddrMax;
  93   1      
  94   1              XBYTE[0xB400]=1;
  95   1              tc_InAddrMax=gc_InAddrMax;
  96   1      
  97   1              tc_pages_per_bank = SECTORS_PER_BANK/tc_InAddrMax;                      // gc_InAddrMax = sectors per page
  98   1              tc_banks_per_block = gw_PagesPerBlock/tc_pages_per_bank;        // Number of 16kB banks in a block
  99   1              if (gc_bank_number == 0)
 100   1              {
 101   2                      tc_bank_block = 0;
 102   2                      tc_FPage = (48/tc_InAddrMax);                   // commom is 20k 
 103   2                      tgc_InAddr = 48%tc_InAddrMax;   //0602 Jay add
 104   2              }
 105   1              else
 106   1              {
 107   2                      tc_bank_number  = gc_bank_number +2;    // Offset of the bank to the start of code region in unit of 16kB
 108   2                      tc_bank_block   = tc_bank_number / tc_banks_per_block;  // in unit of 16kB
 109   2                      tc_bank_offset  = tc_bank_number % tc_banks_per_block;  // Offset of the bank in its block in unit of 16kB
 110   2                      tc_FPage                = tc_bank_offset * tc_pages_per_bank;   // page offset of the bank in its block
 111   2                      tgc_InAddr       = 0;
 112   2              }
 113   1              tc_InAddr =tgc_InAddr;
 114   1          DEVICE_REG[0x0F] = 0x00;     // CE0
C51 COMPILER V7.10   L51_BANKINGLOADER                                                     03/02/2011 09:21:38 PAGE 3   

 115   1          Device_Read_SRAM_Index.WD = 0x6000;
 116   1          u_FBlock.WD = Bank_Block_B[tc_bank_block];
 117   1      //      dbprintf("%bx ", gc_bank_number);
 118   1          if(FLASH_MultRead_DRAM(0, tc_FPage, u_FBlock.BY[1], u_FBlock.BY[0], SECTORS_PER_BANK-8))
 119   1              {
 120   2      //              dbprintf("BankFail:%bx\n",gc_bank_number);
 121   2                      gbt_Code_NeedRecover=1;
 122   2              tgc_InAddr=tc_InAddr;
 123   2              Device_Read_SRAM_Index.WD = 0x6000;
 124   2              u_FBlock.WD = Bank_Block_A[tc_bank_block];
 125   2                      if (FLASH_MultRead_DRAM(1, tc_FPage, u_FBlock.BY[1], u_FBlock.BY[0], SECTORS_PER_BANK-8))
 126   2                      {
 127   3                              GLOBAL_REG[0x91] &= ~0x01;      // turn off LDO
 128   3                              CPU_REG[0x20] = 1;      // select internal boot ROM.
 129   3                              CPU_REG[0x21] = 1;      // reset MCU
 130   3                      }
 131   2              }
 132   1      }
 133          
 134          
 135          /*********************************************************************************
 136          * NAME:                    bit  FLASH_MultRead_DRAM(void)
 137          * DESCRIPTION:
 138          *   If ECC is Uncorrectable, return TRUE; else return FALSE. 
 139          *********************************************************************************/
 140          bit FLASH_MultRead_DRAM(bit tbt_Backup, U8 tc_FPage, UBYTE tc_Block1, UBYTE tc_Block0, UBYTE tc_PageNum)
 141          {
 142   1              bit     tbt_DoSendCommand=FALSE;
 143   1              union WORDDataType u_FBlock1;
 144   1              UBYTE tc_InAddr = 0, tc_FBank = 0,tc_InAddrMax;
 145   1      
 146   1              tc_InAddrMax=gc_InAddrMax;
 147   1              tc_InAddr = tgc_InAddr;//0602 Jay add
 148   1              u_FBlock1.BY[1] = tc_Block1;
 149   1              u_FBlock1.BY[0] = tc_Block0;
 150   1              Reset_DMA();    
 151   1              Device_Xfer_DataLength.WD = 0x03FF;   
 152   1              SET_DEVICE_READ_TO_DRAM();
 153   1              DEVICE_REG[0xA0] = 0x01;                                                                        // Reset ECC  
 154   1              FLASH_REG[0xA3]  = 0x01;                                                                        // Enable ECC 
 155   1              FLASH_REG[0xA0]  = 0x00;                                                                        // Disable Encode RS-Code
 156   1              FLASH_REG[0xA1]  = 0x01;                                                                        // Start Decode RS-Code
 157   1              FLASH_REG[0xA2] &= 0xF3;                                                                        // Clear ECC fail register
 158   1              FLASH_REG[0x06]  = 0x00;                                                                        // cmd1
 159   1              FLASH_REG[0x07]  = 0x30;                                                                        // cmd2 
 160   1              Banking_NAND_InAddr_To_Column_NAND(tc_InAddr);                          // set Column
 161   1              Banking_NAND_FBlock_FPage_FBank_To_PhyAddr_NAND(tc_FPage, tc_FBank, u_FBlock1.BY[1], u_FBlock1.BY[0]); //
             - set FBank Fblock Fpage       
 162   1              CHK_Flash_Ready();
 163   1              FLASH_REG[0x04] = 0x01;                                                                         // CMD0+ADDR+CMD1
 164   1              TRIGGER_FLASH_CMD();
 165   1              CHK_Flash_Ready();
 166   1              FLASH_REG[0x1A] = 0x10;
 167   1              while(tc_PageNum){
 168   2              if(tbt_DoSendCommand ){
 169   3                  FLASH_REG[0x06]  = 0x00;                                                    // cmd1
 170   3                      FLASH_REG[0x07]  = 0x30;                                                        // cmd2 
 171   3                      Banking_NAND_InAddr_To_Column_NAND(tc_InAddr);          // set Column
 172   3                      Banking_NAND_FBlock_FPage_FBank_To_PhyAddr_NAND(tc_FPage, tc_FBank, u_FBlock1.BY[1], u_FBlock1.BY
             -[0]); // set FBank Fblock Fpage
 173   3                      FLASH_REG[0x04] = 0x01;                                                         // CMD0+ADDR+CMD1
 174   3                      TRIGGER_FLASH_CMD(); 
C51 COMPILER V7.10   L51_BANKINGLOADER                                                     03/02/2011 09:21:38 PAGE 4   

 175   3                      CHK_Flash_Ready();
 176   3                      tbt_DoSendCommand= 0;
 177   3              }                 
 178   2              FLASH_REG[0xA1]  = 0x01;                                                                // Start Decode RS-Code
 179   2                  FLASH_REG[0xA2] &= 0xF3;
 180   2              FLASH_REG[0x1A] = 0x10; 
 181   2              if((tc_InAddr==(tc_InAddrMax-2))||(tc_PageNum==0x02)){
 182   3                      FLASH_REG[0x1A] = 0x11;                                                         // last frag = 1
 183   3                  }        
 184   2              Trigger_Data_Transfer();        
 185   2                      Device_Read_SRAM_Index.BY[0] += 0x04 ;                                  // 080411 Joyce add for auotcount function fail
 186   2                      Device_Read_SRAM_Index.BY[1]  = 0x00 ;                                  // 080411 Joyce add for auotcount function fail          
 187   2             
 188   2              tc_InAddr+=2;
 189   2              if(tc_InAddr==tc_InAddrMax){
 190   3                  tbt_DoSendCommand = TRUE;
 191   3                  tc_InAddr = 0x00;
 192   3                  tc_FPage++;
 193   3                  if(tc_FPage==gw_PagesPerBlock){
 194   4                      tc_FPage = 0x00;
 195   4                      tc_FBank++;
 196   4                      gc_Flash_Data++;
 197   4                      //if(tc_FBank==gc_BanksPerDevice){
 198   4                      //    tc_FBank =0x00;
 199   4                      //}
 200   4                      if(tbt_Backup){
 201   5                          u_FBlock1.WD = Bank_Block_A[gc_Flash_Data];
 202   5                      }
 203   4                      else{
 204   5                          u_FBlock1.WD = Bank_Block_B[gc_Flash_Data]; 
 205   5                      }
 206   4                  }
 207   3              }
 208   2              CHK_Data_Transfer_Done();
 209   2              if(CHK_ECC_Done()){
 210   3      //                      dbprintf("\nECC-PN:%bx %bx ",tc_PageNum,tc_FPage);
 211   3                  if(!tbt_Backup){
 212   4                     DEVICE_REG[0x00] |=0x10;                                                 // reset nand module because un-complete flash read process
 213   4                     return 1;
 214   4                  }
 215   3                  }
 216   2              CPU_REG[0x19] = Device_Read_SRAM_Index.BY[0];                   // 080411 Joyce add for auotcount function fail
 217   2                      CPU_REG[0x18] = Device_Read_SRAM_Index.BY[1];                   // 080411 Joyce add for auotcount function fail 
 218   2              tc_PageNum -=2; 
 219   2          }
 220   1          CHK_NandAutocmp_Done();
 221   1              FLASH_REG[0xA1] = 0x00;
 222   1              return 0;           
 223   1      } 
 224          
 225          /*********************************************************************************
 226          * NAME:                    Banking_NAND_InAddr_To_Column_NAND(UBYTE tc_InAddr)
 227          * DESCRIPTION:
 228          *********************************************************************************/
 229          void Banking_NAND_InAddr_To_Column_NAND(UBYTE tc_InAddr) {
 230   1              
 231   1              unionWORD tw_FColAddr;
 232   1          if((FLASH_REG[0xA5]&0x03)==0x02){ //24bit
 233   2              tw_FColAddr.WD =  (U16)(tc_InAddr>>1)*1070;//(1024+46)        
 234   2          }
 235   1          else{                             //16bit
 236   2             tw_FColAddr.WD =  (U16)(tc_InAddr>>1)*1056;//(1024+32)
C51 COMPILER V7.10   L51_BANKINGLOADER                                                     03/02/2011 09:21:38 PAGE 5   

 237   2          }   
 238   1              FLASH_REG[0x0C] = tw_FColAddr.BY[1];
 239   1              FLASH_REG[0x0B] = tw_FColAddr.BY[0]; 
 240   1              
 241   1              
 242   1              
 243   1              
 244   1              
 245   1      }
 246          
 247          /*********************************************************************************************************
             -********************
 248          * NAME: Banking_NAND_FBlock_FPage_FBank_To_PhyAddr_NAND(UBYTE tc_FPage, UBYTE tc_FBank, UBYTE tc_Block1, U
             -BYTE tc_Block0)
 249          * DESCRIPTION:
 250          **********************************************************************************************************
             -*********************/
 251          void Banking_NAND_FBlock_FPage_FBank_To_PhyAddr_NAND(UBYTE tc_FPage, UBYTE tc_FBank, UBYTE tc_Block1, UBYT
             -E tc_Block0) {
 252   1              U8 tc_FMAP;
 253   1              tc_FBank=0;
 254   1              DEVICE_REG[0x0F] =0x00;   
 255   1              if(NAND_INFO.cFMAP&0xF0){// By MCU 
 256   2              tc_FMAP = (NAND_INFO.cFMAP&0xF0)>>4;
 257   2              switch(tc_FMAP){
 258   3                      case 1:         // 256 page  block 
 259   3                              FLASH_REG[0x0A]= tc_FPage;  
 260   3                              FLASH_REG[0x09]= tc_Block1;
 261   3                              FLASH_REG[0x08]= tc_Block0;                     
 262   3                                      break;
 263   3                              default: 
 264   3                                      break;
 265   3                      }                     
 266   2          }
 267   1          else{                               // by HW        
 268   2              FLASH_REG[0x0A] = tc_FPage;                                             // FPage
 269   2                  FLASH_REG[0x09] = tc_Block1;                                      // FBlock_L 
 270   2                  FLASH_REG[0x08] = tc_Block0;                                      // FBlock_H
 271   2                      FLASH_REG[0x1C] = 0;                                             // FBank  
 272   2              }
 273   1              if(NAND_INFO.cADDR_CYCLE==0x04){        // 4 cycle addr
 274   2                      FLASH_REG[0x01] = 0x30|0x01;
 275   2              }
 276   1              else{
 277   2                      FLASH_REG[0x01] = (0x40|0x01);  // 5 cycle addr
 278   2              }         
 279   1              
 280   1      
 281   1      }
 282          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    934    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1      20
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
