C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE USB_BULK
OBJECT MODULE PLACED IN .\obj\USB_BULK.obj
COMPILER INVOKED BY: F:\Keil C 7.10\chengxu\C51\BIN\C51.EXE ..\libsource\USB\USB_BULK.c LARGE OPTIMIZE(9,SIZE) BROWSE NO
                    -AREGS INCDIR(..\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\USB_BULK.lst) OBJECT(.\obj\USB_BU
                    -LK.obj)

line level    source

   1          #include "SPDA2K.h"
   2          
   3          UBYTE gc_PseudoCard_Flag=0;
   4          
   5          void Save_CBW_Packet(void) 
   6          {
   7   1              U8      i;
   8   1              //  ¸Ñ°Ñ¼Æ      
   9   1              while (USB_REG[0xA1] & 0x02)
  10   1              {
  11   2                      USB_PlugDetect();
  12   2                      if(!gbt_USB_Detected) break;
  13   2              } 
  14   1          USB_REG[0xD2]      &= 0xDD;                         //Disable Bulk-Out¤¤Â_
  15   1          dCBW_Tag[0]=USB_BUF_Bank0[4];
  16   1          dCBW_Tag[1]=USB_BUF_Bank0[5];
  17   1          dCBW_Tag[2]=USB_BUF_Bank0[6];
  18   1          dCBW_Tag[3]=USB_BUF_Bank0[7];
  19   1              gdw_dCBW_DataXferLength.BY[0]=USB_BUF_Bank0[11];                                // MSB  gdw_dCBW_DataXferLength
  20   1              gdw_dCBW_DataXferLength.BY[1]=USB_BUF_Bank0[10];                                //      ¬O¥Î¨Óªí¥ÜCBW ªº¸ê®Æ¶Ç¿
             -éªø«×
  21   1              gdw_dCBW_DataXferLength.BY[2]=USB_BUF_Bank0[ 9];                                //
  22   1              gdw_dCBW_DataXferLength.BY[3]=USB_BUF_Bank0[ 8];                                // LSB
  23   1                                                                                              //                   '0' ==>out, H
             -ost  => Device
  24   1              gbt_bmCBWFlag=USB_BUF_Bank0[12]>>7;                                                                     // CBWªº¸ê®Æ¶Ç¿é¤è¦V '1' =>  in,Device => Hhost
  25   1              gc_bCBWCBLength=USB_BUF_Bank0[14]&0x1F;                                     // ¥»CBWªºcommand setªø«×    
             -                  
  26   1              gc_bCBWLUN = (USB_BUF_Bank0[13]&0x0F);                                      // ¨M©w¥Ø«e¬O¾Þ§@¨º¤@¥xºÏºÐ¾÷
  27   1              //¨MOS¤ä´©¦h¼Ñªº¥\¯àªº¥\¯à¶Ü  ==> yes(1)    ==> No(2)
  28   1      
  29   1              switch(gc_bCBWLUN){
  30   2                      case 0x00:
  31   2                              gc_CardType =0x01;
  32   2                      break;
  33   2      
  34   2                      case 0x01 :
  35   2                              gc_CardType = 0x02;
  36   2                              if(gc_CardDetect^(gc_CardExist&0x02))
  37   2                              {
  38   3                                      if(!(gc_Start_Stop_Flag&gc_CardType))
  39   3                                      {
  40   4                                              if(!SD_Identification_Flow())
  41   4                                              {
  42   5                                                      gc_CardDetect &= 0xFD; 
  43   5                                                  gc_CardExist &=0xFD;
  44   5                                                  gc_Start_Stop_Flag &= 0xFD;
  45   5                                                      gc_PseudoCard_Flag = 1;
  46   5                                                      break;  
  47   5                                              }
  48   4                                              else
  49   4                                              {
  50   5                                                      gbt_StorageMedia_has_changed =1;
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 2   

  51   5                                                      gc_CardChangeStage |= 0x02; // SD_Card change flag
  52   5                                                      gc_CardExist |=0x02;
  53   5                                              }
  54   4                                      }
  55   3                              }                       
  56   2                      break;
  57   2                      
  58   2                      default:
  59   2                              gc_CardType =0x01;
  60   2                      break;
  61   2              }
  62   1              // §â16bytes¤§9byte¥ý¦s°_¨Ó¡A¨Ã¸Ñcommand
  63   1      #if 0
                      COMD_IN[0] = USB_BUF_Bank0[15];
                  COMD_IN[1] = USB_BUF_Bank0[16];
                  COMD_IN[2] = USB_BUF_Bank0[17];
                  COMD_IN[3] = USB_BUF_Bank0[18];
                  COMD_IN[4] = USB_BUF_Bank0[19];
                  COMD_IN[5] = USB_BUF_Bank0[20];
                  COMD_IN[6] = USB_BUF_Bank0[21];
                  COMD_IN[7] = USB_BUF_Bank0[22];
                  COMD_IN[8] = USB_BUF_Bank0[23];   
                  COMD_IN[9] = USB_BUF_Bank0[24];       
              #else
  75   1              for(i=0;i<10;i++)
  76   1              {
  77   2                      COMD_IN[i] = USB_BUF_Bank0[i+15];
  78   2              }
  79   1      #endif
  80   1          USB_REG[0xE9] = 0x02;
  81   1      }      
  82          
  83          
  84          void Decode_CBW_Command(void) 
  85          {
  86   1              switch (COMD_IN[0]) 
  87   1              {
  88   2                      case 0x28:                                                                  //Read(10)
  89   2                              if( gc_CardExist&gc_CardType)
  90   2                              {                                       
  91   3                                      if(Check_LBA_ID())
  92   3                                      {                           
  93   4                              gc_USBStage =BulkInReadSectorsStage;      
  94   4                          gc_bCSWStatus=0x00;                       
  95   4                          gc_RequestSenseCode  = 0xFF;              
  96   4                      }                                             
  97   3                      else
  98   3                                      {
  99   4                          gc_USBStage =BulkInReadBufferStage;      
 100   4                                              if(gbt_RW_UsbBuf)
 101   4                                              {  // 090520 Jay add
 102   5                                                      gc_bCSWStatus=0x00;                       
 103   5                              gc_RequestSenseCode  = 0xFF;
 104   5                                              }
 105   4                                              else
 106   4                                              {  
 107   5                                  gc_bCSWStatus=0x01;                       
 108   5                                  gc_RequestSenseCode  = 0x07;              
 109   5                              }                  
 110   4                                      }
 111   3                              }
 112   2                              else
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 3   

 113   2                              {
 114   3                                      LBA.BY[0]=0x00;                               
 115   3                      LBA.BY[1]=0x00;                               
 116   3                      LBA.BY[2]=0x00;                               
 117   3                      LBA.BY[3]=0x00;                               
 118   3                      TotalXferPageNum.BY[0]=COMD_IN[7];            
 119   3                      TotalXferPageNum.BY[1]=COMD_IN[8];            
 120   3                      gc_USBStage =BulkInReadBufferStage;             
 121   3                      gc_bCSWStatus=0x01;                           
 122   3                      gc_RequestSenseCode  = 0x00;                  
 123   3                              }
 124   2                      break;
 125   2      
 126   2                      case 0x2A:                                                                  //write(10)
 127   2                              if(gc_CardExist&gc_CardType) 
 128   2                              {
 129   3                                      if(Check_LBA_ID())
 130   3                                      {
 131   4                                              {
 132   5                                      gc_USBStage=BulkOutWriteSectorsStage;       
 133   5                              gc_bCSWStatus=0x00;                         
 134   5                              gc_RequestSenseCode  = 0xFF;                
 135   5                              }                                               
 136   4                      }                                               
 137   3                      else
 138   3                                      {
 139   4                          gc_USBStage=BulkOutWriteBufferStage;        
 140   4                                              if(gbt_RW_UsbBuf)
 141   4                                              {  // 090520 Jay add
 142   5                                                      gc_bCSWStatus=0x00;                       
 143   5                              gc_RequestSenseCode  = 0xFF;
 144   5                                              }
 145   4                                              else
 146   4                                              {  
 147   5                                 gc_bCSWStatus=0x01;                         
 148   5                              gc_RequestSenseCode  = 0x07;              
 149   5                              }                  
 150   4                                      }
 151   3                              }
 152   2                              else
 153   2                              {
 154   3                                      LBA.BY[0]=0x00;                                 
 155   3                      LBA.BY[1]=0x00;                                 
 156   3                      LBA.BY[2]=0x00;                                 
 157   3                      LBA.BY[3]=0x00;                                 
 158   3                      TotalXferPageNum.BY[0]=COMD_IN[7];            
 159   3                      TotalXferPageNum.BY[1]=COMD_IN[8];              
 160   3                      gc_USBStage=BulkOutWriteBufferStage;            
 161   3                      gc_bCSWStatus=0x01;                             
 162   3                      gc_RequestSenseCode  = 0x00;                    
 163   3                              }
 164   2                      break;
 165   2      
 166   2                      case 0x00:                                                                              // ¡iTest Unit Ready¡j
 167   2                              if(gc_CardExist&gc_CardType)
 168   2                              {
 169   3                                      gc_bCSWStatus = 0x00;                                                           
 170   3                                      gc_RequestSenseCode = 0xFF ;                                                    
 171   3                              }
 172   2                              else
 173   2                              {
 174   3                                      gc_bCSWStatus = 0x01;                                                           
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 4   

 175   3                                      gc_RequestSenseCode = 0x00 ;                                                    
 176   3                              }                       
 177   2                              if (gbt_StorageMedia_has_changed) 
 178   2                              {                                                       
 179   3                                      if(gc_CardChangeStage&gc_CardType)
 180   3                                      {  // Media change
 181   4                                              gc_bCSWStatus = 0x01;
 182   4                                              gc_RequestSenseCode = 0x01 ; 
 183   4                                      }
 184   3                              }
 185   2                              gc_USBStage = CSWStage;                        // '7'  ª½±µ¶Ç¦^CSW Stage
 186   2                      break;
 187   2      
 188   2                      case 0x03:                                                                      //Request Sense Command
 189   2                              SetRequestSenseData();
 190   2                              gc_USBStage = BulkInResponseStage;                              //'4'
 191   2                              gc_bCSWStatus = 0x00;
 192   2                      break;
 193   2      
 194   2                      case 0x04:                                                                      // Format Unit          
 195   2                              gc_bCSWStatus = 0x00;                          //  DeviceOK(«ü card out)
 196   2                              gc_RequestSenseCode = 0xFF;                    //  normal                        
 197   2                              gc_USBStage = CSWStage;                        // '7'  ª½±µ¶Ç¦^CSW Stage
 198   2                      break;                  
 199   2      
 200   2                      case 0x12:                                                                      //INQUIRY Command
 201   2                              SetResponseINQUIRYData();                       // §â­n¦^µ¹Hostªº¸ê®Æ³]¦n¡A¦¹«á´Nµ¥host¦V§Ú­n¸ê®Æ
 202   2                              gc_USBStage = BulkInResponseStage;              // '4'
 203   2                              gdw_dCBW_DataXferLength.WD[1] = 36;
 204   2                              gc_bCSWStatus = 0x00;                            // Command Passed ¨£BulkOnly P.15»¡©ú¦UºØ½Xªº±¡§Î
 205   2                      break;
 206   2      
 207   2                      case 0x5A:
 208   2                      case 0x1A:                                                                          //Mode sense(6)  Type:Option                        
 209   2                              if (COMD_IN[2] != 0x3F) 
 210   2                              {
 211   3                                      gbt_StallWhichEndPoint = StallEndPoint1;        // for bulk in stall
 212   3                                      gc_USBStage = BulkStallStage;                  // '7'
 213   3                                      gc_bCSWStatus = 0x01;                          // Command Failed ¨£BulkOnly P.15»¡©ú¦UºØ½Xªº±¡§Î
 214   3                                      gc_RequestSenseCode = 0x03;                    // ¦¹°Ñ¼ÆOPcode¤£¤ä´©
 215   3                              }
 216   2                              else 
 217   2                              {
 218   3                                      if (COMD_IN[0] == 0x1A) 
 219   3                                      {                               //mode sense(6)ªºHeader¥u­n4 Byte
 220   4                                              USB_BUF_Bank0[0] = 0x03;
 221   4                                              USB_BUF_Bank0[1] = 0x00;
 222   4                                              USB_BUF_Bank0[2] = 0x00;
 223   4                                              switch(gc_CardType)
 224   4                                              {
 225   5                                                      case 0x01:// Flash
 226   5                                                              if (gc_WriteProof) 
 227   5                                                              {
 228   6                                                                      USB_BUF_Bank0[2] = 0x80;
 229   6                                                              }
 230   5                                                      break;                                                  
 231   5      
 232   5                                                      case 0x02:// SD/MMC
 233   5                                                      break;
 234   5                                              }                               
 235   4                                              USB_BUF_Bank0[3] = 0x00;
 236   4                                      }       
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 5   

 237   3                                      else 
 238   3                                      {       //mode sense(10)ªºHeader­n8­ÓByte
 239   4                                              USB_BUF_Bank0[0] = 0x00;
 240   4                                              USB_BUF_Bank0[1] = 0x07;
 241   4                                              USB_BUF_Bank0[2] = 0x00;
 242   4                                              USB_BUF_Bank0[3] = 0x00;
 243   4                                              switch(gc_CardType)
 244   4                                              {
 245   5                                                      case 0x01:// Flash
 246   5                                                              if (gc_WriteProof) 
 247   5                                                              {
 248   6                                                                      USB_BUF_Bank0[3] = 0x80; 
 249   6                                                              }
 250   5                                                      break;                                                  
 251   5      
 252   5                                                      case 0x02:// SD/MMC
 253   5                                                      break;
 254   5                                              }                               
 255   4                                      }                                                                                                     
             - 
 256   3                                      USB_BUF_Bank0[4] = 0x00;          
 257   3                                      USB_BUF_Bank0[5] = 0x00;          
 258   3                                      USB_BUF_Bank0[6] = 0x00;          
 259   3                                      USB_BUF_Bank0[7] = 0x00;          
 260   3                                      gc_USBStage = BulkInResponseStage;
 261   3                                      gbt_XferNormalResponseData_or_ModeSense = ModeSenseResponseData;
 262   3                                      gc_bCSWStatus = 0x00;
 263   3                              }
 264   2                      break;
 265   2                      
 266   2                      case 0x1E:                                          // ¡iPrevent allow medium removal¡j
 267   2                              if (COMD_IN[4] & 0x01) 
 268   2                              {
 269   3                                      gc_bCSWStatus = 0x01;                          //  ­Y³]©w¬°0x01¡A«hwindows·|°h¥X¿ù»~ªº°T¸¹(¦ý³o¬O¥¿±`ª
             -º)
 270   3                                      gc_RequestSenseCode = 0x03;
 271   3                              }
 272   2                              else 
 273   2                              {
 274   3                                      gc_bCSWStatus = 0x00;
 275   3                              }
 276   2                              gc_USBStage = CSWStage;                                 // '7'  ª½±µ¶Ç¦^CSW Stage
 277   2                      break;
 278   2                      
 279   2                      case 0x1B:                                              // ¡iStart Stop UNIT¡j
 280   2                          gc_USBStage=CSWStage;                                       // '7'  ª½±µ¶Ç¦^CSW Stage 
 281   2                          gc_bCSWStatus=0x00;                                         //  ­Y³]©w¬°0x01¡A«hwindows·|reject errorªº°T¸¹(¦ý³o¬O¥¿±
             -`ªº)
 282   2                          if(COMD_IN[4]&0x01)
 283   2                              {                                               //Start Unit    
 284   3                              gc_CardExist |= gc_CardType;
 285   3                              gc_Start_Stop_Flag &=~gc_CardType;
 286   3                           }                                          
 287   2                              else
 288   2                              {
 289   3                              gc_CardExist &= ~gc_CardType;
 290   3                              gc_Start_Stop_Flag |=gc_CardType;
 291   3                           }
 292   2                            break;
 293   2                      
 294   2                      case 0x23: 
 295   2                              if(gc_CardExist&gc_CardType)
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 6   

 296   2                              {                                       
 297   3                                      SetReadFormatCapacity();
 298   3                                      gc_USBStage = BulkInResponseStage;                              // '4'                 
 299   3                      gc_bCSWStatus = 0x00;                                       //DeviceOK(«ü card out)
 300   3                                      gc_RequestSenseCode = 0xFF;                                     //normal
 301   3                  }
 302   2                  else
 303   2                              {
 304   3                      gbt_StallWhichEndPoint = StallEndPoint1;        // for bulk in stall
 305   3                                      gc_USBStage = BulkStallStage;                   // '7'
 306   3                                      gc_bCSWStatus = 0x01;                                       //Command Passed ¨£BulkOnly P.15»¡©ú¦UºØ½Xªº±¡§Î
 307   3                                  gc_RequestSenseCode = 0x00;                                 //¥d¤ù¤£¦s¦b     
 308   3                  }
 309   2                  if(gbt_StorageMedia_has_changed) 
 310   2                              {
 311   3                                      if(gc_CardChangeStage&gc_CardType)
 312   3                                      {  // Media change
 313   4                                              gc_bCSWStatus = 0x01;     
 314   4                                              gc_RequestSenseCode = 0x01 ; 
 315   4                                      }                               
 316   3                              }
 317   2                              break;
 318   2      
 319   2                      case 0x25:
 320   2                              if(gc_CardExist&gc_CardType)
 321   2                              {
 322   3                                      SetReadCapacityData();                                  
 323   3                                      gc_USBStage = BulkInResponseStage;                              // '4'                 
 324   3                      gc_bCSWStatus = 0x00;                                  
 325   3                                      gc_RequestSenseCode = 0xFF;                                     //normal
 326   3                  }
 327   2                  else
 328   2                              {
 329   3                      gbt_StallWhichEndPoint = StallEndPoint1;        // for bulk in stall
 330   3                                      gc_USBStage = BulkStallStage;                   // '7'
 331   3                                      gc_bCSWStatus = 0x01;                                       //Command Passed ¨£BulkOnly P.15»¡©ú¦UºØ½Xªº±¡§Î
 332   3                                  gc_RequestSenseCode = 0x00;                                 //¥d¤ù¤£¦s¦b     
 333   3                  }
 334   2                  if (gbt_StorageMedia_has_changed) 
 335   2                              {                                                       
 336   3                                      if(gc_CardChangeStage&gc_CardType)
 337   3                                      {  // Media change
 338   4                                              gc_bCSWStatus = 0x01;     
 339   4                                              gc_RequestSenseCode = 0x01 ; 
 340   4                                      }                               
 341   3                              }           
 342   2                      break;
 343   2      
 344   2              case 0x2F:
 345   2                  gc_USBStage=CSWStage;
 346   2                  gc_bCSWStatus=0x00;                     // Command Passed ¨£BulkOnly P.15»¡©ú¦UºØ½Xªº±¡§Î
 347   2                  gc_RequestSenseCode = 0xFF;             // normal
 348   2                  break;
 349   2      
 350   2              case 0x2E:
 351   2                  TotalXferPageNum.BY[0]=COMD_IN[7];            
 352   2                  TotalXferPageNum.BY[1]=COMD_IN[8];             
 353   2                  gc_USBStage = BulkOutWriteBufferStage;
 354   2                  gc_bCSWStatus=0x00;                     
 355   2                  gc_RequestSenseCode = 0xFF;                                        
 356   2                  break;
 357   2      
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 7   

 358   2              case 0x35:
 359   2                  gc_USBStage=CSWStage;                   // '7'  ª½±µ¶Ç¦^CSW Stage 
 360   2                  gc_bCSWStatus=0x01;                     //  ­Y³]©w¬°0x01
 361   2                  gc_RequestSenseCode = 0x02;             // ¤£©ú­ì¦]¿ù»~¡A³]OPcode¤£¤ä´©             
 362   2                  break;
 363   2      
 364   2              case 0x3C:
 365   2                      TotalXferPageNum.BY[0]=COMD_IN[7];            
 366   2                  TotalXferPageNum.BY[1]=COMD_IN[8];            
 367   2                  gc_USBStage = BulkInReadBufferStage ;
 368   2                  gc_bCSWStatus=0x00;                           
 369   2                  gc_RequestSenseCode  = 0xFF;              
 370   2                  break;
 371   2      
 372   2                      case 0xFE:{     // µ¡¤f¨ç¦¡
 373   3                                      if (COMD_IN[1] != 0xFE) {
 374   4                                      gc_USBStage = BulkStallStage;               // '7'
 375   4                                      gc_bCSWStatus = 0x01;                       // Command Failed ¨£BulkOnly P.15»¡©ú¦UºØ½Xªº±¡§Î
 376   4                                      gc_RequestSenseCode = 0x02;                 // ¤£©ú­ì¦]¿ù»~¡A³]OPcode¤£¤ä´©                    
             -           
 377   4                                      }
 378   3                                      else {
 379   4                                      SelfTestCmd();           
 380   4                                      gc_USBStage = CSWStage;                     // ¸ê®Æ³£¶Ç§¹¤F,¶i¤J¤U¤@stage==>Comand Status Wrapp
             -er
 381   4                                      }
 382   3                                      break;
 383   3                      }
 384   2                      case 0x55:{
 385   3                              gc_USBStage=CSWStage;                          // ¸ê®Æ³£¶Ç§¹¤F,¶i¤J¤U¤@stage==>Comand Status Wrap
             -per
 386   3                              gc_bCSWStatus=0x00;                            //  DeviceOK(«ü card out)
 387   3                      gc_RequestSenseCode = 0xFF ;                   //  normal
 388   3                              break;
 389   3              }
 390   2                      case 0x43:{  //CD ROM                                                                                   //Read TOC/PMA-ATIP
 391   3                              if(COMD_IN[1]==0x02){
 392   4                                      SetTOC_PMA_ATIP_Data(36);                                       // §â­n¦^µ¹Hostªº¸ê®Æ³]¦n¡A¦¹«á´Nµ¥host¦V§Ú­n¸ê®Æ
 393   4                                      gdw_dCBW_DataXferLength.WD[1] = 36;
 394   4                              }
 395   3                              else{
 396   4                                      SetTOC_PMA_ATIP_Data(12);
 397   4                                      gdw_dCBW_DataXferLength.WD[1] = 12;
 398   4                              }
 399   3                              gc_USBStage = BulkInResponseStage;                              //'4'
 400   3                              gc_bCSWStatus = 0x00;
 401   3                              break;
 402   3                      }       
 403   2              default:{
 404   3                     if (gbt_bmCBWFlag) {
 405   4                              gbt_StallWhichEndPoint = StallEndPoint1;    // for bulk in stall
 406   4                     }
 407   3                     else{
 408   4                              gbt_StallWhichEndPoint = StallEndPoint2;    // for bulk in stall
 409   4                     }
 410   3                     gc_USBStage = BulkStallStage;                   // '7'
 411   3                     gc_bCSWStatus = 0x01;                           // Command Failed ¨£BulkOnly P.15»¡©ú¦UºØ½X
             -ªº±¡§Î
 412   3                     gc_RequestSenseCode = 0x02;                     // ¤£©ú­ì¦]¿ù»~¡A³]OPcode¤£¤ä´©
 413   3                     break;
 414   3              }
 415   2              }
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 8   

 416   1      }
 417          
 418          
 419          void SetResponseINQUIRYData(void) 
 420          { 
 421   1              U8      i;
 422   1      
 423   1              switch(gc_CardType)
 424   1              {  // gc_CardType  bit 0 : flash  bit 1: SD/MMC
 425   2                      case 0x02 :
 426   2                              for(i=0;i<36;i++)
 427   2                              {       // ¼Ð·ÇInQuiryªø«×¬° 36 bytes
 428   3                                      USB_BUF_Bank0[i]=Standard_INQUIRY_Format_SDMMC[i];   // COM_IN[4]=0x24=36
 429   3                      }       
 430   2                      break;
 431   2      
 432   2                      default:
 433   2                      for(i=0;i<36;i++)
 434   2                              {       // ¼Ð·ÇInQuiryªø«×¬° 36 bytes
 435   3                                      if((gbt_enableCDROM==1)&&(gc_bCBWLUN==2))
 436   3                                      {
 437   4                                              USB_BUF_Bank0[i]=CDROM_User_INQUIRY_Format[i];   // COM_IN[4]=0x24=36
 438   4                                      }
 439   3                                      else
 440   3                                      {
 441   4                                      USB_BUF_Bank0[i]=Standard_INQUIRY_Format[i];   // COM_IN[4]=0x24=36
 442   4                              }                               
 443   3                      }                               
 444   2              break;
 445   2           }          
 446   1      }
 447          
 448          /***************************************************************************
 449          * NAME:         void SetRequestSenseData(void)
 450          * DESCRIPTION:
 451          *               SCSI command OPcode0x03
 452          *      //      0     1     2     3     4     5     6     7     8     9  
 453          *      //   0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 
 454          *      //     10    11    12    13    14    15    16    17
 455          *      //   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,   //byte7=0x0C==>¦p¶ñ¬°0x00 USB HOST·|¤£¥¿±`
 456          ***************************************************************************/
 457          void SetRequestSenseData(void) {
 458   1      
 459   1              U8      i;
 460   1      
 461   1              for(i=1;i<18;i++)
 462   1              {
 463   2                      USB_BUF_Bank0[i]=0x00;
 464   2              }
 465   1              USB_BUF_Bank0[0]=0x70;
 466   1              USB_BUF_Bank0[7]=0x0A;
 467   1      
 468   1              switch(gc_RequestSenseCode) 
 469   1              {
 470   2                      case 0x00:      // 02 3A 00 - Medium not present
 471   2                              USB_BUF_Bank0[ 2]=0x02;
 472   2                              USB_BUF_Bank0[12]=0x3A;
 473   2                      break;
 474   2      
 475   2                      case 0x01:      // 06 28 00 - Media changed
 476   2                              USB_BUF_Bank0[ 2]=0x06;
 477   2                              USB_BUF_Bank0[12]=0x28;
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 9   

 478   2                              gbt_StorageMedia_has_changed=0;
 479   2                              gc_CardChangeStage&=~gc_CardType;
 480   2                      break;
 481   2      
 482   2                      case 0x02:      // 05 20 00 - Invalid command operaion code
 483   2                              USB_BUF_Bank0[ 2]=0x05;
 484   2                              USB_BUF_Bank0[12]=0x20;
 485   2                      break;
 486   2      
 487   2                      case 0x03:      // 05 24 00 - Invalid field in command packet
 488   2                              USB_BUF_Bank0[ 2]=0x05;
 489   2                              USB_BUF_Bank0[12]=0x24;
 490   2                      break;
 491   2      
 492   2                      case 0x05:      // 07 27 00 - Write protected media
 493   2                              USB_BUF_Bank0[ 2]=0x07;
 494   2                              USB_BUF_Bank0[12]=0x27;
 495   2                      break;
 496   2      
 497   2                      case 0x06:      // 03 11 00 - Unrecovered read error
 498   2                              USB_BUF_Bank0[ 2]=0x03;
 499   2                              USB_BUF_Bank0[12]=0x11;
 500   2                      break;
 501   2      
 502   2                      case 0x07:      // 05 21 00 - Logical block address out of range
 503   2                              USB_BUF_Bank0[ 2]=0x05;
 504   2                              USB_BUF_Bank0[12]=0x21;
 505   2                      break;
 506   2      
 507   2                      case 0x08:      // 03 03 00 - Write fault
 508   2                              USB_BUF_Bank0[ 2]=0x03;
 509   2                              USB_BUF_Bank0[12]=0x03;
 510   2                      break;
 511   2      
 512   2                      case 0x88:
 513   2                              USB_BUF_Bank0[ 2] = 0x00;                               //Medium Error                   
 514   2                              USB_BUF_Bank0[12] = gc_ST_ErrorCode;            //Vender  CMD Status              
 515   2                      break;                   
 516   2              }       
 517   1              gc_RequestSenseCode=0xFF;
 518   1      }
 519          
 520          /*********************************************************************************
 521          * NAME:         void SetReadFormatCapacity(void)
 522          * DESCRIPTION:
 523          *********************************************************************************/
 524          void SetReadFormatCapacity(void) {      
 525   1              SetPartitionCapacity();
 526   1      
 527   1              USB_BUF_Bank0[ 0] = 0x00;
 528   1              USB_BUF_Bank0[ 1] = 0x00;
 529   1              USB_BUF_Bank0[ 2] = 0x00;
 530   1              USB_BUF_Bank0[ 3] = 0x08;
 531   1              USB_BUF_Bank0[ 8] = 0x02;                                               //Format Media
 532   1              USB_BUF_Bank0[ 9] = 0x00;
 533   1              USB_BUF_Bank0[10] = 0x02;                                               //0x00000200 ==> 512 bytes
 534   1              USB_BUF_Bank0[11] = 0x00;
 535   1              switch(gc_CardType)
 536   1              {
 537   2                      case 0x02:                      
 538   2                              USB_BUF_Bank0[ 4] = SD_Capacity.BY[0];                                  //MSB
 539   2                              USB_BUF_Bank0[ 5] = SD_Capacity.BY[1];                                  //
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 10  

 540   2                              USB_BUF_Bank0[ 6] = SD_Capacity.BY[2];                                  //
 541   2                              USB_BUF_Bank0[ 7] = SD_Capacity.BY[3];                                  //LSB ´î¤@¡A¦]¬°±q¤@ºâ°_
 542   2                              break;
 543   2      
 544   2                      default :
 545   2                              if(gbt_Support_Dummy_Capacity)
 546   2                              {  // 090416 add for dummy capacity
 547   3                                      if(gbt_enableCDROM && (gc_bCBWLUN==2))
 548   3                                      {//09/04/24,joyce for CD-ROM
 549   4                                      USB_BUF_Bank0[ 4] = Capacity.BY[0];                             //MSB
 550   4                                          USB_BUF_Bank0[ 5] = Capacity.BY[1];                         //
 551   4                                          USB_BUF_Bank0[ 6] = Capacity.BY[2];                         //
 552   4                                          USB_BUF_Bank0[ 7] = Capacity.BY[3];                         //LSB ´î¤@¡A¦]¬°±q¤@ºâ°_
 553   4                                      }
 554   3                                      else
 555   3                                      {
 556   4                                      USB_BUF_Bank0[ 4] = Dummy_Capacity.BY[0];                               //MSB
 557   4                                          USB_BUF_Bank0[ 5] = Dummy_Capacity.BY[1];                           //
 558   4                                          USB_BUF_Bank0[ 6] = Dummy_Capacity.BY[2];                           //
 559   4                                          USB_BUF_Bank0[ 7] = Dummy_Capacity.BY[3];                           //LSB ´î¤@¡A¦]¬°±q¤@ºâ°_
 560   4                                      }                                               
 561   3                              }
 562   2                          else
 563   2                              {
 564   3                                      USB_BUF_Bank0[ 4] = Capacity.BY[0];                                     //MSB
 565   3                                      USB_BUF_Bank0[ 5] = Capacity.BY[1];                                     //
 566   3                                      USB_BUF_Bank0[ 6] = Capacity.BY[2];                                     //
 567   3                                      USB_BUF_Bank0[ 7] = Capacity.BY[3];                                     //LSB ´î¤@¡A¦]¬°±q¤@ºâ°_
 568   3                              }                                                                               
 569   2                              break;
 570   2              }
 571   1      }                                                                               
 572                                                                                          
 573          /***************************************************************************
 574          * NAME:         void SetPartitionCapacity(void)
 575          * DESCRIPTION:
 576          *                ¦@ 8 bytes
 577          ***************************************************************************/
 578          void SetPartitionCapacity(void)
 579          {                
 580   1              // ¥Ñ¦¹¨M©w¤Á³Î¦¨´X­Ópartitioncapacity  
 581   1              // §_«h±N·í¦¨¤@¾ã­ÓFlash ¬°¤@­Ó disk 
 582   1              if(gbt_enableCDROM && (gc_bCBWLUN==2))//09/04/24,joyce
 583   1              {
 584   2                      Capacity.LW=Capacity_CDROM.LW;
 585   2              }
 586   1              else
 587   1              {
 588   2                      Capacity.LW=Capacity_Remove.LW;
 589   2              }
 590   1      }
 591          
 592          /***************************************************************************
 593          * NAME:         void SetReadCapacityData(void)
 594          * DESCRIPTION:
 595          *                ¦@ 8 bytes
 596          ***************************************************************************/
 597          void SetReadCapacityData(void) 
 598          {
 599   1              SetPartitionCapacity();                                                 //­pºâ©Ò±oªºpartitionsize·|©ñ¦bLBA.LW¤¤
 600   1              USB_BUF_Bank0[ 4] = 0x00;
 601   1              USB_BUF_Bank0[ 5] = 0x00;
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 11  

 602   1              USB_BUF_Bank0[ 6] = 0x02;
 603   1              USB_BUF_Bank0[ 7] = 0x00;
 604   1      
 605   1              switch(gc_CardType)
 606   1              {
 607   2                      case 0x02:              
 608   2                              SD_Capacity.LW--;
 609   2                              USB_BUF_Bank0[ 0] = SD_Capacity.BY[0];                                  //MSB
 610   2                              USB_BUF_Bank0[ 1] = SD_Capacity.BY[1];                                  //
 611   2                              USB_BUF_Bank0[ 2] = SD_Capacity.BY[2];                                  //
 612   2                              USB_BUF_Bank0[ 3] = SD_Capacity.BY[3];                                  //LSB ´î¤@¡A¦]¬°±q¤@ºâ°_                        
 613   2                              SD_Capacity.LW ++;
 614   2                              break;
 615   2                      default :                                                                                       
 616   2                          if(gbt_Support_Dummy_Capacity)
 617   2                              {   // 090416 add for dummy capacity
 618   3                                      if(gbt_enableCDROM && (gc_bCBWLUN==2))
 619   3                                      {//09/04/24,joyce for CD-ROM
 620   4                                          Capacity.LW--;
 621   4                                      USB_BUF_Bank0[ 0] = Capacity.BY[0];                             //MSB
 622   4                                          USB_BUF_Bank0[ 1] = Capacity.BY[1];                         //
 623   4                                          USB_BUF_Bank0[ 2] = Capacity.BY[2];                         //
 624   4                                          USB_BUF_Bank0[ 3] = Capacity.BY[3];                         //LSB ´î¤@¡A¦]¬°±q¤@ºâ°_
 625   4                                          Capacity.LW++;
 626   4                                      }
 627   3                                      else{
 628   4                                      Dummy_Capacity.LW--;
 629   4                                      USB_BUF_Bank0[ 0] = Dummy_Capacity.BY[0];                               //MSB
 630   4                                          USB_BUF_Bank0[ 1] = Dummy_Capacity.BY[1];                           //
 631   4                                          USB_BUF_Bank0[ 2] = Dummy_Capacity.BY[2];                           //
 632   4                                          USB_BUF_Bank0[ 3] = Dummy_Capacity.BY[3];                           //LSB ´î¤@¡A¦]¬°±q¤@ºâ°_                                                                                        
 633   4                                          Dummy_Capacity.LW++;
 634   4                                      }
 635   3                          }
 636   2                          else
 637   2                              {                                                                                       
 638   3                                      Capacity.LW--;
 639   3                                      USB_BUF_Bank0[ 0] = Capacity.BY[0];                                     //MSB
 640   3                                      USB_BUF_Bank0[ 1] = Capacity.BY[1];                                     //
 641   3                                      USB_BUF_Bank0[ 2] = Capacity.BY[2];                                     //
 642   3                                      USB_BUF_Bank0[ 3] = Capacity.BY[3];                                     //LSB ´î¤@¡A¦]¬°±q¤@ºâ°_                                                                                        
 643   3                                      Capacity.LW++;
 644   3                              }
 645   2                              break;
 646   2              }       
 647   1      }
 648          
 649          
 650          void SetTOC_PMA_ATIP_Data(U8 tc_data) 
 651          {              
 652   1              U8      i;
 653   1      
 654   1              for(i=0;i<tc_data;i++)
 655   1              {
 656   2                      USB_BUF_Bank0[i]=TOC_PMA_ATIP_Format[i];
 657   2              }
 658   1      }
 659          
 660          
 661          bit Check_LBA_ID(void) 
 662          {
 663   1              gbt_RW_UsbBuf =0;  // 090520 Jay add
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 12  

 664   1              if ((COMD_IN[0] == 0x28) || (COMD_IN[0] == 0x2A)) 
 665   1              {
 666   2                      LBA.BY[0] = COMD_IN[2];
 667   2                      LBA.BY[1] = COMD_IN[3];
 668   2                      LBA.BY[2] = COMD_IN[4];
 669   2                      LBA.BY[3] = COMD_IN[5];      
 670   2                      TotalXferPageNum.BY[0] = COMD_IN[7];
 671   2                      TotalXferPageNum.BY[1] = COMD_IN[8];
 672   2              }
 673   1              else 
 674   1              {
 675   2                      LBA.BY[0] = 0x00;
 676   2                      LBA.BY[1] = COMD_IN[1]& 0x0F;
 677   2                      LBA.BY[2] = COMD_IN[2];
 678   2                      LBA.BY[3] = COMD_IN[3];      
 679   2                      TotalXferPageNum.BY[0] = 0x00;    
 680   2                      TotalXferPageNum.BY[1] = COMD_IN[4];
 681   2              }
 682   1      
 683   1              switch(gc_CardType)
 684   1              {
 685   2                      case 2:
 686   2                              if(LBA.LW>= SD_Capacity.LW )
 687   2                              {
 688   3                                      LBA.LW = SD_Capacity.LW ;
 689   3                                      gc_ErrorCode = ID_NOT_FND;
 690   3                                      return 0;               
 691   3                              }
 692   2                              else
 693   2                              {
 694   3                                      return 1;
 695   3                              }
 696   2                      break;
 697   2                      default:
 698   2                          if(gbt_Support_Dummy_Capacity)
 699   2                              {
 700   3                              if(LBA.LW>= Dummy_Capacity.LW)
 701   3                                      {
 702   4                                          LBA.LW = Dummy_Capacity.LW;
 703   4                                          gc_ErrorCode = ID_NOT_FND;
 704   4                                          return 0;           
 705   4                                  }   
 706   3                                      else if(LBA.LW>=Capacity.LW)
 707   3                                      {
 708   4                                              gbt_RW_UsbBuf=1; //090520 Jay add
 709   4                                              return 0;
 710   4                                      }
 711   3                                  else
 712   3                                      {
 713   4                                          return 1;
 714   4                                  }                   
 715   3                          }
 716   2                          else
 717   2                              {
 718   3                                      if(LBA.LW>= Capacity.LW){
 719   4                                              LBA.LW = Capacity.LW;
 720   4                                              gc_ErrorCode = ID_NOT_FND;
 721   4                                              return 0;               
 722   4                                      }       
 723   3                                      else{
 724   4                                              return 1;
 725   4                                      }
C51 COMPILER V7.10   USB_BULK                                                              02/28/2011 10:30:02 PAGE 13  

 726   3                              }
 727   2                              break;
 728   2              }
 729   1      }
 730          
 731          
 732          void StallBulkRW(void) 
 733          {
 734   1              if (gbt_StallWhichEndPoint == StallEndPoint1) {  // for bulk in stall
 735   2                           // ÀË¬d¬O§_EndPoint1 ªºStall¬O§_¤w¸g²M°£¤F
 736   2                              // ¦¹®É Device ·|¦¬¨ì HOST µoªº clear feature ¤¤Â_¡C
 737   2                      USB_REG[0xEB] = 0x01;
 738   2                      while (USB_REG[0xEE] == 0)
 739   2                      {
 740   3                              USB_PlugDetect();
 741   3                              if(!gbt_USB_Detected) break;
 742   3                      }
 743   2                      USB_REG[0xE8] = 0x04;//in stall
 744   2              }
 745   1              if (gbt_StallWhichEndPoint == StallEndPoint2) {  // for bulk out stall
 746   2                      // ÀË¬d¬O§_EndPoint1 ªºStall¬O§_¤w¸g²M°£¤F
 747   2                      // fw ¦A°õ¦æ¤¤Â_µ{¦¡
 748   2                      USB_REG[0xEB] = 0x02;
 749   2                      while (USB_REG[0xEE] == 0)
 750   2                      {
 751   3                              USB_PlugDetect();
 752   3                              if(!gbt_USB_Detected) break;
 753   3                      }
 754   2                      USB_REG[0xE8] = 0x08;//out stall
 755   2              }
 756   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1847    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      1    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
