C51 COMPILER V7.10   INDEP_LCM_FUNC                                                        02/28/2011 10:30:53 PAGE 1   


C51 COMPILER V7.10, COMPILATION OF MODULE INDEP_LCM_FUNC
OBJECT MODULE PLACED IN .\obj\Indep_LCM_Func.obj
COMPILER INVOKED BY: F:\Keil C 7.10\chengxu\C51\BIN\C51.EXE LCM\Indep_LCM_Func.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS I
                    -NCDIR(..\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\Indep_LCM_Func.lst) OBJECT(.\obj\Indep_L
                    -CM_Func.obj)

line level    source

   1          #include "spda2k.h"
   2          #include "..\LCM\model_define.h"
   3          #include "..\LCM\LCM.h"
   4          #include "..\LCM\LCM_func.h"
   5          #include "..\header\variables.h"
   6          //extern xdata U16 gw_icon_sector;
   7          
   8          void USER_ReadReserveBlock(U16 tw_ReserveBLKSector)
   9          {
  10   1              DSPHZK_Block_Read(1,tw_ReserveBLKSector,1,gc_PlayRecordDataBufHB);
  11   1      }
  12          
  13          void User_ReadReserveBlockData_To_TFT(U32 tdw_StartByteAddr,U32 tdw_ByteNum)
  14          {
  15   1              xdata   U8      *mbDmaAddr;
  16   1              data    U8      tw_SectorNum; 
  17   1              data    U8      tw_Loop;
  18   1              data    U16     tw_LoopNum;
  19   1              data    U16 DmaDst;
  20   1              data    U16     tw_StartLogicSectorAddr;
  21   1              data    U16     tw_ByteStartOffset;
  22   1              data    U16     tw_ByteEndOffset;
  23   1      
  24   1              //-----------------------------------------------------------------------------
  25   1              tw_StartLogicSectorAddr = tdw_StartByteAddr>>9;  //将起始字节地址转换为起始sector地址
  26   1              tw_ByteStartOffset = tdw_StartByteAddr & 0x1ff;//start sector offset
  27   1              tw_ByteEndOffset = (tdw_StartByteAddr + tdw_ByteNum) & 0x1ff; //end sector offset
  28   1              tw_SectorNum=tdw_ByteNum>>9;                     //计算共有多少个sector
  29   1      
  30   1              if((tdw_ByteNum & 0x1ff) == 0)
  31   1              {
  32   2                      if(tw_ByteStartOffset!=0)
  33   2                      {
  34   3                              tw_SectorNum++;
  35   3                      }
  36   2              }
  37   1              else
  38   1              {
  39   2                      tw_SectorNum++;
  40   2                      if((tw_ByteStartOffset + (tdw_ByteNum & 0x1ff)) > 512 )           
  41   2                      {
  42   3                              tw_SectorNum++;
  43   3                      }
  44   2              }
  45   1      
  46   1              //------------------------------find kernel phyaddress-----------------------------------------
  47   1              EA = 0;
  48   1      
  49   1              for(tw_Loop=0;tw_Loop<tw_SectorNum;tw_Loop++)
  50   1              {       
  51   2                      //--------------------------------Flash to SRAM------------------------------------
  52   2                      USER_ReadReserveBlock(tw_StartLogicSectorAddr+tw_Loop);
  53   2      
C51 COMPILER V7.10   INDEP_LCM_FUNC                                                        02/28/2011 10:30:53 PAGE 2   

  54   2                      //for 023Only
  55   2                      LCD_Nand2DataMode();
  56   2      
  57   2              XBYTE[0xB304]=0x09; //reset DMA machine and setting pad 0 enable 
  58   2              XBYTE[0xB304]=0x08; 
  59   2                      //-------------------------------SRAM to Flash------------------------------------
  60   2                      if(tw_Loop == 0)
  61   2                      {
  62   3                              if((tdw_ByteNum<512)&&(tw_SectorNum==1))   
  63   3                              {
  64   4                                      tw_LoopNum = tdw_ByteNum;
  65   4                              }
  66   3                              else
  67   3                              {                                         
  68   4                                      tw_LoopNum = 512-tw_ByteStartOffset;
  69   4                              }
  70   3                              mbDmaAddr = &gc_PlayRecordDataBuf[tw_ByteStartOffset];
  71   3                      }
  72   2                      else if(tw_Loop < tw_SectorNum-1)
  73   2                      {
  74   3                              tw_LoopNum = 512;                               
  75   3                              mbDmaAddr = &gc_PlayRecordDataBuf[0];
  76   3                      }
  77   2                      else
  78   2                      {
  79   3                              if(tw_ByteEndOffset == 0)   
  80   3                              {
  81   4                                      tw_LoopNum = 512;       
  82   4                              }
  83   3                              else
  84   3                              {
  85   4                                      tw_LoopNum = tw_ByteEndOffset;
  86   4                              }
  87   3                              mbDmaAddr = &gc_PlayRecordDataBuf[0];                   
  88   3                      }
  89   2              
  90   2                      DmaDst = (U16)mbDmaAddr;
  91   2                      tw_LoopNum = tw_LoopNum-1;    //DMA transfer size 
  92   2      
  93   2                      //source
  94   2                      XBYTE[0xB112] = (*((U8*)&DmaDst+1));
  95   2                      XBYTE[0xB113] = (*((U8*)&DmaDst));                                      
  96   2      
  97   2                      XBYTE[0xB302]=((U8 *)(&tw_LoopNum))[1];
  98   2                      XBYTE[0xB303]=((U8 *)(&tw_LoopNum))[0];                         
  99   2      
 100   2                      XBYTE[0xB3C0] = 0x00;//clear DMA completed flag
 101   2                      LCM_A0_HI;
 102   2                      LCM_CS_LO;
 103   2      
 104   2                      XBYTE[0xB3B0]=0x01;     //trigger DMA
 105   2                      while(XBYTE[0xB3C0]==0);
 106   2                      XBYTE[0xB3C0]=0;
 107   2      
 108   2                      LCD_Data2NandMode();
 109   2              }       
 110   1              XBYTE[0xB113]=0xFF;             //unlock SRAM for DMA(src)  2006-04-19
 111   1              XBYTE[0xB112]=0xFF;     
 112   1          XBYTE[0xB304]=0x09;         //reset DMA machine and setting pad 0 enable 
 113   1          XBYTE[0xB304]=0x08; 
 114   1              EA = 1;
 115   1      }
C51 COMPILER V7.10   INDEP_LCM_FUNC                                                        02/28/2011 10:30:53 PAGE 3   

 116          
 117          void LCD_DisplayIcon(U8 tc_IconIDNumber,U8 tc_CurrentOffset)
 118          {
 119   1              U8  tc_Sector;
 120   1              U16 tw_ByteOffset;
 121   1              U32 tdw_StartByteAddr;
 122   1              U32 tdw_ByteNum;
 123   1      
 124   1              tc_IconIDNumber += 1; //前面8个 Byte用来记录ID总数和Chuck sum,应跳过   
 125   1              tc_Sector = tc_IconIDNumber>>6;
 126   1              tw_ByteOffset = ((U16)tc_IconIDNumber << 3) & 0x1ff;
 127   1              EA = 0;
 128   1              USER_ReadReserveBlock(gw_icon_sector + tc_Sector);
 129   1              EA = 1;
 130   1      
 131   1              ((U8 *)&tdw_StartByteAddr)[0]=gc_PlayRecordDataBuf[tw_ByteOffset+0]; 
 132   1              ((U8 *)&tdw_StartByteAddr)[1]=gc_PlayRecordDataBuf[tw_ByteOffset+1]; 
 133   1              ((U8 *)&tdw_StartByteAddr)[2]=gc_PlayRecordDataBuf[tw_ByteOffset+2];
 134   1              ((U8 *)&tdw_StartByteAddr)[3]=gc_PlayRecordDataBuf[tw_ByteOffset+3];
 135   1              ((U8 *)&tdw_ByteNum)[0] = gc_PlayRecordDataBuf[tw_ByteOffset+4];
 136   1              ((U8 *)&tdw_ByteNum)[1] = gc_PlayRecordDataBuf[tw_ByteOffset+5];
 137   1              ((U8 *)&tdw_ByteNum)[2] = gc_PlayRecordDataBuf[tw_ByteOffset+6];
 138   1              ((U8 *)&tdw_ByteNum)[3] = gc_PlayRecordDataBuf[tw_ByteOffset+7];
 139   1              tdw_StartByteAddr = tdw_StartByteAddr + tdw_ByteNum * tc_CurrentOffset;
 140   1              User_ReadReserveBlockData_To_TFT(((U32)gw_icon_sector*512)+tdw_StartByteAddr,tdw_ByteNum);      
 141   1      }
 142          
 143          
 144          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    682    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      22
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
