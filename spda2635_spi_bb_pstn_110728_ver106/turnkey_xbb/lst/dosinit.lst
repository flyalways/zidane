C51 COMPILER V9.00   DOSINIT                                                               07/09/2012 21:16:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DOSINIT
OBJECT MODULE PLACED IN .\obj\dosinit.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE DOS\dosinit.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource\hea
                    -der) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\dosinit.lst) OBJECT(.\obj\dosinit.obj)

line level    source

   1          #include "..\header\SPDA2K.h"
   2          #include "..\header\variables.h"
   3          
   4          
   5          U8 JudgeBootSector(void)
   6          {
   7   1              U32 tdw_DiskSize;
   8   1              U32     tdw_PBRAddr;
   9   1              U32     tdw_PBRAddr1;
  10   1      
  11   1              ((U8 *)(&tdw_PBRAddr))[0]=gc_PlayRecordDataBuf[0x1C9];
  12   1              ((U8 *)(&tdw_PBRAddr))[1]=gc_PlayRecordDataBuf[0x1C8];
  13   1              ((U8 *)(&tdw_PBRAddr))[2]=gc_PlayRecordDataBuf[0x1C7];
  14   1              ((U8 *)(&tdw_PBRAddr))[3]=gc_PlayRecordDataBuf[0x1C6];
  15   1      
  16   1              ((U8 *)(&tdw_DiskSize))[0]=gc_PlayRecordDataBuf[0x1CD];
  17   1              ((U8 *)(&tdw_DiskSize))[1]=gc_PlayRecordDataBuf[0x1CC];
  18   1              ((U8 *)(&tdw_DiskSize))[2]=gc_PlayRecordDataBuf[0x1CB];
  19   1              ((U8 *)(&tdw_DiskSize))[3]=gc_PlayRecordDataBuf[0x1CA];
  20   1      
  21   1              ((U8 *)(&tdw_PBRAddr1))[0]=gc_PlayRecordDataBuf[0x1D9];
  22   1              ((U8 *)(&tdw_PBRAddr1))[1]=gc_PlayRecordDataBuf[0x1D8];
  23   1              ((U8 *)(&tdw_PBRAddr1))[2]=gc_PlayRecordDataBuf[0x1D7];
  24   1              ((U8 *)(&tdw_PBRAddr1))[3]=gc_PlayRecordDataBuf[0x1D6];
  25   1      
  26   1              if((tdw_DiskSize+tdw_PBRAddr-1)==gdw_CARD_TotalSizeMB)
  27   1              {
  28   2                      return  1;      // MBR
  29   2              }
  30   1              if((tdw_DiskSize+tdw_PBRAddr)==gdw_CARD_TotalSizeMB)
  31   1              {
  32   2                      return  1;      // MBR
  33   2              }
  34   1      
  35   1              if((tdw_DiskSize+tdw_PBRAddr)<gdw_CARD_TotalSizeMB)
  36   1              {
  37   2                      if(((tdw_DiskSize+tdw_PBRAddr)*100/98)>gdw_CARD_TotalSizeMB)
  38   2                      {
  39   3                              return  1;      // MBR
  40   3                      }
  41   2              }
  42   1      
  43   1              if((tdw_DiskSize+tdw_PBRAddr+gc_PlayRecordDataBuf[0x1D0]-1)==tdw_PBRAddr1)
  44   1              {
  45   2      //              dbprintf(">>>iPod\n");
  46   2                      return 1;
  47   2              }
  48   1      
  49   1              if((gc_PlayRecordDataBuf[54]=='F')&&(gc_PlayRecordDataBuf[55]=='A')&&(gc_PlayRecordDataBuf[56]=='T'))
  50   1              {
  51   2                      return 0;
  52   2              }
  53   1      
  54   1              if((gc_PlayRecordDataBuf[82]=='F')&&(gc_PlayRecordDataBuf[83]=='A')&&(gc_PlayRecordDataBuf[84]=='T'))
C51 COMPILER V9.00   DOSINIT                                                               07/09/2012 21:16:45 PAGE 2   

  55   1              {
  56   2                      return 0;
  57   2              }
  58   1      
  59   1              if ((gc_PlayRecordDataBuf[0x1fe]!=0x55)||(gc_PlayRecordDataBuf[0x1ff]!=0xAA)) return 2;
  60   1              else if((gc_PlayRecordDataBuf[0]!=0xEB)&&(gc_PlayRecordDataBuf[0]!=0xE9)) return 1;
  61   1              else return 0;
  62   1      }       
  63          
  64          U8 DOS_Initialize(void)
  65          {
  66   1              xdata   U8      tc_Status;
  67   1              data    U8      tc_FATperDisc;
  68   1              data    U16     tw_RootDirSectors=0;
  69   1              data    U16     tw_DOS_ReserveSector;
  70   1              data    U32     tdw_PBRAddr;
  71   1              xdata   U32     tdw_PartitionSectorSize;
  72   1      
  73   1              tdw_PBRAddr=0;
  74   1              gb_ReadWriteDataArea=0;
  75   1              
  76   1              gw_FileIndex[0]=0;
  77   1              gw_FileIndex[1]=0;
  78   1              gw_FileIndex[2]=0;
  79   1              
  80   1              gw_FileTotalNumber[0]=0;
  81   1              gw_FileTotalNumber[1]=0;
  82   1      
  83   1              gs_File_FCB[0].dw_FDB_LogAdd=0;
  84   1              gs_File_FCB[1].dw_FDB_LogAdd=0;
  85   1              gs_File_FCB[2].dw_FDB_LogAdd=0;
  86   1      
  87   1              gs_File_FCB[0].dw_File_StartCluster=0xffffffff;
  88   1              gs_File_FCB[1].dw_File_StartCluster=0xffffffff;
  89   1              gs_File_FCB[2].dw_File_StartCluster=0xffffffff;
  90   1      
  91   1              if(!DOS_Read_LogicSector(0))
  92   1              { 
  93   2                      tc_Status=JudgeBootSector();
  94   2                      if(tc_Status==2)//(JC)neither PBR nor MBR 
  95   2                      {
  96   3                              return 1;
  97   3                      }
  98   2                      else if(tc_Status==1)//(JC)MBR
  99   2                      {
 100   3                              if(gc_PlayRecordDataBuf[0x1C2]!=0)
 101   3                              {
 102   4                                      ((U8 *)(&tdw_PBRAddr))[0]=gc_PlayRecordDataBuf[0x1C9];
 103   4                                      ((U8 *)(&tdw_PBRAddr))[1]=gc_PlayRecordDataBuf[0x1C8];
 104   4                                      ((U8 *)(&tdw_PBRAddr))[2]=gc_PlayRecordDataBuf[0x1C7];
 105   4                                      ((U8 *)(&tdw_PBRAddr))[3]=gc_PlayRecordDataBuf[0x1C6];
 106   4                              }
 107   3                              else
 108   3                              {
 109   4                                      ((U8 *)(&tdw_PBRAddr))[0]=gc_PlayRecordDataBuf[0x1D9];
 110   4                                      ((U8 *)(&tdw_PBRAddr))[1]=gc_PlayRecordDataBuf[0x1D8];
 111   4                                      ((U8 *)(&tdw_PBRAddr))[2]=gc_PlayRecordDataBuf[0x1D7];
 112   4                                      ((U8 *)(&tdw_PBRAddr))[3]=gc_PlayRecordDataBuf[0x1D6];
 113   4                              }
 114   3                              gdw_DOS_PBRAddr=tdw_PBRAddr;
 115   3                              if(DOS_Read_LogicSector(tdw_PBRAddr*gc_HostSectorUnit))
 116   3                              {//read PBR sector error.
C51 COMPILER V9.00   DOSINIT                                                               07/09/2012 21:16:45 PAGE 3   

 117   4                                      return DOS_READ_PBS_ERR;
 118   4                              } 
 119   3                      } 
 120   2      
 121   2                      if(((gc_PlayRecordDataBuf[54]=='F')&&(gc_PlayRecordDataBuf[55]=='A')&&(gc_PlayRecordDataBuf[56]=='T'))
 122   2                       ||((gc_PlayRecordDataBuf[82]=='F')&&(gc_PlayRecordDataBuf[83]=='A')&&(gc_PlayRecordDataBuf[84]=='T')))
 123   2                      {
 124   3                              gc_DOS_SectorPerCluster=gc_PlayRecordDataBuf[0x0D];
 125   3                              tc_FATperDisc=gc_PlayRecordDataBuf[0x10];
 126   3                              ((U8 *)(&tw_DOS_ReserveSector))[0]=gc_PlayRecordDataBuf[0x0F];
 127   3                              ((U8 *)(&tw_DOS_ReserveSector))[1]=gc_PlayRecordDataBuf[0x0E];
 128   3                              gdw_DOS_Fat1Addr=tdw_PBRAddr+tw_DOS_ReserveSector;
 129   3                              ((U8 *)(&gdw_DOS_SectorPerFAT))[0]=0;
 130   3                              ((U8 *)(&gdw_DOS_SectorPerFAT))[1]=0;
 131   3                              ((U8 *)(&gdw_DOS_SectorPerFAT))[2]=gc_PlayRecordDataBuf[0x17];
 132   3                              ((U8 *)(&gdw_DOS_SectorPerFAT))[3]=gc_PlayRecordDataBuf[0x16];
 133   3                              if(gdw_DOS_SectorPerFAT)                //(JC)check FATSize16/12
 134   3                      {
 135   4                              ((U8 *)(&tw_RootDirSectors))[0]=gc_PlayRecordDataBuf[0x12];
 136   4                                      ((U8 *)(&tw_RootDirSectors))[1]=gc_PlayRecordDataBuf[0x11];
 137   4                                      tw_RootDirSectors=tw_RootDirSectors>>4;
 138   4                      }
 139   3                      else//FAT32
 140   3                      {
 141   4                              ((U8 *)(&gdw_DOS_SectorPerFAT))[0] = gc_PlayRecordDataBuf[0x27];
 142   4                                      ((U8 *)(&gdw_DOS_SectorPerFAT))[1] = gc_PlayRecordDataBuf[0x26];
 143   4                                      ((U8 *)(&gdw_DOS_SectorPerFAT))[2] = gc_PlayRecordDataBuf[0x25];
 144   4                                      ((U8 *)(&gdw_DOS_SectorPerFAT))[3] = gc_PlayRecordDataBuf[0x24];
 145   4                      }
 146   3                      gdw_DOS_Fat2Addr=gdw_DOS_Fat1Addr;
 147   3                      if(tc_FATperDisc==2)
 148   3                              {
 149   4                      gdw_DOS_Fat2Addr+=gdw_DOS_SectorPerFAT;
 150   4                              }
 151   3                      
 152   3                      ((U8 *)(&tdw_PartitionSectorSize))[0]=0;
 153   3                              ((U8 *)(&tdw_PartitionSectorSize))[1]=0;
 154   3                              ((U8 *)(&tdw_PartitionSectorSize))[2]=gc_PlayRecordDataBuf[0x14];
 155   3                              ((U8 *)(&tdw_PartitionSectorSize))[3]=gc_PlayRecordDataBuf[0x13];
 156   3      
 157   3                      if(tdw_PartitionSectorSize==0)
 158   3                      {//(JC)FAT32 or FAT12/16 size more than 32M
 159   4                              ((U8 *)(&tdw_PartitionSectorSize))[0]=gc_PlayRecordDataBuf[0x23];
 160   4                                      ((U8 *)(&tdw_PartitionSectorSize))[1]=gc_PlayRecordDataBuf[0x22];
 161   4                                      ((U8 *)(&tdw_PartitionSectorSize))[2]=gc_PlayRecordDataBuf[0x21];
 162   4                                      ((U8 *)(&tdw_PartitionSectorSize))[3]=gc_PlayRecordDataBuf[0x20];
 163   4                      }       
 164   3      
 165   3                      if (tdw_PartitionSectorSize!=0)
 166   3                              {                               
 167   4                                      gdw_DOS_FatMaxCluster=tdw_PartitionSectorSize-tw_DOS_ReserveSector-tw_RootDirSectors-(gdw_DOS_SectorPe
             -rFAT<<(tc_FATperDisc-1));
 168   4                                      gdw_DOS_FatMaxCluster=gdw_DOS_FatMaxCluster/gc_DOS_SectorPerCluster;
 169   4                                              
 170   4                              if(gdw_DOS_FatMaxCluster<65525)
 171   4                              {
 172   5                                              gc_DOS_FileSystemType=1;        // FAT16
 173   5                                      }
 174   4                              else
 175   4                              {
 176   5                                      gc_DOS_FileSystemType=2;        // FAT32
 177   5                                      }
C51 COMPILER V9.00   DOSINIT                                                               07/09/2012 21:16:45 PAGE 4   

 178   4      
 179   4      //                              gdw_DOS_FatMaxCluster+=2;       //(JC)the maximum cluster no
 180   4                                      if ((gdw_DOS_FatMaxCluster==0)||(gdw_DOS_FatMaxCluster>0x0FFFFFFF))
 181   4                                      {//0x0fffffff means last cluster in chain in FAT32.
 182   5                                              gdw_DOS_FatMaxCluster=0x0FFFFFFF;
 183   5                                      }
 184   4      
 185   4                                      if(gc_DOS_FileSystemType==1)
 186   4                                      {// FAT 16
 187   5                                              gdw_DOS_RootDirAddr = gdw_DOS_Fat2Addr + gdw_DOS_SectorPerFAT;
 188   5                                              gdw_DOS_DataAddr = gdw_DOS_RootDirAddr + tw_RootDirSectors/gc_HostSectorUnit;
 189   5                                              //FAT12/16 have no root dir cluster. starting cluster '2' is in the beginning of data area
 190   5                                              gdw_DOS_RootDirClus=0;
 191   5                                      }
 192   4                                      else if(gc_DOS_FileSystemType==2)                                       
 193   4                                      {// FAT 32
 194   5                                              gdw_DOS_DataAddr = gdw_DOS_Fat2Addr + gdw_DOS_SectorPerFAT;
 195   5                                              //(JC)BPB_RootClus[3:0]                         
 196   5                                              ((U8 *)(&gdw_DOS_RootDirClus))[0]=gc_PlayRecordDataBuf[0x2F];
 197   5                                              ((U8 *)(&gdw_DOS_RootDirClus))[1]=gc_PlayRecordDataBuf[0x2E];
 198   5                                              ((U8 *)(&gdw_DOS_RootDirClus))[2]=gc_PlayRecordDataBuf[0x2D];
 199   5                                              ((U8 *)(&gdw_DOS_RootDirClus))[3]=gc_PlayRecordDataBuf[0x2C];
 200   5                                              gdw_DOS_RootDirAddr=gdw_DOS_DataAddr+((gdw_DOS_RootDirClus-2)*(U32)gc_DOS_SectorPerCluster);//start f
             -rom cluster 2
 201   5                                      }
 202   4                                      gdw_DOS_Fat1Addr=gdw_DOS_Fat1Addr*gc_HostSectorUnit;
 203   4                                      gdw_DOS_Fat2Addr=gdw_DOS_Fat2Addr*gc_HostSectorUnit;
 204   4                                      gdw_DOS_DataAddr=gdw_DOS_DataAddr*gc_HostSectorUnit;
 205   4                                      gdw_DOS_RootDirAddr=gdw_DOS_RootDirAddr*gc_HostSectorUnit;
 206   4                              }
 207   3                              else
 208   3                              {//tdw_PartitionSectorSize == 0, not FAT12/16/32
 209   4                                      return DOS_PARTITIONSIZE_ERR;
 210   4                              }
 211   3                      }
 212   2              }
 213   1              else
 214   1              {
 215   2                      return DOS_READ_MBS_ERR;        
 216   2              }
 217   1              return 0;  
 218   1      }
 219          
 220          
 221          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1300    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
