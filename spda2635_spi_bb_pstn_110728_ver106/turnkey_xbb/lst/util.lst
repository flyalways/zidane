A51 MACRO ASSEMBLER  UTIL                                                                 07/09/2012 21:16:44 PAGE     1


MACRO ASSEMBLER A51 V8.01
OBJECT MODULE PLACED IN .\obj\util.obj
ASSEMBLER INVOKED BY: C:\Keil\C51\BIN\A51.EXE ASM\util.a51 SET(LARGE) DEBUG PRINT(.\lst\util.lst) OBJECT(.\obj\util.obj)
                       EP

LOC  OBJ            LINE     SOURCE

                       1             NAME UTIL
                       2     
                       3     ?PR?_fat16_free_cluster_offset?UTIL             SEGMENT CODE
                       4     ?PR?_fat32_free_cluster_offset?UTIL             SEGMENT CODE
                       5     ?PR?_count_free_cluster_in_fat16_sector?UTIL    SEGMENT CODE
                       6     ?PR?_count_free_cluster_in_fat32_sector?UTIL    SEGMENT CODE
                       7     PUBLIC _fat16_free_cluster_offset
                       8     PUBLIC _fat32_free_cluster_offset
                       9     PUBLIC _count_free_cluster_in_fat16_sector
                      10     PUBLIC _count_free_cluster_in_fat32_sector
                      11     
                      12     
                      13     
                      14     
                      15     
                      16     
                      17     ;U8 fat16_free_cluster_offset(U8 xdata * p, U8 size)
                      18     ;{
                      19     ;       UBYTE count = size;
                      20     ;       while (count)
                      21     ;       {
                      22     ;               if (*p++ == 0)
                      23     ;               {
                      24     ;                       if (*p++ == 0)
                      25     ;                       {
                      26     ;                               return size-count;
                      27     ;                       }
                      28     ;               }
                      29     ;               else
                      30     ;                       p++;
                      31     ;               count--;
                      32     ;       }
                      33     ;       return size;
                      34     ;}
----                  35             RSEG  ?PR?_fat16_free_cluster_offset?UTIL
0000                  36     _fat16_free_cluster_offset:
                      37             ;// size = R5
                      38             ;// p = {R6, R7}
0000 8A83             39             mov             DPH, R2;R6
0002 8982             40             mov             DPL, R1;R7
0004 ED               41             mov     A, R5
0005 FF               42             mov     R7, A                   ;// R7 = size, R5 = count
0006 6010             43             jz      ?__fat16_search_free_loop_end
0008                  44     ?__fat16_search_free_loop_begin:
0008 E0               45             movx    A, @DPTR
0009 A3               46             inc     DPTR
000A 7009             47             jnz     ?__fat16_search_not_free_b0
000C E0               48             movx    A, @DPTR
000D A3               49             inc     DPTR
000E 7006             50             jnz     ?__fat16_search_not_free_b1
0010 C3               51             clr     C
0011 EF               52             mov     A, R7
0012 9D               53             subb    A, R5                   ;// A = size - count
0013 FF               54             mov     R7, A
0014 22               55             ret
0015                  56     ?__fat16_search_not_free_b0:
0015 A3               57             inc     DPTR
A51 MACRO ASSEMBLER  UTIL                                                                 07/09/2012 21:16:44 PAGE     2

0016                  58     ?__fat16_search_not_free_b1:
0016                  59     ?__fat16_search_free_loop_condition:
0016 DDF0             60             djnz    R5, ?__fat16_search_free_loop_begin     ;// count--
0018                  61     ?__fat16_search_free_loop_end:
0018 22               62             ret                                             ;// return R7 = size
                      63     
                      64     
                      65     ;! \internal Search FAT32 free clusters in the given buffer p[].
                      66     ;       \param  p               Buffer for FAT.
                      67     ;       \param  size    Should be equal to or less than 128.
                      68     ;       \return Free cluster entry offset in the sector.
                      69     ; U8 fat32_free_cluster_offset(U8 xdata * p, U8 size)
                      70     ;{
                      71     ;       UBYTE offset;
                      72     ;       offset = 0;
                      73     ;       while (size)
                      74     ;       {
                      75     ;               if (*p++ == 0)
                      76     ;               {
                      77     ;                       if (*p++ == 0)
                      78     ;                       {
                      79     ;                               if (*p++ == 0)
                      80     ;                               {
                      81     ;                                       if (*p++ == 0)
                      82     ;                                       {
                      83     ;                                               return offset;
                      84     ;                                       }
                      85     ;                               }
                      86     ;                               else
                      87     ;                                       p++;
                      88     ;                       }
                      89     ;                       else
                      90     ;                       {
                      91     ;                               p++;
                      92     ;                               p++;
                      93     ;                       }
                      94     ;               }
                      95     ;               else
                      96     ;               {
                      97     ;                       p ++;
                      98     ;                       p ++;
                      99     ;                       p ++;
                     100     ;               }
                     101     ;               offset++;
                     102     ;               size--;
                     103     ;       }
                     104     ;       return offset;
                     105     ;}
----                 106             RSEG  ?PR?_fat32_free_cluster_offset?UTIL
0000                 107     _fat32_free_cluster_offset:
                     108     ;       // size = R5
                     109     ;       // p = {R6, R7}
0000 8A83            110             mov             DPH, R2;R6
0002 8982            111             mov             DPL, R1;R7
0004 ED              112             mov     A, R5
0005 FF              113             mov     R7, A                    
0006 601A            114             jz      ?__fat32_search_free_loop_end
0008                 115     ?__fat32_search_free_loop_begin:
0008 E0              116             movx    A, @DPTR
0009 A3              117             inc     DPTR
000A 7011            118             jnz     ?__fat32_search_not_free_b0
000C E0              119             movx    A, @DPTR
000D A3              120             inc     DPTR
000E 700E            121             jnz     ?__fat32_search_not_free_b1
0010 E0              122             movx    A, @DPTR
0011 A3              123             inc     DPTR
A51 MACRO ASSEMBLER  UTIL                                                                 07/09/2012 21:16:44 PAGE     3

0012 700B            124             jnz     ?__fat32_search_not_free_b2
0014 E0              125             movx    A, @DPTR
0015 A3              126             inc     DPTR
0016 7008            127             jnz     ?__fat32_search_not_free_b3
0018 C3              128             clr     C
0019 EF              129             mov     A, R7
001A 9D              130             subb    A, R5                   ;// A = size - count
001B FF              131             mov     R7, A
001C 22              132             ret
001D                 133     ?__fat32_search_not_free_b0:
001D A3              134             inc     DPTR
001E                 135     ?__fat32_search_not_free_b1:
001E A3              136             inc     DPTR
001F                 137     ?__fat32_search_not_free_b2:
001F A3              138             inc     DPTR
0020                 139     ?__fat32_search_not_free_b3:
0020                 140     ?__fat32_search_free_loop_condition:
0020 DDE6            141             djnz    R5, ?__fat32_search_free_loop_begin     ;// count--
0022                 142     ?__fat32_search_free_loop_end:
0022 22              143             ret                                             ;// return R7 = size
                     144     
                     145     
                     146     ; ! \internal Count FAT16 free clusters in a given buffer p[].
                     147     ;       This function is limied by the max number of argument 'size'.
                     148     ;  So one call cannot search the entire 512-byte (256-cluster-entry) buffer.
                     149     ;       \param  p               Buffer for FAT.
                     150     ;       \param  size    Size of the buffer p[]. 0<=size<=255.
                     151     ;       \return Number of free clusters.
                     152     ;U8 count_free_cluster_in_fat16_sector(U8 xdata * p, U8 size)
                     153     ;{
                     154     ;       UBYTE xdata * base = p;
                     155     ;       UBYTE free_cluster_count = 0;
                     156     ;       while (size)
                     157     ;       {
                     158     ;               if (*p++ == 0)
                     159     ;               {
                     160     ;                       if (*p == 0)
                     161     ;                       {
                     162     ;                               free_cluster_count++;
                     163     ;                       }
                     164     ;               }
                     165     ;               p = (base += 2);
                     166     ;               size--;
                     167     ;       }
                     168     ;       return free_cluster_count;
                     169     ;}
----                 170             RSEG  ?PR?_count_free_cluster_in_fat16_sector?UTIL
0000                 171     _count_free_cluster_in_fat16_sector:
                     172     ;       // size = R5
                     173     ;       // p = {R6, R7}
0000 8F82            174             mov             DPL, R7
0002 8A83            175             mov             DPH, R2;R6
0004 E4              176             clr             A
0005 FF              177             mov             R7, A                   ;// R7 = free_cluster_count = 0;
0006 ED              178             mov             A, R5
0007 6010            179             jz              ?__fat16_count_free_loop_end
0009                 180     ?__fat16_count_free_loop_begin:
0009 E0              181             movx    A, @DPTR
000A A3              182             inc             DPTR
000B 7009            183             jnz             ?__fat16_count_not_free_b0
000D E0              184             movx    A, @DPTR
000E A3              185             inc             DPTR
000F 7006            186             jnz             ?__fat16_count_not_free_b1
                     187     
0011 0F              188             inc             R7                                      ;// free_cluster_count++
0012 DDF5            189             djnz    R5, ?__fat16_count_free_loop_begin
A51 MACRO ASSEMBLER  UTIL                                                                 07/09/2012 21:16:44 PAGE     4

0014 8003            190             jmp             ?__fat16_count_free_loop_end
0016                 191     ?__fat16_count_not_free_b0:
0016 A3              192             inc             DPTR
0017                 193     ?__fat16_count_not_free_b1:
0017                 194     ?__fat16_count_free_loop_condition:
0017 DDF0            195             djnz    R5, ?__fat16_count_free_loop_begin
0019                 196     ?__fat16_count_free_loop_end:
                     197     
0019 22              198             ret
                     199     
                     200     
                     201     ;! \internal
                     202     ;! \internal Count FAT32 free clusters in a given buffer p[].
                     203     ;       \param  p               Buffer for FAT.
                     204     ;       \param  size    Size of the buffer p[].
                     205     ;       \return Number of free clusters.
                     206     ; U8 count_free_cluster_in_fat32_sector(U8 xdata * p, U8 size)
                     207     ;{
                     208     ;       UBYTE xdata * base = p;
                     209     ;       UBYTE free_cluster_count = 0;
                     210     ;       while (size)
                     211     ;       {
                     212     ;               if (*p++ == 0)
                     213     ;               {
                     214     ;                       if (*p++ == 0)
                     215     ;                       {
                     216     ;                               if (*p++ == 0)
                     217     ;                               {
                     218     ;                                       if (*p == 0)
                     219     ;                                       {
                     220     ;                                               free_cluster_count++;
                     221     ;                                       }
                     222     ;                               }
                     223     ;                       }
                     224     ;               }
                     225     ;               p = (base += 4);
                     226     ;               size--;
                     227     ;       }
                     228     ;       return free_cluster_count;
                     229     ;}
----                 230             RSEG  ?PR?_count_free_cluster_in_fat32_sector?UTIL
0000                 231     _count_free_cluster_in_fat32_sector:
                     232     ;        size = R5
                     233     ;        p = {R6, R7}
0000 8E83            234             mov             DPH, R6
0002 8982            235             mov             DPL, R1;R7
0004 E4              236             clr             A
0005 FF              237             mov             R7, A                   ;// R7 = free_cluster_count = 0;
0006 ED              238             mov             A, R5
0007 601A            239             jz              ?__fat32_count_free_loop_end
0009                 240     ?__fat32_count_free_loop_begin:
0009 E0              241             movx    A, @DPTR
000A A3              242             inc             DPTR
000B 7011            243             jnz             ?__fat32_count_not_free_b0
000D E0              244             movx    A, @DPTR
000E A3              245             inc             DPTR
000F 700E            246             jnz             ?__fat32_count_not_free_b1
0011 E0              247             movx    A, @DPTR
0012 A3              248             inc             DPTR
0013 700B            249             jnz             ?__fat32_count_not_free_b2
0015 E0              250             movx    A, @DPTR
0016 A3              251             inc             DPTR
0017 7008            252             jnz             ?__fat32_count_not_free_b3
                     253     
0019 0F              254             inc             R7                                      ;// free_cluster_count++
001A DDED            255             djnz    R5, ?__fat32_count_free_loop_begin
A51 MACRO ASSEMBLER  UTIL                                                                 07/09/2012 21:16:44 PAGE     5

001C 8005            256             jmp             ?__fat32_count_free_loop_end
001E                 257     ?__fat32_count_not_free_b0:
001E A3              258             inc             DPTR
001F                 259     ?__fat32_count_not_free_b1:
001F A3              260             inc             DPTR
0020                 261     ?__fat32_count_not_free_b2:
0020 A3              262             inc             DPTR
0021                 263     ?__fat32_count_not_free_b3:
0021                 264     ?__fat32_count_free_loop_condition:
0021 DDE6            265             djnz    R5, ?__fat32_count_free_loop_begin
0023                 266     ?__fat32_count_free_loop_end:
                     267     
0023 22              268             ret
                     269     
                     270             END
                             
A51 MACRO ASSEMBLER  UTIL                                                                 07/09/2012 21:16:44 PAGE     6

SYMBOL TABLE LISTING
------ ----- -------


N A M E                                    T Y P E  V A L U E   ATTRIBUTES

?PR?_COUNT_FREE_CLUSTER_IN_FAT16_SECTOR?UTIC SEG    001AH       REL=UNIT
?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIC SEG    0024H       REL=UNIT
?PR?_FAT16_FREE_CLUSTER_OFFSET?UTIL . .    C SEG    0019H       REL=UNIT
?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL . .    C SEG    0023H       REL=UNIT
?__FAT16_COUNT_FREE_LOOP_BEGIN. . . . .    C ADDR   0009H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT16_SECTOR?UTIL
?__FAT16_COUNT_FREE_LOOP_CONDITION. . .    C ADDR   0017H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT16_SECTOR?UTIL
?__FAT16_COUNT_FREE_LOOP_END. . . . . .    C ADDR   0019H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT16_SECTOR?UTIL
?__FAT16_COUNT_NOT_FREE_B0. . . . . . .    C ADDR   0016H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT16_SECTOR?UTIL
?__FAT16_COUNT_NOT_FREE_B1. . . . . . .    C ADDR   0017H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT16_SECTOR?UTIL
?__FAT16_SEARCH_FREE_LOOP_BEGIN . . . .    C ADDR   0008H   R   SEG=?PR?_FAT16_FREE_CLUSTER_OFFSET?UTIL
?__FAT16_SEARCH_FREE_LOOP_CONDITION . .    C ADDR   0016H   R   SEG=?PR?_FAT16_FREE_CLUSTER_OFFSET?UTIL
?__FAT16_SEARCH_FREE_LOOP_END . . . . .    C ADDR   0018H   R   SEG=?PR?_FAT16_FREE_CLUSTER_OFFSET?UTIL
?__FAT16_SEARCH_NOT_FREE_B0 . . . . . .    C ADDR   0015H   R   SEG=?PR?_FAT16_FREE_CLUSTER_OFFSET?UTIL
?__FAT16_SEARCH_NOT_FREE_B1 . . . . . .    C ADDR   0016H   R   SEG=?PR?_FAT16_FREE_CLUSTER_OFFSET?UTIL
?__FAT32_COUNT_FREE_LOOP_BEGIN. . . . .    C ADDR   0009H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIL
?__FAT32_COUNT_FREE_LOOP_CONDITION. . .    C ADDR   0021H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIL
?__FAT32_COUNT_FREE_LOOP_END. . . . . .    C ADDR   0023H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIL
?__FAT32_COUNT_NOT_FREE_B0. . . . . . .    C ADDR   001EH   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIL
?__FAT32_COUNT_NOT_FREE_B1. . . . . . .    C ADDR   001FH   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIL
?__FAT32_COUNT_NOT_FREE_B2. . . . . . .    C ADDR   0020H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIL
?__FAT32_COUNT_NOT_FREE_B3. . . . . . .    C ADDR   0021H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIL
?__FAT32_SEARCH_FREE_LOOP_BEGIN . . . .    C ADDR   0008H   R   SEG=?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL
?__FAT32_SEARCH_FREE_LOOP_CONDITION . .    C ADDR   0020H   R   SEG=?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL
?__FAT32_SEARCH_FREE_LOOP_END . . . . .    C ADDR   0022H   R   SEG=?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL
?__FAT32_SEARCH_NOT_FREE_B0 . . . . . .    C ADDR   001DH   R   SEG=?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL
?__FAT32_SEARCH_NOT_FREE_B1 . . . . . .    C ADDR   001EH   R   SEG=?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL
?__FAT32_SEARCH_NOT_FREE_B2 . . . . . .    C ADDR   001FH   R   SEG=?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL
?__FAT32_SEARCH_NOT_FREE_B3 . . . . . .    C ADDR   0020H   R   SEG=?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL
DPH . . . . . . . . . . . . . . . . . .    D ADDR   0083H   A   
DPL . . . . . . . . . . . . . . . . . .    D ADDR   0082H   A   
UTIL. . . . . . . . . . . . . . . . . .    N NUMB   -----       
_COUNT_FREE_CLUSTER_IN_FAT16_SECTOR . .    C ADDR   0000H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT16_SECTOR?UTIL
_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR . .    C ADDR   0000H   R   SEG=?PR?_COUNT_FREE_CLUSTER_IN_FAT32_SECTOR?UTIL
_FAT16_FREE_CLUSTER_OFFSET. . . . . . .    C ADDR   0000H   R   SEG=?PR?_FAT16_FREE_CLUSTER_OFFSET?UTIL
_FAT32_FREE_CLUSTER_OFFSET. . . . . . .    C ADDR   0000H   R   SEG=?PR?_FAT32_FREE_CLUSTER_OFFSET?UTIL


REGISTER BANK(S) USED: 0 


ASSEMBLY COMPLETE.  0 WARNING(S), 0 ERROR(S)
