C51 COMPILER V9.00   LCM_DISPLAY2                                                          07/09/2012 21:16:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LCM_DISPLAY2
OBJECT MODULE PLACED IN .\obj\LCM_Display2.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LCM\LCM_Display2.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsourc
                    -e\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\LCM_Display2.lst) OBJECT(.\obj\LCM_Display2.obj)

line level    source

   1          #include "..\Header\SPDA2K.h"
   2          #include "..\header\UI_config.h"
   3          #include "..\header\variables.h"
   4          #include "LCM_BMP.h"
   5          
   6                  
   7          void LCM_ShowCountryMenu(void)
   8          {
   9   1              data    U8      i;
  10   1              xdata   U8      *p;
  11   1      
  12   1              if(gc_CurrentHZK>16)
  13   1              {
  14   2                      LCM_DisplayMenuString(&gc_LrcDisplayBuf,0,0,(gc_CurrentHZK&3)*16,1);
  15   2              }
  16   1              else
  17   1              {
  18   2                      p=gc_Str_Country[gc_CurrentHZK];
  19   2                      for(i=0;i<p[0];i++)
  20   2                      {
  21   3                              gc_LrcDisplayBuf[i]=p[1+i];
  22   3                      }
  23   2                      LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,(gc_CurrentHZK&3)*16,1);
  24   2              }
  25   1      }
  26          
  27          void LCM_ShowMainMenu(void)
  28          {
  29   1              data    U8      i;
  30   1              xdata   U8      j;
  31   1              xdata   U8      k;
  32   1              xdata   U8      m;
  33   1              xdata   U8      tc_Offset;
  34   1              xdata   U8      *p;
  35   1              xdata   U16     tw_Addr;
  36   1      
  37   1              gb_LCM_InverseDisp=0;
  38   1              switch(gc_MainMenuNum)
  39   1              {
  40   2                      case 0: // 音樂(Music)
  41   2                              p=gc_Str_Music[gc_CurrentHZK];
  42   2                      break;
  43   2      
  44   2                      case 1: // FM 收音(FM Radio)
  45   2                              p=gc_Str_Radio[gc_CurrentHZK];
  46   2                      break;
  47   2      
  48   2                      case 2: // 錄音播放(WAV play)
  49   2                              p=gc_Str_WAV[gc_CurrentHZK];
  50   2                      break;
  51   2      
  52   2                      case 3: // 日曆(Calendar)
  53   2                              p=gc_Str_Calendar[gc_CurrentHZK];
  54   2                      break;
C51 COMPILER V9.00   LCM_DISPLAY2                                                          07/09/2012 21:16:49 PAGE 2   

  55   2      
  56   2                      case 4: // 設定(Setup)
  57   2                              p=gc_Str_Setup[gc_CurrentHZK];
  58   2                      break;
  59   2              }
  60   1      
  61   1              for(i=0;i<p[0];i++)
  62   1              {
  63   2                      gc_LrcDisplayBuf[i]=p[1+i];
  64   2              }
  65   1              LCM_Clear_L0_L1();
  66   1      #ifdef SPI_1M
  67   1              if(gc_CurrentHZK==LANG_CHS)
  68   1              {
  69   2                      LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],(128-p[0]*8)/2,0,1);
  70   2              }
  71   1              else
  72   1              {
  73   2                      LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],(128-p[0]*4)/2,0,1);
  74   2              }
  75   1      #else
                      if(gc_CurrentHZK==LANG_CHS||gc_CurrentHZK==LANG_CHT||gc_CurrentHZK==LANG_JAP||gc_CurrentHZK==LANG_KOR)
                      {
                              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],(128-p[0]*8)/2,0,1);
                      }
                      else
                      {
                              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],(128-p[0]*4)/2,0,1);
                      }
              #endif
  85   1              // Display Function Icon
  86   1              j=(gc_MainMenuNum+3)%5;
  87   1              for(i=0;i<5;i++)
  88   1              {
  89   2                      switch(j)
  90   2                      {
  91   3                              case 0:
  92   3                                      if(i==2)
  93   3                                      {
  94   4                                              tw_Addr=MusicIcon34x32;
  95   4                                      }
  96   3                                      else
  97   3                                      {
  98   4                                              tw_Addr=MusicIcon17x16;
  99   4                                      }
 100   3                              break;
 101   3      
 102   3                              case 1:
 103   3                                      if(i==2)
 104   3                                      {
 105   4                                              tw_Addr=FMIcon34x32;
 106   4                                      }
 107   3                                      else
 108   3                                      {
 109   4                                              tw_Addr=FMIcon17x16;
 110   4                                      }
 111   3                              break;
 112   3      
 113   3                              case 2:
 114   3                                      if(i==2)
 115   3                                      {
 116   4                                              tw_Addr=PlayRecordIcon34x32;
C51 COMPILER V9.00   LCM_DISPLAY2                                                          07/09/2012 21:16:49 PAGE 3   

 117   4                                      }
 118   3                                      else
 119   3                                      {
 120   4                                              tw_Addr=PlayRecordIcon17x16;
 121   4                                      }
 122   3                              break;
 123   3      
 124   3                              case 3:
 125   3                                      if(i==2)
 126   3                                      {
 127   4                                              tw_Addr=CalendarIcon34x32;
 128   4                                      }
 129   3                                      else
 130   3                                      {
 131   4                                              tw_Addr=CalendarIcon17x16;
 132   4                                      }
 133   3                              break;
 134   3      
 135   3                              case 4:
 136   3                                      if(i==2)
 137   3                                      {
 138   4                                              tw_Addr=SetupIcon34x32;
 139   4                                      }
 140   3                                      else
 141   3                                      {
 142   4                                              tw_Addr=SetupIcon17x16;
 143   4                                      }
 144   3                              break;
 145   3                      }
 146   2                      j=(j+1)%5;
 147   2                      switch(i)
 148   2                      {
 149   3                              case 0:
 150   3                                      tc_Offset=8;
 151   3                              break;
 152   3              
 153   3                              case 1:
 154   3                                      tc_Offset=29;
 155   3                              break;
 156   3              
 157   3                              case 3:
 158   3                                      tc_Offset=82;
 159   3                              break;
 160   3              
 161   3                              case 4:
 162   3                                      tc_Offset=103;
 163   3                              break;
 164   3                      }
 165   2                      if(i==2)
 166   2                      {
 167   3                              LCM_ReadSPIBMPdata(tw_Addr,136);
 168   3                              for(k=0;k<4;k++)
 169   3                              {
 170   4                                      LCM_set_address(k+2,47);
 171   4                                      for(m=0;m<34;m++)
 172   4                                      {
 173   5                                              LCM_write_data(gc_DirLCMtempBuf[m+k*34]);
 174   5                                      }
 175   4                              }
 176   3                      }
 177   2                      else
 178   2                      {
C51 COMPILER V9.00   LCM_DISPLAY2                                                          07/09/2012 21:16:49 PAGE 4   

 179   3                              LCM_ReadSPIBMPdata(tw_Addr,34);
 180   3                              for(k=0;k<2;k++)
 181   3                              {
 182   4                                      LCM_set_address(k+6,tc_Offset);
 183   4                                      for(m=0;m<17;m++)
 184   4                                      {
 185   5                                              LCM_write_data(gc_DirLCMtempBuf[m+k*17]);
 186   5                                      }
 187   4                              }
 188   3                      }
 189   2              }
 190   1      }
 191          
 192          void LCM_ShowPlayMenu(U8 tc_item)
 193          {
 194   1              data    U8      i;
 195   1              xdata   U8      *p;
 196   1      
 197   1              switch(tc_item)
 198   1              {
 199   2                      case 0: // 循環模式
 200   2                              p=gc_Str_Repeat[gc_CurrentHZK];
 201   2                      break;
 202   2      
 203   2                      case 1: // 音效設定
 204   2                              p=gc_Str_EQ[gc_CurrentHZK];
 205   2                      break;
 206   2      
 207   2                      case 2: // 復讀模式
 208   2                              p=gc_Str_AB[gc_CurrentHZK];
 209   2                      break;
 210   2      
 211   2                      case 3: // 退出
 212   2                              p=gc_Str_Exit2[gc_CurrentHZK];
 213   2                      break;
 214   2              }
 215   1      
 216   1              if(tc_item==gc_PlayMenuNum)
 217   1              {
 218   2                      gb_LCM_InverseDisp=1;   
 219   2              }
 220   1              for(i=0;i<p[0];i++)
 221   1              {
 222   2                      gc_LrcDisplayBuf[i]=p[1+i];
 223   2              }
 224   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,tc_item*16,1);
 225   1              gb_LCM_InverseDisp=0;
 226   1      }
 227          
 228          void LCM_ShowWAVPlayMenu(U8 tc_item)
 229          {
 230   1              data    U8      i;
 231   1              xdata   U8      *p;
 232   1      
 233   1              switch(tc_item)
 234   1              {
 235   2                      case 0: // 音效設定
 236   2                              p=gc_Str_EQ[gc_CurrentHZK];
 237   2                      break;
 238   2      
 239   2                      case 1: // 復讀模式
 240   2                              p=gc_Str_AB[gc_CurrentHZK];
C51 COMPILER V9.00   LCM_DISPLAY2                                                          07/09/2012 21:16:49 PAGE 5   

 241   2                      break;
 242   2      
 243   2                      case 2: // 退出
 244   2                              p=gc_Str_Exit2[gc_CurrentHZK];
 245   2                      break;
 246   2              }
 247   1      
 248   1              if(tc_item==gc_WAVPlayMenuNum)
 249   1              {
 250   2                      gb_LCM_InverseDisp=1;   
 251   2              }
 252   1              for(i=0;i<p[0];i++)
 253   1              {
 254   2                      gc_LrcDisplayBuf[i]=p[1+i];
 255   2              }
 256   1              LCM_DisplayMenuString(&gc_LrcDisplayBuf,p[0],0,tc_item*16,1);
 257   1              gb_LCM_InverseDisp=0;
 258   1      }
 259          
 260          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1057    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      21
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
