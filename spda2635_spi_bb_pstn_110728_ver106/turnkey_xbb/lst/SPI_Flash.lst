C51 COMPILER V9.00   SPI_FLASH                                                             07/09/2012 21:16:54 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE SPI_FLASH
OBJECT MODULE PLACED IN .\obj\SPI_Flash.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE SPI\SPI_Flash.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource\h
                    -eader) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\SPI_Flash.lst) OBJECT(.\obj\SPI_Flash.obj)

line level    source

   1          #include <intrins.h>
   2          #include "..\header\SPDA2K.h"
   3          #include "..\header\variables.h"
   4          
   5          
   6          void SPI_Send_Byte(U8 out)
   7          {
   8   1          XBYTE[0xBB00]=out;
   9   1              while((XBYTE[0xBB1C]&0x10)==1);
  10   1              XBYTE[0xBB10]|=0x02;                    // clear dummy read     
  11   1      }
  12          
  13          
  14          U8 SPI_Get_Byte(void)
  15          {
  16   1          XBYTE[0xBB00]=0xFF;                                 // write dummy to trigger read.
  17   1              while((XBYTE[0xBB1C]&0x10)==1);
  18   1              return XBYTE[0xBB00];
  19   1      }
  20          
  21          
  22          U8  SPI_Read_Status(void)
  23          {
  24   1              xdata   U8  byte;
  25   1              
  26   1              SPI_ENABLE();                   /* enable device */
  27   1              SPI_Send_Byte(0x05);            /* send RDSR command */
  28   1              byte = SPI_Get_Byte();          /* receive byte */
  29   1              SPI_DISABLE();                  /* disable device */
  30   1              return byte;    
  31   1      }
  32          
  33          
  34          void   SPI_Wait_Busy(void)
  35          {
  36   1          while ((SPI_Read_Status() & 0x01))  /* waste time until not busy */
  37   1              {
  38   2                      SPI_Read_Status();
  39   2              }
  40   1      }
  41          
  42          
  43          void  SPI_WREN(void)
  44          {
  45   1              SPI_ENABLE();
  46   1              SPI_Send_Byte(0x06);   
  47   1              SPI_DISABLE();
  48   1      } 
  49          
  50          
  51          void  SPI_WRDI(void)
  52          {
  53   1          SPI_ENABLE();
  54   1          SPI_Send_Byte(0x04);   
C51 COMPILER V9.00   SPI_FLASH                                                             07/09/2012 21:16:54 PAGE 2   

  55   1          SPI_DISABLE();
  56   1      }
  57          
  58          
  59          void  SPI_Read_Data(unionU16 tw_SPIAddr)
  60          { 
  61   1              data    U8      i;
  62   1      
  63   1              XBYTE[0xB400]|=0x20;    //reset spi interface 
  64   1              XBYTE[0xB400]=0x04;                     
  65   1              SPI_ENABLE(); 
  66   1              SPI_Send_Byte(0x03);  //CMD
  67   1              SPI_Send_Byte(tw_SPIAddr.BY[1]);  
  68   1              SPI_Send_Byte(tw_SPIAddr.BY[0]);  
  69   1              SPI_Send_Byte(0x00);  
  70   1              XBYTE[0xB304]=0x09;             //Reset DMA
  71   1              XBYTE[0xB304]=0x08;             //Normal DMA
  72   1              Device_Xfer_DataLength.WD=0x01FF;                       //read 512 byte
  73   1              SET_DEVICE_READ();
  74   1              XBYTE[0xBB10]=0x0F;                                             // after DMA, SPI FIFO has to be cleared
  75   1              Trigger_Data_Transfer_Done();
  76   1          SPI_DISABLE();                  
  77   1              for(i=0;i<200;i++); //一定要delay太快 會lose data ~~~
  78   1      }
  79          
  80          void  SPI_Write_Data(unionU16 tw_SPIAddr)
  81          {    
  82   1          if(gc_SPI_ID==0xBF) // SST
  83   1              {
  84   2              SPI_Write_Data_ADh(tw_SPIAddr);   
  85   2          }
  86   1          else
  87   1              {
  88   2              SPI_Write_Data_02h(tw_SPIAddr); 
  89   2          }
  90   1      }
  91          
  92          
  93          void  SPI_Write_Data_02h(unionU16 tw_SPIAddr)
  94          {
  95   1          data        U8 tw_Pagecnt;
  96   1      
  97   1          tw_Pagecnt=2;
  98   1          while(tw_Pagecnt)
  99   1              {
 100   2              SPI_WREN();// enable WR   
 101   2              SPI_ENABLE();         
 102   2              SPI_Send_Byte(0x02);  //CMD
 103   2              SPI_Send_Byte(tw_SPIAddr.BY[1]);  
 104   2              SPI_Send_Byte(tw_SPIAddr.BY[0]); 
 105   2              SPI_Send_Byte(0x00);    
 106   2              Device_Xfer_DataLength.WD = 0x00FF;     
 107   2              SET_DEVICE_WRITE();
 108   2              Trigger_Data_Transfer_Done();
 109   2              Device_Write_SRAM_Index.WD+=0x100;
 110   2              tw_SPIAddr.BY[0]++;
 111   2              tw_Pagecnt--;
 112   2              SPI_DISABLE();  
 113   2                  SPI_Wait_Busy();
 114   2                  SPI_WRDI();     
 115   2              }
 116   1      }
C51 COMPILER V9.00   SPI_FLASH                                                             07/09/2012 21:16:54 PAGE 3   

 117          
 118          
 119          void  SPI_Write_Data_ADh(unionU16 tw_SPIAddr)
 120          {
 121   1          data        U8 i;
 122   1      
 123   1          SPI_WREN();// enable WR
 124   1          SPI_ENABLE();
 125   1              SPI_Send_Byte(0x80);
 126   1              SPI_DISABLE();
 127   1      
 128   1          SPI_ENABLE();
 129   1          SPI_Send_Byte(0xAD);  //CMD
 130   1          SPI_Send_Byte(tw_SPIAddr.BY[1]);  
 131   1          SPI_Send_Byte(tw_SPIAddr.BY[0]);  
 132   1          SPI_Send_Byte(0x00);
 133   1          i=0;
 134   1              while(1)
 135   1              {
 136   2                      SPI_Send_Byte(gc_PlayRecordDataBuf[i*2]);
 137   2                      SPI_Send_Byte(gc_PlayRecordDataBuf[i*2+1]);            
 138   2                      SPI_DISABLE();
 139   2                      while(SPI_Read_Status()&0x01);
 140   2                      SPI_ENABLE();           
 141   2                      SPI_Send_Byte(0xAD);  
 142   2                      i++;
 143   2                      if(i==0)
 144   2                      {
 145   3                              break;
 146   3                      }
 147   2              }
 148   1              SPI_DISABLE();  
 149   1              SPI_Wait_Busy();
 150   1              SPI_WRDI();
 151   1              SPI_Read_Status();
 152   1      }
 153          
 154          
 155          void  SPI_Erase_Block(U8 tc_BlockNum)
 156          {
 157   1              XBYTE[0xB400]|=0x20;    //reset spi interface 
 158   1              XBYTE[0xB400]=0x04;                     
 159   1          SPI_WREN();// enable WR
 160   1          SPI_ENABLE();
 161   1          SPI_Send_Byte(0xD8);  //CMD
 162   1              SPI_Send_Byte(tc_BlockNum);  
 163   1              SPI_Send_Byte(0x00);  
 164   1              SPI_Send_Byte(0x00); 
 165   1              SPI_DISABLE();
 166   1              SPI_Wait_Busy();
 167   1              SPI_Read_Status();  
 168   1      }
 169          
 170          
 171          void SPI_UserData_Block_Erase(void)
 172          {
 173   1          SPI_Erase_Block(SPI_USERdata_AREA);
 174   1      }
 175          
 176          
 177          void SPI_UserData_Block_Read(U16 Sector_Addr,U8 Buf_Index)
 178          {
C51 COMPILER V9.00   SPI_FLASH                                                             07/09/2012 21:16:54 PAGE 4   

 179   1              data    unionU16        tdw_SPIAddr;
 180   1      
 181   1              Device_Read_SRAM_Index.BY[0]=Buf_Index;
 182   1              Device_Read_SRAM_Index.BY[1]=0x00;
 183   1              tdw_SPIAddr.BY[0]=Sector_Addr<<1;
 184   1              tdw_SPIAddr.BY[1]=Sector_Addr/128+SPI_USERdata_AREA;
 185   1              SPI_Read_Data(tdw_SPIAddr);
 186   1      }
 187          
 188          
 189          void SPI_UserData_Block_Write(U16 Sector_Addr,U8 Buf_Index)
 190          {
 191   1              data    unionU16        tdw_SPIAddr;
 192   1      
 193   1              XBYTE[0xB400]|=0x20;    //reset spi interface 
 194   1              XBYTE[0xB400]= 0x04;                     
 195   1      
 196   1              Device_Write_SRAM_Index.BY[0]=Buf_Index;
 197   1              Device_Write_SRAM_Index.BY[1]=0x00;
 198   1              tdw_SPIAddr.BY[0]=Sector_Addr<<1;
 199   1              tdw_SPIAddr.BY[1]=Sector_Addr/128+SPI_USERdata_AREA;
 200   1              SPI_Write_Data(tdw_SPIAddr);
 201   1      }
 202          
 203          
 204          void SPI_DSPHZK_Block_Read(U8 Area,U16 Offset_Addr,U8 Buf_Index)
 205          {
 206   1              unionU16        tdw_SPIAddr;
 207   1              XBYTE[0xB400]|=0x20;    //reset spi interface 
 208   1              XBYTE[0xB400]= 0x04;                     
 209   1      
 210   1              Device_Read_SRAM_Index.BY[0]=Buf_Index;
 211   1              Device_Read_SRAM_Index.BY[1]=0x00;
 212   1              tdw_SPIAddr.BY[0]=Offset_Addr<<1;
 213   1              tdw_SPIAddr.BY[1]=Offset_Addr/128;
 214   1      
 215   1              if(Area==1)
 216   1              {
 217   2                      tdw_SPIAddr.BY[1]+=SPI_HZK_AREA;        // HZK : Block8 ~
 218   2          }
 219   1          else
 220   1              {
 221   2                      tdw_SPIAddr.BY[1]+=SPI_DSP_AREA;        // DSP : Block3 ~ Block5
 222   2          }
 223   1          SPI_Read_Data(tdw_SPIAddr);
 224   1      }
 225          
 226          
 227          void Trigger_Data_Transfer(void) 
 228          {
 229   1              XBYTE[0xB3C0] = 0x00;                                                                           //Clear DMA Xfer done interrupt
 230   1              XBYTE[0xB3B0] = 0x01;                                                                           //Trigger Data Xfer
 231   1      }
 232          
 233          
 234          void Trigger_Data_Transfer_Done(void) 
 235          {
 236   1              XBYTE[0xB3B0]=0x01;
 237   1              while(!(XBYTE[0xB3C0]&0x01))    //Wait Data xfer done
 238   1              {
 239   2              }                                               
 240   1              XBYTE[0xB3C0]=0x00;                                                                             //Clear DMA Xfer done interrupt
C51 COMPILER V9.00   SPI_FLASH                                                             07/09/2012 21:16:54 PAGE 5   

 241   1      }
 242          
 243          
 244          void USER_Delay(U16 DT)
 245          {
 246   1              data    U16     i;
 247   1              data    U8      j;
 248   1              data    U8      k;
 249   1      
 250   1              if(gc_clock_mode==2)            DT*=2;
 251   1              else if(gc_clock_mode==5)       DT*=4;
 252   1              else if(gc_clock_mode==6)       DT*=4;
 253   1              else if(gc_clock_mode==4)       DT*=6;
 254   1              for(i=0;i<DT;i++)
 255   1              {
 256   2                      for(j=155;j>0;j--)
 257   2                      {
 258   3                              for(k=3;k>0;k--);
 259   3                      }
 260   2              }
 261   1      }
 262          
 263          
 264          void SET_DEVICE_READ(void) 
 265          {
 266   1              XBYTE[0xB301]=0x02;                                                             //FLASH to SRAM
 267   1              XBYTE[0xB302]=Device_Xfer_DataLength.BY[1];
 268   1              XBYTE[0xB303]=Device_Xfer_DataLength.BY[0];             //傳送長度
 269   1              XBYTE[0xB114]=Device_Read_SRAM_Index.BY[1];
 270   1              XBYTE[0xB115]=Device_Read_SRAM_Index.BY[0];             //SRAM Index
 271   1      }
 272          
 273          
 274          void SET_DEVICE_WRITE(void) 
 275          {
 276   1              XBYTE[0xB301]=0x20;                                                             //SRAM to FLASH
 277   1              XBYTE[0xB302]=Device_Xfer_DataLength.BY[1];
 278   1              XBYTE[0xB303]=Device_Xfer_DataLength.BY[0];             //傳送長度
 279   1              XBYTE[0xB112]=Device_Write_SRAM_Index.BY[1];
 280   1              XBYTE[0xB113]=Device_Write_SRAM_Index.BY[0];    //SRAM Index
 281   1      } 
 282          
 283          
 284          void SET_DEVICE_READ_TO_DRAM(void)
 285          {
 286   1              XBYTE[0xB301]=0x62;     // FLASH to Program RAM
 287   1              XBYTE[0xB302]=0xFF;               
 288   1              XBYTE[0xB303]=0x01;
 289   1              //DRAM Index
 290   1              XBYTE[0xB118] = 0x00;               
 291   1              XBYTE[0xB119] = gc_ProgRAM_Index;               
 292   1      }
 293          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    853    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      11
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.00   SPI_FLASH                                                             07/09/2012 21:16:54 PAGE 6   

   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
