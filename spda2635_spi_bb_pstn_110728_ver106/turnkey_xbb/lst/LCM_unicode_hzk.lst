C51 COMPILER V9.00   LCM_UNICODE_HZK                                                       07/09/2012 21:16:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE LCM_UNICODE_HZK
OBJECT MODULE PLACED IN .\obj\LCM_unicode_hzk.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE LCM\LCM_unicode_hzk.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libso
                    -urce\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\LCM_unicode_hzk.lst) OBJECT(.\obj\LCM_unicode_hzk.obj)

line level    source

   1          #include "..\Header\SPDA2K.h"
   2          #include "..\header\PROTOTYP.h"
   3          #include "..\LCM\LCM_BMP.h"
   4          #include "..\header\variables.h"
   5          
   6          #ifdef SPI_1M
   7          ////////////2M-spi hzk
   8          #define D_font_sector           0x6  //Font BMP sector
   9          void LCM_UNICODE_READ_HZK_SECTOR(U16 tw_SectorCount)
  10          {
  11   1              SPI_DSPHZK_Block_Read(1,tw_SectorCount,gc_PlayRecordDataBufHB);
  12   1      }
  13          //U8 UNICODE_HZK_GET_BMP(U8 tc_HighByte, U8 tc_LowByte,U8 * tc_BmpBuf,U8 tbt_UnicodeOrISN)
  14          U8 LCM_UNICODE_HZK_GET_BMP(U8 tc_HighByte, U8 tc_LowByte,U8 * tc_BmpBuf,U8 tbt_UnicodeOrISN)
  15          {
  16   1              U16     tw_hzkbyteoffest = 0,i;
  17   1              U16     tw_hzksectoroffest = 0;
  18   1              U32     ShowPointer;
  19   1      
  20   1              if(tc_HighByte&0x80)
  21   1              {
  22   2                      if(tc_HighByte<0xa1 || tc_LowByte<0xa1 || tc_HighByte>=0xf8)
  23   2                      {
  24   3                              goto CantFindHZ;
  25   3                      }
  26   2      
  27   2                      ShowPointer = (((U32)tc_HighByte-0xa1)*94+((U32)tc_LowByte-0xa1))*24;
  28   2                      
  29   2                      tw_hzksectoroffest = (U16)(ShowPointer/512);
  30   2                      tw_hzkbyteoffest = (U16)(ShowPointer%512);
  31   2      
  32   2                      LCM_UNICODE_READ_HZK_SECTOR(D_font_sector+tw_hzksectoroffest);
  33   2                      
  34   2                      if(tw_hzkbyteoffest<(512-24))
  35   2                      {
  36   3                              for(i=0;i<24;i++)
  37   3                              {
  38   4                                      *(tc_BmpBuf+i) = gc_PlayRecordDataBuf[tw_hzkbyteoffest+i];
  39   4                              }
  40   3                      }
  41   2                      else
  42   2                      {
  43   3                              for(i=0;i<(512-tw_hzkbyteoffest);i++)
  44   3                              {
  45   4                                      *(tc_BmpBuf+i) = gc_PlayRecordDataBuf[tw_hzkbyteoffest+i];
  46   4                              }
  47   3      
  48   3                              LCM_UNICODE_READ_HZK_SECTOR(D_font_sector+tw_hzksectoroffest+1);
  49   3      
  50   3                              for(i=0;i<(24-(512-tw_hzkbyteoffest));i++)
  51   3                              {
  52   4                                      *(tc_BmpBuf+((512-tw_hzkbyteoffest)+i)) = gc_PlayRecordDataBuf[i];
  53   4                              }
  54   3                      }
C51 COMPILER V9.00   LCM_UNICODE_HZK                                                       07/09/2012 21:16:49 PAGE 2   

  55   2      //              gw_BmpInx += 24;
  56   2                      return 0x80|12;
  57   2              }
  58   1              else
  59   1              {
  60   2                      if(!tc_HighByte) goto CantFindHZ;                       
  61   2              
  62   2                      ShowPointer=tc_HighByte*24;
  63   2      
  64   2                      tw_hzksectoroffest = (U16)(ShowPointer/512);
  65   2                      tw_hzkbyteoffest = (U16)(ShowPointer%512);
  66   2      
  67   2                      LCM_UNICODE_READ_HZK_SECTOR(tw_hzksectoroffest);
  68   2                      
  69   2                      if(tw_hzkbyteoffest<(512-24))
  70   2                      {
  71   3                              for(i=0;i<24;i++)
  72   3                              {
  73   4                                      *(tc_BmpBuf+i) = gc_PlayRecordDataBuf[tw_hzkbyteoffest+i];
  74   4                              }
  75   3                      }
  76   2                      else
  77   2                      {
  78   3                              for(i=0;i<(512-tw_hzkbyteoffest);i++)
  79   3                              {
  80   4                                      *(tc_BmpBuf+i) = gc_PlayRecordDataBuf[tw_hzkbyteoffest+i];
  81   4                              }
  82   3      
  83   3                              LCM_UNICODE_READ_HZK_SECTOR(tw_hzksectoroffest+1);
  84   3      
  85   3                              for(i=0;i<(24-(512-tw_hzkbyteoffest));i++)
  86   3                              {
  87   4                                      *(tc_BmpBuf+((512-tw_hzkbyteoffest)+i)) = gc_PlayRecordDataBuf[i];
  88   4                              }
  89   3                      }
  90   2      //              gw_BmpInx += 24;
  91   2                      return 0x00|10;  //英文字母不显示最后两列，以便美观些。-sunzhk add
  92   2              }
  93   1      
  94   1      CantFindHZ:
  95   1              for(tc_HighByte = 0; tc_HighByte < 24; tc_HighByte++)
  96   1              {
  97   2                      *(tc_BmpBuf+tc_HighByte) = 0;
  98   2              }
  99   1      
 100   1      //      gw_BmpInx += 24;
 101   1              return 0x80|12;
 102   1      }
*** WARNING C280 IN LINE 14 OF LCM\LCM_UNICODE_HZK.C: 'tbt_UnicodeOrISN': unreferenced local variable
 103          ////////////4M-spi hzk
 104          #else
              void LCM_UNICODE_READ_HZK_SECTOR(U16 tw_SectorCount)
              {
                      SPI_DSPHZK_Block_Read(1,tw_SectorCount,gc_PlayRecordDataBufHB);
              }
              //========================================================================================================
             -=====================
              //UNICODE_HZK_GET_BMP()
              //PARA:
              //              tc_HighByte: high byte of unicode or ISN                        
              //              tc_LowByte:  low byte of unicode or ISN 
              //              tc_BmpBuf:       the buffer point of the Bmp data
C51 COMPILER V9.00   LCM_UNICODE_HZK                                                       07/09/2012 21:16:49 PAGE 3   

              //              tbt_UnicodeOrISN: indicate the low and high byte is ISN or unicde,0: ISN; 1: unicode
              //return value:
              //              bit7: indicate the ISN is one or two bytes.0:one byte; 1: two bytes;
              //              bit6~bit0: the valid column number of the BmpData
              //========================================================================================================
             -=====================
                      #define D_font_sector           0x125  //Font BMP sector
              
                      #define SBCS    0
                      #define DBCS    1
              
                      #define CP1250_TAB_SECT                 1
                      #define CP1251_TAB_SECT                 2
                      #define CP1252_TAB_SECT                 3
                      #define CP1253_TAB_SECT                 4
                      #define CP1254_TAB_SECT                 5
                      #define CP1255_TAB_SECT                 6
                      #define CP1256_TAB_SECT                 7
                      #define CP1257_TAB_SECT                 8
                      #define CP1258_TAB_SECT                 9
                      #define CP874_TAB_SECT                  10
                      #define CP932_TAB_SECT                  11      // Shift JIS
                      #define CP936_TAB_SECT                  44      // GBK
                      #define CP949_TAB_SECT                  134 // for Korean
                      #define CP950_TAB_SECT                  227     // Big5
              
              U8 code char_set_bytes[] = 
              {
                      DBCS,   // Simplified Chinese
                      DBCS,   // Traditional Chinese
                      SBCS,   // English
                      DBCS,   // Japense
                      DBCS,   // Korean
                      SBCS,   // German
                      SBCS,   // French
                      SBCS,   // Italian
                      SBCS,   // Spanish
                      SBCS,   // Swedish
                      SBCS,   // Czech
                      SBCS,   // Dutch
                      SBCS,   // Portuguese
                      SBCS,   // Danish
                      SBCS,   // Polish
                      SBCS,   // Russian      
              };
              
              U8 code gwa_trans_table_sector[] =
              {
                      CP936_TAB_SECT,         // Simplified Chinese
                      CP950_TAB_SECT,         // Traditional Chinese
                      CP1252_TAB_SECT,        // English
                      CP932_TAB_SECT,         // Japense
                      CP949_TAB_SECT,         // Korean
                      CP1252_TAB_SECT,        // German
                      CP1252_TAB_SECT,        // French
                      CP1252_TAB_SECT,        // Italian
                      CP1252_TAB_SECT,        // Spanish
                      CP1252_TAB_SECT,        // Swedish
                      CP1250_TAB_SECT,        // Czech
                      CP1252_TAB_SECT,        // Dutch
                      CP1252_TAB_SECT,        // Portuguese
                      CP1252_TAB_SECT,        // Danish
C51 COMPILER V9.00   LCM_UNICODE_HZK                                                       07/09/2012 21:16:49 PAGE 4   

                      CP1250_TAB_SECT,        // Polish
                      CP1251_TAB_SECT,        // Russian
              };
              
              
              U8 LCM_UNICODE_HZK_GET_BMP(U8 tc_HighByte, U8 tc_LowByte,U8 * tc_BmpBuf,U8 tbt_UnicodeOrISN)
              {
                      data    U8      tc_Loop;
                      data    U8      tc_ValidColumn;
                      data    U8      tc_LookupAttribute;
                      data    U8      tc_TwoByteFlag;
                      data    U16     tw_OffsetSector;
                      data    U16     tw_ByteOffset;
                      data    U16     tw_UnicodeTabOffset;
                      data    U16     tw_unicode;
                      xdata   U16     tw_tmp;
                      xdata   U8      xdata * p;
              
                      tc_TwoByteFlag=0x80;
                      tw_OffsetSector=0;
                      tc_Loop=0;
                      
                      //-------------------------------------------------------------------
                      // if it is ISN and high byte's bit7 is 1, must convert it to Unicode
                      //-------------------------------------------------------------------
                      if(!tbt_UnicodeOrISN)
                      {               
                              if(tc_HighByte&0x80)
                              {//if it is ISN,try to convert to unicode
                                      tc_LookupAttribute=char_set_bytes[gc_CurrentHZK];
                                      if(gc_CurrentHZK==LANG_JAP)
                                      {//if it is not japanese
                                              if((tc_HighByte>=0xA1)&&(tc_HighByte<=0xDF))
                                              {//if it is in single byte area,pad 0 to low byte
                                                      tc_LowByte=0;
                                                      tc_TwoByteFlag=0x00;// next onebyte
                                              }
                                      }
                                      else
                                      {//if it is not japanese
                                              if(tc_LookupAttribute==0x00)
                                              {//if attribute is 0x00, ISN is single byte
                                                      tc_TwoByteFlag=0;
                                              }
                                      }
                              
                                      //read table first 
                                      LCM_UNICODE_READ_HZK_SECTOR(gwa_trans_table_sector[gc_CurrentHZK]);     
                                      tw_ByteOffset=(U16)(tc_HighByte)*2;     //get the start offset byte in secotr 
                                                                                                                              //tc_LookupAttribute=1: information is sector 
                                                                                                                              //tc_LookupAttribute=0: information is Unicode                  
                                      if(tc_LookupAttribute)
                                      {//if attribute is 0x01, ISN is double bytes
                                              //---------------- read unicode Table sector -------------------
                                              tw_UnicodeTabOffset=*(U16 *)(&gc_PlayRecordDataBuf[tw_ByteOffset]);
                                              tw_UnicodeTabOffset=tw_UnicodeTabOffset+(U16)(tc_LowByte-0x40)*2 ;
              
                                              tw_OffsetSector=(tw_UnicodeTabOffset>>9)+gwa_trans_table_sector[gc_CurrentHZK];//get the start offset 
             -sector
                                              tw_ByteOffset=tw_UnicodeTabOffset&0x1FF;
                                              LCM_UNICODE_READ_HZK_SECTOR(tw_OffsetSector);//read the corect sector
                                      }
C51 COMPILER V9.00   LCM_UNICODE_HZK                                                       07/09/2012 21:16:49 PAGE 5   

              
                                      tc_HighByte=gc_PlayRecordDataBuf[tw_ByteOffset];
                                      tc_LowByte=gc_PlayRecordDataBuf[tw_ByteOffset+1];
                              }
                              else /*if(tc_HighByte & 0x80)*/
                              {//if it is ASCII,convert high byte to unicode
                                      tc_LowByte=tc_HighByte;
                                      tc_HighByte=0;
                                      tc_TwoByteFlag=0;
                              }
                      }//end of if(tbt_UnicodeOrISN)
                      //--------------------------------------------------------------------
                      // according to unicode,find the zk bmp data
                      //--------------------------------------------------------------------
              
                      tw_unicode=(tc_HighByte<<8)|tc_LowByte;
                      //read table 
                      LCM_UNICODE_READ_HZK_SECTOR(D_font_sector/*gw_font_sector*/);
                      
                      tw_tmp=(U16)(tc_HighByte)<<1;
                      tw_ByteOffset=*(U16 *)(&gc_PlayRecordDataBuf[tw_tmp]);
                      tw_OffsetSector=tw_ByteOffset+D_font_sector+(tc_LowByte/16); //538;
                      LCM_UNICODE_READ_HZK_SECTOR(tw_OffsetSector);
                      tw_ByteOffset=((U16)(tc_LowByte&0x0F))<<5;      
                      p=&(gc_PlayRecordDataBuf[tw_ByteOffset]); 
              
                      if((p[16]==0xAA)&&(p[17]==0xBB))
                      {
                              tc_ValidColumn=8;
                              tc_Loop=16;
                      }
                      else
                      {
                              tc_ValidColumn=16;
                              tc_Loop=32;     
                      }
              
                      do 
                      {
                              *tc_BmpBuf++=*p++;//get one byte
                      } while (--tc_Loop);
              
              
                      return tc_TwoByteFlag|tc_ValidColumn;
              }
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    647    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
