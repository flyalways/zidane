C51 COMPILER V9.00   DOSCOMM                                                               07/09/2012 21:16:46 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DOSCOMM
OBJECT MODULE PLACED IN .\obj\dosComm.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE DOS\dosComm.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource\hea
                    -der) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\dosComm.lst) OBJECT(.\obj\dosComm.obj)

line level    source

   1          #include <string.h>
   2          #include "..\header\SPDA2K.h"
   3          #include "..\header\Rambase.h"
   4          #include "..\header\variables.h"
   5          
   6          
   7          U32 DOS_GetNextCluster(U32 tdw_CurrentCluster,U32 tdw_ClusterNumber)
   8          {
   9   1              data    U16     tw_WordOffset;
  10   1              xdata   U32     tdw_ClusterNumCounter;
  11   1              xdata   U32     tdw_fatOffset;
  12   1              xdata   U32     tdw_DOS_FatSize;
  13   1              
  14   1              tdw_ClusterNumCounter=0;
  15   1              gb_ReadWriteDataArea=1;
  16   1              if(tdw_CurrentCluster<2)
  17   1              {//for rootdir
  18   2                      return(0xffffffff);     
  19   2              }
  20   1              
  21   1              if (tdw_ClusterNumber == 0) 
  22   1              {
  23   2                      return tdw_CurrentCluster;
  24   2              }
  25   1                                      
  26   1              tdw_fatOffset=tdw_CurrentCluster<<gc_DOS_FileSystemType;//fat16 or fat32        
  27   1              for(tdw_DOS_FatSize=(tdw_fatOffset>>9);tdw_DOS_FatSize<(gdw_DOS_SectorPerFAT*gc_HostSectorUnit);tdw_DOS_F
             -atSize++)//(JC)search sectors in FAT from current cluster sector to FAT end
  28   1              {//find in fat
  29   2                      if(DOS_Read_LogicSector(gdw_DOS_Fat1Addr+tdw_DOS_FatSize)==0)
  30   2                      {                       
  31   3                              while((tdw_fatOffset>>9)==tdw_DOS_FatSize)
  32   3                              {
  33   4                                      tw_WordOffset=tdw_fatOffset&0x1FF;
  34   4                                      if(gc_DOS_FileSystemType==1)
  35   4                                      {//FAT16
  36   5                                              if(tdw_CurrentCluster>=0xfff8)
  37   5                                              {                                               
  38   6                                                      return(0xffffffff);
  39   6                                              }                                       
  40   5                                              tdw_CurrentCluster=(((U32)gc_UserDataBuf[tw_WordOffset+1]<<8))|(U32)gc_UserDataBuf[tw_WordOffset];
  41   5                                      }
  42   4                                      else if(gc_DOS_FileSystemType==2)
  43   4                                      {//fat32                                
  44   5                                              if(tdw_CurrentCluster>=0x0ffffff8)
  45   5                                              {                       
  46   6                                                      return(0xffffffff);
  47   6                                              }
  48   5              
  49   5                                              ((U8 *)(&tdw_CurrentCluster))[0]=gc_UserDataBuf[tw_WordOffset+3];
  50   5                                              ((U8 *)(&tdw_CurrentCluster))[1]=gc_UserDataBuf[tw_WordOffset+2];
  51   5                                              ((U8 *)(&tdw_CurrentCluster))[2]=gc_UserDataBuf[tw_WordOffset+1];
  52   5                                              ((U8 *)(&tdw_CurrentCluster))[3]=gc_UserDataBuf[tw_WordOffset]; 
  53   5                                              tdw_CurrentCluster &= 0x0FFFFFFF;
C51 COMPILER V9.00   DOSCOMM                                                               07/09/2012 21:16:46 PAGE 2   

  54   5                                      }
  55   4                                      tdw_fatOffset = tdw_CurrentCluster<< gc_DOS_FileSystemType;
  56   4                                      tdw_ClusterNumCounter++;
  57   4      
  58   4                                      if(gc_CurrentCard==2)  //if SD not exist return DOS_CLUSTER_LINK_ERR chiayen0813
  59   4                                      {
  60   5                                              if(gb_SD_pin)
  61   5                                              {
  62   6                                                      return(0xffffffff);             
  63   6                                              }
  64   5                                      }
  65   4      
  66   4                                      if((gc_CurrentCard==5) && (gb_HostConnect == 0))  //if Host not exist return DOS_CLUSTER_LINK_ERR chia
             -yen 20081017
  67   4                                      {
  68   5                                              return(0xffffffff);             
  69   5                                      }
  70   4      
  71   4                                      if(tdw_ClusterNumCounter==tdw_ClusterNumber)
  72   4                                      {               
  73   5                                              return(tdw_CurrentCluster);
  74   5                                      }
  75   4                              }
  76   3                      }
  77   2                      else
  78   2                      {
  79   3                              return(0xffffffff);
  80   3                      }       
  81   2              }
  82   1      }
  83          
  84          
  85          U32 DOS_ClusterLogicAddr(U32 tdw_Cluster)
  86          {       
  87   1              data    U32 tdw_LogicAddr;
  88   1      
  89   1              if(tdw_Cluster==0)
  90   1              {       //maybe Root dir
  91   2                      if(gc_DOS_FileSystemType==2)
  92   2                      {//FAT32 cluster can not be 0
  93   3                              tdw_LogicAddr=0;//mark error
  94   3                      }
  95   2                      else
  96   2                      {//FAT12&FAT16 root dir
  97   3                              tdw_LogicAddr=gdw_DOS_RootDirAddr;
  98   3                      }
  99   2              }
 100   1              else if(tdw_Cluster==1)
 101   1              {       //cluster is disable to be 1
 102   2                      //when cluster is 1,error is occur      
 103   2                      tdw_LogicAddr = 0;
 104   2              }
 105   1              else
 106   1              {//normal state
 107   2                      tdw_LogicAddr=gdw_DOS_DataAddr+((tdw_Cluster-2)*gc_DOS_SectorPerCluster*gc_HostSectorUnit);
 108   2              }
 109   1      
 110   1              return tdw_LogicAddr;
 111   1      }
 112          
 113          
 114          U8 DOS_Read_LogicSector(U32 tdw_LogicSectorAddr)
C51 COMPILER V9.00   DOSCOMM                                                               07/09/2012 21:16:46 PAGE 3   

 115          {
 116   1              xdata   U8      tc_Status;
 117   1              xdata   U8      tc_BufIndex;
 118   1              xdata   U32 tdw_tempLogicSectorAddr;
 119   1      
 120   1              switch(gc_CurrentCard)
 121   1              {
 122   2                      case 2:
 123   2                      if(gb_ReadWriteDataArea==0)
 124   2                              {
 125   3                                      tc_BufIndex=gc_PlayRecordDataBufHB;
 126   3                              }
 127   2                              else
 128   2                              {
 129   3                                      tc_BufIndex=gc_UserDataBufHB;
 130   3                              }
 131   2                              
 132   2                              tdw_tempLogicSectorAddr=tdw_LogicSectorAddr;                    
 133   2                              SD_Read_LBA_Dos(tdw_LogicSectorAddr,tc_BufIndex);
 134   2      
 135   2                              if(gb_SD_pin)  //if SD not exist return false
 136   2                              {
 137   3                                      tc_Status=1;
 138   3                              }
 139   2                              else
 140   2                              {
 141   3                                      tc_Status=0;
 142   3                              }
 143   2                      break;
 144   2      
 145   2              case 5:
 146   2                              HOST_Read_Logicsector(tdw_LogicSectorAddr);
 147   2                              if(gb_HostConnect==0)
 148   2                              {
 149   3                                      tc_Status=1;            
 150   3                              }
 151   2                              else
 152   2                              {
 153   3                                      tc_Status=0;    
 154   3                              }
 155   2                      break;
 156   2              }
 157   1              return tc_Status;
 158   1      }
 159          
 160          
 161          U8 DOS_Read_File(U8 tc_FileHandle)
 162          {
 163   1              xdata   U8      tc_ResidueSector;
 164   1              xdata   U32     tdw_DataPoint;
 165   1      
 166   1              if(gs_File_FCB[tc_FileHandle].dw_File_StartCluster==0xffffffff)
 167   1              {
 168   2                      return DOS_STARTCLUSTER_ERR;
 169   2              }
 170   1      
 171   1              if(gs_File_FCB[tc_FileHandle].dw_File_DataPoint<gs_File_FCB[tc_FileHandle].dw_File_TotalSize)
 172   1              {//not at file end.
 173   2                      tc_ResidueSector=(gs_File_FCB[tc_FileHandle].dw_File_DataPoint>>9)&(gc_DOS_SectorPerCluster*gc_HostSecto
             -rUnit-1);
 174   2                      if((tc_ResidueSector==0)&&(gs_File_FCB[tc_FileHandle].dw_File_DataPoint!=0))
 175   2                      {//next cluster.
C51 COMPILER V9.00   DOSCOMM                                                               07/09/2012 21:16:46 PAGE 4   

 176   3                              gs_File_FCB[tc_FileHandle].dw_File_CurrentCluster=DOS_GetNextCluster(gs_File_FCB[tc_FileHandle].dw_File
             -_CurrentCluster,1);
 177   3                              if(gs_File_FCB[tc_FileHandle].dw_File_CurrentCluster==0xffffffff)
 178   3                              {
 179   4                                      return DOS_CLUSTER_LINK_ERR;
 180   4                              }
 181   3                      }
 182   2                      tdw_DataPoint=DOS_ClusterLogicAddr(gs_File_FCB[tc_FileHandle].dw_File_CurrentCluster)+tc_ResidueSector;
 183   2                      gb_ReadWriteDataArea=0;
 184   2                      gs_File_FCB[tc_FileHandle].dw_File_DataPoint+=512;
 185   2                      return (DOS_Read_LogicSector(tdw_DataPoint));
 186   2              }
 187   1              else
 188   1              {
 189   2                      return DOS_END_OF_FILE;
 190   2              }
 191   1      }
 192          
 193          U8 DOS_Write_LogicSector(U32 tdw_LogicSectorAddr,U8 tc_AppendW)
 194          {
 195   1              if(gc_CurrentCard==2)
 196   1              {
 197   2                      SD_Write_LBA_Dos(tdw_LogicSectorAddr,tc_AppendW);
 198   2              }
 199   1              else if(gc_CurrentCard==5)
 200   1              {
 201   2                      Host_Write_LBA_Dos(tdw_LogicSectorAddr,tc_AppendW);
 202   2              }
 203   1      
 204   1              return 0;
 205   1      }
*** WARNING C291 IN LINE 82 OF DOS\DOSCOMM.C: not every exit path returns a value


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1017    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      45
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
