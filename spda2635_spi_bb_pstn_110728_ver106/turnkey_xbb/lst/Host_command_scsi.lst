C51 COMPILER V9.00   HOST_COMMAND_SCSI                                                     07/09/2012 21:16:47 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE HOST_COMMAND_SCSI
OBJECT MODULE PLACED IN .\obj\Host_command_scsi.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Host\Host_command_scsi.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\li
                    -bsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\Host_command_scsi.lst) OBJECT(.\obj\Host_command_sc
                    -si.obj)

line level    source

   1          #include "..\header\SPDA2K.h"
   2          #include "..\header\host_init.h"
   3          #include "..\header\variables.h"
   4          
   5          #define HostDMAtoHOSTBUFFER     1               // 1K/2K sector一次讀取
   6          #define HOSTBUFFER                      0x90
   7          
   8          
   9          U8 HOST_Read_Logicsector(U32 tdw_LogicSectorAddr)
  10          {
  11   1              data    U8      x;
  12   1              xdata   U8      j;
  13   1              xdata   U8      *buffer;
  14   1      
  15   1              if(gb_ReadWriteDataArea==0)     
  16   1              {
  17   2                      buffer=gc_PlayRecordDataBuf;
  18   2              } 
  19   1              else
  20   1              {
  21   2                      buffer=gc_UserDataBuf;
  22   2              }
  23   1      
  24   1      #if HostDMAtoHOSTBUFFER==1
  25   1              if((tdw_LogicSectorAddr>=gdw_HOSTStartSectorRead)&&(tdw_LogicSectorAddr<=(gdw_HOSTStartSectorRead+gc_Host
             -SectorUnit-1)))
  26   1              {
  27   2                      x=tdw_LogicSectorAddr-gdw_HOSTStartSectorRead;
  28   2                      XBYTE[0xB301]=0x00;        //DMA src: MCU Data SRAM;  dst: DSP DM
  29   2                      XBYTE[0xB302]=0xFF;
  30   2                      XBYTE[0xB303]=0x01;
  31   2                      XBYTE[0xB112]=0x00;
  32   2                      XBYTE[0xB113]=HOSTBUFFER+2*x;
  33   2                      XBYTE[0xB114]=(U16)buffer;
  34   2                      XBYTE[0xB115]=(U16)buffer>>8;
  35   2                      XBYTE[0xB3B0]=0x01;
  36   2                      while(!(XBYTE[0xB3C0]&0x01));
  37   2                      XBYTE[0xB3C0]=0x00;
  38   2                      return 0;
  39   2              }
  40   1              else
  41   1              {
  42   2                      gdw_HOSTStartSectorRead=tdw_LogicSectorAddr;
  43   2              }
  44   1      #endif
  45   1              gc_HostUnitNum=tdw_LogicSectorAddr%gc_HostSectorUnit;
  46   1              tdw_LogicSectorAddr=tdw_LogicSectorAddr/gc_HostSectorUnit;
  47   1      
  48   1              gb_HostError=0;
  49   1              j = HOST_Readsector(tdw_LogicSectorAddr,buffer);        //read one sector       
  50   1              if(j != 0)              
  51   1              {
  52   2                      if(j==HOST_SCSICMD_MEDIACHANGED)
C51 COMPILER V9.00   HOST_COMMAND_SCSI                                                     07/09/2012 21:16:47 PAGE 2   

  53   2                      {
  54   3                              return HOST_SCSICMD_MEDIACHANGED;
  55   3                      }
  56   2              else if(j==3)
  57   2                      {
  58   3                              gb_HostError=1;
  59   3                              return 3;
  60   3                      }
  61   2              }
  62   1      
  63   1              return 0;
  64   1      }
  65          
  66          
  67          U8 HOST_Readsector(U32 SectorAddr,U8 *buffer)
  68          {
  69   1              code    U8      CBW[31]={0x55,0x53,0x42,0x43,0x01,0x02,0x66,0x01,0x00,0x02,0x00,0x00,0x80,0x00,0x0A,0x28,0x00,0x0
             -0,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
  70   1              data    U8      i;
  71   1              data    U8      j;
  72   1              data    U8      tc_state;
  73   1              data    U8      tc_RetryCount;
  74   1              xdata   U16     tw_Offset;
  75   1              xdata   U16     k;
  76   1      
  77   1              // Prepare CBW data
  78   1              for(i=0;i<31;i++)               
  79   1              {
  80   2                      XBYTE[HOST_BUF_SA+i]=CBW[i];
  81   2              }
  82   1              XBYTE[HOST_BUF_SA+7]=gc_CBWTag++;
  83   1              XBYTE[HOST_BUF_SA+9]=gc_HostSectorUnit*2;
  84   1              XBYTE[HOST_BUF_SA+17]=(U8)(SectorAddr>>24);
  85   1              XBYTE[HOST_BUF_SA+18]=(U8)(SectorAddr>>16);
  86   1              XBYTE[HOST_BUF_SA+19]=(U8)(SectorAddr>>8);
  87   1              XBYTE[HOST_BUF_SA+20]=(U8)(SectorAddr>>0);
  88   1      
  89   1              // OUT CBW
  90   1              tc_RetryCount=0;
  91   1              while(1)
  92   1              {
  93   2                      tc_RetryCount++;
  94   2                      if(tc_RetryCount>5)
  95   2                      {
  96   3                              return 1;
  97   3                      }
  98   2      
  99   2                      tran_out(gc_HostDeviceAddress,31);
 100   2                      tc_state=Host_phy_Command_check();
 101   2                      if(gb_HostConnect == 0) 
 102   2                      {
 103   3                              return HOST_PHYCOUNECT_FAIL;
 104   3                      }
 105   2                      if((tc_state==HOST_TEST_ERROR)||(tc_state==HOST_TimeOut_ERROR)||(tc_state==HOST_TEST_ERROR1))
 106   2                      {
 107   3                              gb_dtg_out=(!gb_dtg_out);               
 108   3                      }
 109   2                      else if(tc_state!=0) 
 110   2                      {
 111   3                              gb_HostConnect=0; 
 112   3                              return HOST_SCSICMD_MEDIUMNOTPRESENT;
 113   3                      }
C51 COMPILER V9.00   HOST_COMMAND_SCSI                                                     07/09/2012 21:16:47 PAGE 3   

 114   2                      else
 115   2                      {
 116   3                              break;
 117   3                      }
 118   2              }
 119   1      
 120   1              tw_Offset=0;
 121   1              // maxliao 20070116 - For My Disk(U-disk) and Action MP3 player can't access 
 122   1              if(gw_HostVID==0x10D6)
 123   1              {
 124   2                      XBYTE[0xB01C]|=0x20;    //Non Auto Ack in for action mp3 player
 125   2              }
 126   1              delay(1000);
 127   1              while(1)
 128   1              {
 129   2                      tran_in_(gc_HostDeviceAddress,64,tw_Offset);
 130   2                      tc_state=Host_phy_Command_check_(tw_Offset,gb_dtg_in);
 131   2                      if(tc_state==0)
 132   2                      {
 133   3                              break;
 134   3                      }
 135   2                      if(gb_HostConnect == 0) 
 136   2                      {
 137   3                              return HOST_PHYCOUNECT_FAIL;
 138   3                      }
 139   2                      if(tc_state==HOST_STALL)
 140   2                      {
 141   3                              gb_dtg_in=0;
 142   3                              ClearFeature(gc_HostDeviceAddress,0,gc_Host_EPIN,0);
 143   3                              tran_in(gc_HostDeviceAddress,13,tw_Offset);
 144   3                              tc_state=Host_phy_Command_check();
 145   3              
 146   3                              if(tc_state!=0) // 20080620
 147   3                              {
 148   4                                      return tc_state;
 149   4                              }                           
 150   3                              SCSICMD_03_REQUESTSENSE();
 151   3                              return 1;
 152   3                      }
 153   2      
 154   2                      k=0;
 155   2                      if(tc_state==HOST_TEST_ERROR)
 156   2                      {
 157   3                              k++;
 158   3                              if(k>12)
 159   3                              {
 160   4                                      return 3;
 161   4                              }
 162   3                      }
 163   2              }
 164   1      
 165   1              // maxliao 20070116 - For My Disk(U-disk) and Action MP3 player can't access 
 166   1              XBYTE[0xB01C]&=0xdf; //Auto Ack in
 167   1      
 168   1              gb_dtg_in=!gb_dtg_in;
 169   1              tw_Offset=64;
 170   1                      
 171   1              if(tc_state==0)
 172   1              {
 173   2                      for(j=0;j<gc_HostSectorUnit;j++)
 174   2                      {
 175   3                              if(j==0)
C51 COMPILER V9.00   HOST_COMMAND_SCSI                                                     07/09/2012 21:16:47 PAGE 4   

 176   3                              {
 177   4                                      i=1;
 178   4                              }
 179   3                              else
 180   3                              {
 181   4                                      i=0;
 182   4                                      tw_Offset=0;
 183   4                              }
 184   3      
 185   3                              for(;i<8;i++)
 186   3                              {
 187   4                                      if(gb_HostConnect == 0) 
 188   4                                      {
 189   5                                              return HOST_PHYCOUNECT_FAIL;
 190   5                                      }
 191   4      
 192   4                                      XBYTE[0xB604]=tw_Offset&0xFF;
 193   4                                      XBYTE[0xB605]=(tw_Offset>>8)+(HOST_BUF_SA>>8);
 194   4      
 195   4                                      tc_RetryCount=0;
 196   4                                      while(1)
 197   4                                      {       
 198   5                                              tc_RetryCount++;
 199   5                                              if(tc_RetryCount>5)
 200   5                                              {
 201   6                                                      return 1;
 202   6                                              }
 203   5      
 204   5                                              if(gb_dtg_in == 0) 
 205   5                                              {
 206   6                                                      XBYTE[0xB601]=0x91;
 207   6                                              }
 208   5                                              else
 209   5                                              {
 210   6                                                      XBYTE[0xB601]=0x93;
 211   6                                              }
 212   5                                              tc_state=Host_phy_Command_check();
 213   5                                              if(tc_state==0)
 214   5                                              {
 215   6                                                      break;
 216   6                                              }
 217   5                                              else
 218   5                                              {
 219   6                                                      return 1;
 220   6                                              }
 221   5                                      }
 222   4      
 223   4                                      gb_dtg_in = (!gb_dtg_in);
 224   4                                      tw_Offset+=64;  
 225   4                              }
 226   3      
 227   3                              XBYTE[0xB301]=0x00;        //DMA src: MCU Data SRAM;  dst: DSP DM
 228   3                              XBYTE[0xB302]=0xFF;
 229   3                              XBYTE[0xB303]=0x01;
 230   3                              XBYTE[0xB112]=0x00;
 231   3                              XBYTE[0xB113]=HOST_BUF_SA>>8;
 232   3                              XBYTE[0xB114]=0x00;
 233   3      
 234   3                              // 將指定Sector之512-byte資料DMA至指定buffer
 235   3                              if(j==gc_HostUnitNum)
 236   3                              {
 237   4                                      XBYTE[0xB115]=((U16)buffer)>>8;
C51 COMPILER V9.00   HOST_COMMAND_SCSI                                                     07/09/2012 21:16:47 PAGE 5   

 238   4                                      XBYTE[0xB3B0]=0x01;
 239   4                                      while(!(XBYTE[0xB3C0]&0x01));
 240   4                                      XBYTE[0xB3C0]=0x00;
 241   4                              }
 242   3      
 243   3                              #if HostDMAtoHOSTBUFFER==1
 244   3                              // 備份USB資料至0xA000~0xA7FF, 若下一次是同一Sector則直接DMA至destination buffer
 245   3                              XBYTE[0xB115]=HOSTBUFFER+2*j;
 246   3                              XBYTE[0xB3B0]=0x01;
 247   3                              while(!(XBYTE[0xB3C0]&0x01));
 248   3                              XBYTE[0xB3C0]=0x00;
 249   3                              #endif
 250   3                      }
 251   2      
 252   2                      // maxliao 20061205 - Enable SOF
 253   2                      XBYTE[0xB630]=1;
 254   2              }
 255   1              else if(tc_state & 0x10)
 256   1              {//stall
 257   2                      XBYTE[0xB630]=1;                                //enable SOF
 258   2                      gb_dtg_in = 0;          
 259   2                      ClearFeature(gc_HostDeviceAddress,0,gc_Host_EPIN,0);
 260   2      
 261   2                      tran_in_(gc_HostDeviceAddress,13,0);            //stored at HOST_BUF_SA 
 262   2                  tc_state=Host_phy_Command_check();
 263   2      
 264   2                      if(XBYTE[HOST_BUF_SA+12]==0x01)
 265   2                      {
 266   3                              tc_state=SCSICMD_03_REQUESTSENSE();
 267   3                              return 1;
 268   3                      }
 269   2              }
 270   1              
 271   1              // IN CSW
 272   1              if(gb_HostConnect == 0) 
 273   1              {
 274   2                      return HOST_PHYCOUNECT_FAIL;
 275   2              }
 276   1              
 277   1              for(i=0;i<20;i++)
 278   1              {
 279   2                      tran_in(gc_HostDeviceAddress,13,0);
 280   2                      tc_state=Host_phy_Command_check();
 281   2                      if((tc_state==0)&&(gb_HostShortPack==0))
 282   2                      {
 283   3                              break;
 284   3                      }
 285   2                      gb_dtg_in=(!gb_dtg_in);
 286   2              }
 287   1      
 288   1              if(tc_state!=0)
 289   1              {
 290   2                      return 0xff;    // fail
 291   2              }
 292   1      
 293   1              return 0;
 294   1      }
 295          
 296          
 297          void delay(U16  i)
 298          {
 299   1              while(i)   i--;
C51 COMPILER V9.00   HOST_COMMAND_SCSI                                                     07/09/2012 21:16:47 PAGE 6   

 300   1      }
 301          
 302          void Host_Write_LBA_Dos(U32 Write_LBA,U8 Write_Stage)
 303          {
 304   1              data    bit     tb_Host_CBW_Stage=0;
 305   1              data    bit     tb_Host_Data_Stage=0;
 306   1              data    bit     tb_Host_CSW_Stage=0;
 307   1              xdata   U8      i;
 308   1              xdata   U8      j;
 309   1              xdata   U8      tc_state;
 310   1              xdata   U16     tw_addr;
 311   1              code    U8      CBW[31]={0x55,0x53,0x42,0x43,0x01,0x02,0x66,0x01,0x00,0x02,0x00,0x00,0x00,0x00,0x0A,0x2A,0x00,0x0
             -0,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
 312   1      
 313   1              if(gb_ReadWriteDataArea==0)     
 314   1              {
 315   2                      tw_addr=gc_PlayRecordDataBuf;
 316   2              } 
 317   1              else
 318   1              {
 319   2                      tw_addr=gc_UserDataBuf;
 320   2              }
 321   1      
 322   1              switch(Write_Stage)
 323   1              {
 324   2                      case 0: // CBW+Data
 325   2                              tb_Host_CBW_Stage=1;
 326   2                              tb_Host_Data_Stage=1;
 327   2                              break;
 328   2                      case 1: // only data
 329   2                              tb_Host_Data_Stage=1;
 330   2                              break;
 331   2                      case 2: //data+CSW
 332   2                              tb_Host_Data_Stage=1;
 333   2                              tb_Host_CSW_Stage=1;    
 334   2                              break;
 335   2                      case 3:// CBW+512-byte data+CSW
 336   2                              tb_Host_CBW_Stage=1;
 337   2                              tb_Host_Data_Stage=1;
 338   2                              tb_Host_CSW_Stage=1;
 339   2                              break;
 340   2                      default:  // only CSW
 341   2                              tb_Host_CSW_Stage=1;
 342   2                              break;
 343   2              }
 344   1      
 345   1              if(tb_Host_CBW_Stage==1)
 346   1              {
 347   2                      // Prepare CBW data
 348   2                      for(i=0;i<31;i++)               
 349   2                      {
 350   3                              XBYTE[HOST_BUF_SA+i]=CBW[i];
 351   3                      }
 352   2                      XBYTE[HOST_BUF_SA+7]=gc_CBWTag++;
 353   2                      XBYTE[HOST_BUF_SA+9]=gc_HostSectorUnit*2;
 354   2                      if(Write_Stage==0)
 355   2                      {
 356   3                              XBYTE[HOST_BUF_SA+9]*=gc_DOS_SectorPerCluster;
 357   3                              XBYTE[HOST_BUF_SA+23]=gc_DOS_SectorPerCluster/gc_HostSectorUnit;
 358   3                      }
 359   2                      XBYTE[HOST_BUF_SA+17]=(U8)(Write_LBA>>24);
 360   2                      XBYTE[HOST_BUF_SA+18]=(U8)(Write_LBA>>16);
C51 COMPILER V9.00   HOST_COMMAND_SCSI                                                     07/09/2012 21:16:47 PAGE 7   

 361   2                      XBYTE[HOST_BUF_SA+19]=(U8)(Write_LBA>>8);
 362   2                      XBYTE[HOST_BUF_SA+20]=(U8)(Write_LBA>>0);
 363   2                      tran_out(gc_HostDeviceAddress,31);
 364   2                      tc_state=Host_phy_Command_check();
 365   2              }
 366   1      
 367   1              if(tb_Host_Data_Stage==1)
 368   1              {
 369   2                      for(i=0;i<8;i++)
 370   2                      {
 371   3                              XBYTE[0xB301]=0x00;
 372   3                              XBYTE[0xB112]=(U8)tw_addr;
 373   3                              XBYTE[0xB113]=(U8)(tw_addr>>8);
 374   3                              XBYTE[0xB114]=0x00;
 375   3                              XBYTE[0xB115]=HOST_BUF_SA>>8;
 376   3                              XBYTE[0xB3B0]=0x01;
 377   3                              while(!(XBYTE[0xB3C0]&0x01));
 378   3                              XBYTE[0xB3C0]=0x00;
 379   3                              tran_out(gc_HostDeviceAddress,64);
 380   3                              j=0;
 381   3                              while(1)
 382   3                              {
 383   4                                      tc_state=Host_phy_Command_check();
 384   4                                      if(tc_state==0) 
 385   4                                      {
 386   5                                              break;
 387   5                                      }
 388   4                                      j++;
 389   4                                      if(j>50)
 390   4                                      {
 391   5                                              gc_CurrentCard=9;
 392   5                                              return;
 393   5                                      }
 394   4                              }
 395   3                              tw_addr+=64;
 396   3                      }
 397   2              }
 398   1      
 399   1              if(tb_Host_CSW_Stage==1)
 400   1              {
 401   2                      tran_in(gc_HostDeviceAddress,13,0);
 402   2                      while(1)
 403   2                      {
 404   3                              tc_state=Host_phy_Command_check();
 405   3                              if(tc_state==0||gb_HostConnect==0)
 406   3                              {
 407   4                                      break;
 408   4                              }
 409   3                      }
 410   2              }
 411   1      }
 412          
 413                           


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1321    ----
   CONSTANT SIZE    =     62    ----
   XDATA SIZE       =   ----      28
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       5
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.00   HOST_COMMAND_SCSI                                                     07/09/2012 21:16:47 PAGE 8   

   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
