; .\obj\L51_BankingLoader.SRC generated from: ASM\L51_BankingLoader.c
; COMPILER INVOKED BY:
;        C:\Keil\C51\BIN\C51.EXE ASM\L51_BankingLoader.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\L51_BankingLoader.lst) SRC(.\obj\L51_BankingLoader.SRC)

$NOMOD51

NAME	L51_BANKINGLOADER

ACC7	BIT	0E0H.7
P0	DATA	080H
P1	DATA	090H
P2	DATA	0A0H
P3	DATA	0B0H
T0	BIT	0B0H.4
AC	BIT	0D0H.6
T1	BIT	0B0H.5
EA	BIT	0A8H.7
IE	DATA	0A8H
EXF2	BIT	0C8H.6
RD	BIT	0B0H.7
ES	BIT	0A8H.4
IP	DATA	0B8H
RI	BIT	098H.0
INT0	BIT	0B0H.2
CY	BIT	0D0H.7
TI	BIT	098H.1
INT1	BIT	0B0H.3
RamPage	DATA	09BH
RCAP2H	DATA	0CBH
PS	BIT	0B8H.4
SP	DATA	081H
OV	BIT	0D0H.2
RCAP2L	DATA	0CAH
C_T2	BIT	0C8H.1
WR	BIT	0B0H.6
RCLK	BIT	0C8H.5
TCLK	BIT	0C8H.4
SBUF	DATA	099H
PCON	DATA	087H
SCON	DATA	098H
TMOD	DATA	089H
TCON	DATA	088H
IE0	BIT	088H.1
IE1	BIT	088H.3
B	DATA	0F0H
CP_RL2	BIT	0C8H.0
ACC	DATA	0E0H
ET0	BIT	0A8H.1
ET1	BIT	0A8H.3
TF0	BIT	088H.5
ET2	BIT	0A8H.5
TF1	BIT	088H.7
TF2	BIT	0C8H.7
RB8	BIT	098H.2
TH0	DATA	08CH
EX0	BIT	0A8H.0
IT0	BIT	088H.0
TH1	DATA	08DH
TB8	BIT	098H.3
EX1	BIT	0A8H.2
IT1	BIT	088H.2
TH2	DATA	0CDH
P	BIT	0D0H.0
SM0	BIT	098H.7
TL0	DATA	08AH
SM1	BIT	098H.6
TL1	DATA	08BH
SM2	BIT	098H.5
TL2	DATA	0CCH
SD_Detect	BIT	090H.1
PT0	BIT	0B8H.1
PT1	BIT	0B8H.3
RS0	BIT	0D0H.3
PT2	BIT	0B8H.5
TR0	BIT	088H.4
RS1	BIT	0D0H.4
TR1	BIT	088H.6
TR2	BIT	0C8H.2
PX0	BIT	0B8H.0
PX1	BIT	0B8H.2
DPH	DATA	083H
DPL	DATA	082H
EXEN2	BIT	0C8H.3
REN	BIT	098H.4
T2CON	DATA	0C8H
RXD	BIT	0B0H.0
CKCON	DATA	08EH
TXD	BIT	0B0H.1
F0	BIT	0D0H.5
ACC0	BIT	0E0H.0
ACC1	BIT	0E0H.1
ACC2	BIT	0E0H.2
ACC3	BIT	0E0H.3
PSW	DATA	0D0H
ACC4	BIT	0E0H.4
ACC5	BIT	0E0H.5
ACC6	BIT	0E0H.6
?PR?perform_nand_bank_call?L51_BANKINGLOADER SEGMENT CODE 
?PR?return_from_nand_bank?L51_BANKINGLOADER SEGMENT CODE 
?PR?load_nand_bank?L51_BANKINGLOADER     SEGMENT CODE 
?XD?load_nand_bank?L51_BANKINGLOADER     SEGMENT XDATA OVERLAYABLE 
?PR?_SPI_Load_Code_To_DRAM?L51_BANKINGLOADER SEGMENT CODE 
?XD?_SPI_Load_Code_To_DRAM?L51_BANKINGLOADER SEGMENT XDATA OVERLAYABLE 
?BI?_SPI_Load_Code_To_DRAM?L51_BANKINGLOADER SEGMENT BIT OVERLAYABLE 
?DT?_SPI_Load_Code_To_DRAM?L51_BANKINGLOADER SEGMENT DATA OVERLAYABLE 
?PR?L51_BANKINGLOADER                    SEGMENT CODE 
	EXTRN	XDATA (gc_ProgRAM_Index)
	EXTRN	CODE (SET_DEVICE_READ_TO_DRAM)
	EXTRN	XDATA (gc_SPI_Addr1)
	EXTRN	XDATA (gc_SPI_Addr2)
	EXTRN	DATA (gc_bank_number)
	EXTRN	DATA (gc_clock_mode)
	EXTRN	CODE (_set_clock_mode)
	EXTRN	CODE (Trigger_Data_Transfer_Done)
	EXTRN	CODE (_SPI_Send_Byte)
	EXTRN	BIT (gb_ReloadProgram)
	EXTRN	CODE (?C?IMUL)
	PUBLIC	_SPI_Load_Code_To_DRAM
	PUBLIC	load_nand_bank
	PUBLIC	return_from_nand_bank
	PUBLIC	perform_nand_bank_call

	RSEG  ?XD?load_nand_bank?L51_BANKINGLOADER
?load_nand_bank?BYTE:
   tc_clock?240:   DS   1
	ORG  1
    tc_B400?241:   DS   1
	ORG  2
    tw_addr?242:   DS   2

	RSEG  ?XD?_SPI_Load_Code_To_DRAM?L51_BANKINGLOADER
?_SPI_Load_Code_To_DRAM?BYTE:
   u_Seccnt?343:   DS   1

	RSEG  ?BI?_SPI_Load_Code_To_DRAM?L51_BANKINGLOADER
?_SPI_Load_Code_To_DRAM?BIT:
   tc_Retry?345:   DBIT   1

	RSEG  ?DT?_SPI_Load_Code_To_DRAM?L51_BANKINGLOADER
          i?344:   DS   1
; #include <stdio.h>
; #include "..\header\SPDA2K.h"
; #include "..\header\variables.h"
; 
; 
; //! Entry of the banking loader.

	RSEG  ?PR?L51_BANKINGLOADER
Com0019:
L?0026:
	USING	3
	MOV  	DPTR,#0B400H
	MOVX 	A,@DPTR
	ORL  	A,#020H
	MOVX 	@DPTR,A
	MOV  	A,#04H
	MOVX 	@DPTR,A
	RET  	
; END OF Com0019

; void perform_nand_bank_call(void)

	RSEG  ?PR?perform_nand_bank_call?L51_BANKINGLOADER
perform_nand_bank_call:
	USING	0
			; SOURCE LINE # 7
; {
			; SOURCE LINE # 8
; #pragma asm
; 	cjne A, gc_bank_number, ?_need_to_load_nand_bank
	  cjne A, gc_bank_number, ?_need_to_load_nand_bank
; 	push DPL
	  push DPL
; 	push DPH
	  push DPH
; 	ret
	  ret
; 
	  
; ?_need_to_load_nand_bank:
	  ?_need_to_load_nand_bank:
; 	//Target Bank Number is in register A
	  
; 	push gc_bank_number
	  push gc_bank_number
; 	mov  gc_bank_number, A
	  mov  gc_bank_number, A
; 
	  
; 	//push the bank recover function for returning use
	  
; 	mov  A, #LOW return_from_nand_bank
	  mov  A, #LOW return_from_nand_bank
; 	push ACC
	  push ACC
; 	mov  A, #HIGH return_from_nand_bank
	  mov  A, #HIGH return_from_nand_bank
; 	push ACC
	  push ACC
; 	//push target address
	  
; 	push DPL
	  push DPL
; 	push DPH
	  push DPH
;  	//push PSW and IE
	  
; 	push PSW
	  push PSW
; 	mov  PSW, #18	//use register bank3
	  mov  PSW, #18	 
; 	push IE
	  push IE
; 	clr  EA			//disable IRQ
	  clr  EA			 
; 
	  
; 	call load_nand_bank
	  call load_nand_bank
; 
	  
; 	//recover IE and PSW
	  
; 	pop  IE
	  pop  IE
; 	pop  PSW
	  pop  PSW
; 	ret
	  ret
; #pragma endasm
; }
			; SOURCE LINE # 41
	RET  	
; END OF perform_nand_bank_call

; 
; //! Exit of the banking loader.
; void return_from_nand_bank(void)

	RSEG  ?PR?return_from_nand_bank?L51_BANKINGLOADER
return_from_nand_bank:
	USING	0
			; SOURCE LINE # 44
; {
			; SOURCE LINE # 45
; #pragma asm
; 	mov  A, gc_bank_number	//A is current bank
	  mov  A, gc_bank_number	 
; 	pop  gc_bank_number		//gc_bank_number is return bank
	  pop  gc_bank_number		 
; 	push PSW
	  push PSW
; 	cjne A, gc_bank_number, ?_recover_need_load_nand
	  cjne A, gc_bank_number, ?_recover_need_load_nand
; 	pop PSW
	  pop PSW
; 	ret
	  ret
; ?_recover_need_load_nand:
	  ?_recover_need_load_nand:
; 	mov  PSW, #18 			//use register bank3
	  mov  PSW, #18 			 
; 	push IE
	  push IE
; 	clr  EA					//disable IRQ
	  clr  EA					 
; 
	  
; 	call load_nand_bank
	  call load_nand_bank
; 
	  
; 	//pop PSW and IE
	  
; 	pop  IE
	  pop  IE
; 	pop  PSW
	  pop  PSW
; 	ret
	  ret
; #pragma endasm
; }
			; SOURCE LINE # 65
	RET  	
; END OF return_from_nand_bank

; 
; //! NAND banking loader.
; #define SECTORS_PER_BANK  	24		// 12K
; #define	BANK0_START_ADDR	0x60	// 24K
; #define	BANK1_START_ADDR	0xC0	// 48K
; #define	BANK_SIZE			0x30	// 12K
; 
; 
; void load_nand_bank(void) using 3

	RSEG  ?PR?load_nand_bank?L51_BANKINGLOADER
load_nand_bank:
	USING	3
	PUSH 	PSW
	MOV  	PSW,#018H
			; SOURCE LINE # 74
; {
; 	xdata	U8	tc_clock;
; 	xdata	U8	tc_B400;
; 	xdata	U16	tw_addr;
;  
; 	tc_clock=gc_clock_mode;
			; SOURCE LINE # 80
	MOV  	DPTR,#tc_clock?240
	MOV  	A,gc_clock_mode
	MOVX 	@DPTR,A
; 	set_clock_mode(CLOCK_MODE_SPI);
			; SOURCE LINE # 81
	MOV  	R7,#05H
	LCALL	_set_clock_mode
; 	tc_B400=XBYTE[0xB400]; 
			; SOURCE LINE # 82
	MOV  	DPTR,#0B400H
	MOVX 	A,@DPTR
	MOV  	DPTR,#tc_B400?241
	MOVX 	@DPTR,A
;          
; 	if (gc_bank_number == 0)
			; SOURCE LINE # 84
	MOV  	A,gc_bank_number
	JNZ  	?C0003
; 	{
			; SOURCE LINE # 85
; 		tw_addr=BANK0_START_ADDR;
			; SOURCE LINE # 86
	INC  	DPTR
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,#060H
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 87
	SJMP 	?C0004
?C0003:
; 	else
; 	{
			; SOURCE LINE # 89
; 		tw_addr=BANK1_START_ADDR+(gc_bank_number-1)*BANK_SIZE;
			; SOURCE LINE # 90
	MOV  	R7,gc_bank_number
	MOV  	R6,#00H
	MOV  	R4,#00H
	MOV  	R5,#030H
	LCALL	?C?IMUL
	MOV  	A,R7
	ADD  	A,#090H
	MOV  	R7,A
	CLR  	A
	ADDC 	A,R6
	MOV  	DPTR,#tw_addr?242
	MOVX 	@DPTR,A
	INC  	DPTR
	MOV  	A,R7
	MOVX 	@DPTR,A
; 	}
			; SOURCE LINE # 91
?C0004:
; 
; 	//dbprintf("%bx ",gc_bank_number); 
; 
; 	//reset spi interface 
; 	XBYTE[0xB400]|=0x20;
			; SOURCE LINE # 96
; 	XBYTE[0xB400]=0x04; 
			; SOURCE LINE # 97
	LCALL	L?0026
?C0005:
; 	while(1)
			; SOURCE LINE # 98
; 	{
			; SOURCE LINE # 99
; 		gc_SPI_Addr1=(U8)(tw_addr);
			; SOURCE LINE # 100
	MOV  	DPTR,#tw_addr?242
	MOVX 	A,@DPTR
	MOV  	R6,A
	INC  	DPTR
	MOVX 	A,@DPTR
	MOV  	DPTR,#gc_SPI_Addr1
	MOVX 	@DPTR,A
; 		gc_SPI_Addr2=(U8)(tw_addr>>8);
			; SOURCE LINE # 101
	MOV  	A,R6
	MOV  	DPTR,#gc_SPI_Addr2
	MOVX 	@DPTR,A
; 		SPI_Load_Code_To_DRAM(SECTORS_PER_BANK);
			; SOURCE LINE # 102
	MOV  	R7,#018H
	LCALL	_SPI_Load_Code_To_DRAM
; 
; 		if(gb_ReloadProgram==0)
			; SOURCE LINE # 104
	JB   	gb_ReloadProgram,?C0007
; 		{
			; SOURCE LINE # 105
; 			break;
			; SOURCE LINE # 106
	SJMP 	?C0006
; 		}
			; SOURCE LINE # 107
?C0007:
; 		else
; 		{
			; SOURCE LINE # 109
; 			//reset spi interface 
; 			XBYTE[0xB400]|=0x20;
			; SOURCE LINE # 111
; 			XBYTE[0xB400]=0x04; 
			; SOURCE LINE # 112
	LCALL	L?0026
; 			gb_ReloadProgram=0;
			; SOURCE LINE # 113
	CLR  	gb_ReloadProgram
; 		}
			; SOURCE LINE # 114
; 	}
			; SOURCE LINE # 115
	SJMP 	?C0005
?C0006:
; 	set_clock_mode(tc_clock); 
			; SOURCE LINE # 116
	MOV  	DPTR,#tc_clock?240
	MOVX 	A,@DPTR
	MOV  	R7,A
	LCALL	_set_clock_mode
; 	XBYTE[0xB400]=tc_B400;
			; SOURCE LINE # 117
	MOV  	DPTR,#tc_B400?241
	MOVX 	A,@DPTR
	MOV  	DPTR,#0B400H
	MOVX 	@DPTR,A
; }
			; SOURCE LINE # 118
	POP  	PSW
	RET  	
; END OF load_nand_bank

; 
; 
; void SPI_Load_Code_To_DRAM(U8 u_Seccnt)

	RSEG  ?PR?_SPI_Load_Code_To_DRAM?L51_BANKINGLOADER
_SPI_Load_Code_To_DRAM:
	USING	0
			; SOURCE LINE # 121
	MOV  	DPTR,#u_Seccnt?343
	MOV  	A,R7
	MOVX 	@DPTR,A
; {
			; SOURCE LINE # 122
; 	data	U8	i;
; 	data	bit	tc_Retry=0;
			; SOURCE LINE # 124
	CLR  	tc_Retry?345
;   
; 	gc_ProgRAM_Index=BANK0_START_ADDR;
			; SOURCE LINE # 126
	MOV  	DPTR,#gc_ProgRAM_Index
	MOV  	A,#060H
	MOVX 	@DPTR,A
?C0010:
; 
;     while(u_Seccnt)
			; SOURCE LINE # 128
	MOV  	DPTR,#u_Seccnt?343
	MOVX 	A,@DPTR
	JZ   	?C0024
; 	{
			; SOURCE LINE # 129
;         SPI_ENABLE(); 
			; SOURCE LINE # 130
	MOV  	DPTR,#0BB18H
	MOVX 	A,@DPTR
	ANL  	A,#0FEH
	MOVX 	@DPTR,A
;         SPI_Send_Byte(0x03);  //CMD
			; SOURCE LINE # 131
	MOV  	R7,#03H
	LCALL	_SPI_Send_Byte
;         SPI_Send_Byte(gc_SPI_Addr2);  
			; SOURCE LINE # 132
	MOV  	DPTR,#gc_SPI_Addr2
	MOVX 	A,@DPTR
	MOV  	R7,A
	LCALL	_SPI_Send_Byte
;         SPI_Send_Byte(gc_SPI_Addr1);  
			; SOURCE LINE # 133
	MOV  	DPTR,#gc_SPI_Addr1
	MOVX 	A,@DPTR
	MOV  	R7,A
	LCALL	_SPI_Send_Byte
;         SPI_Send_Byte(0x00);  
			; SOURCE LINE # 134
	CLR  	A
	MOV  	R7,A
	LCALL	_SPI_Send_Byte
; 
; 		XBYTE[0xB304]=0x09;		//Reset DMA
			; SOURCE LINE # 136
	MOV  	DPTR,#0B304H
	MOV  	A,#09H
	MOVX 	@DPTR,A
; 		XBYTE[0xB304]=0x08;		//Normal DMA
			; SOURCE LINE # 137
	DEC  	A
	MOVX 	@DPTR,A
; 	    SET_DEVICE_READ_TO_DRAM();
			; SOURCE LINE # 138
	LCALL	SET_DEVICE_READ_TO_DRAM
; 
; 	    SPI_REG[0x10] = 0x0F;						// after DMA, SPI FIFO has to be cleared
			; SOURCE LINE # 140
	MOV  	DPTR,#0BB10H
	MOV  	A,#0FH
	MOVX 	@DPTR,A
; 		Trigger_Data_Transfer_Done();
			; SOURCE LINE # 141
	LCALL	Trigger_Data_Transfer_Done
; 
; 		if(tc_Retry==0)
			; SOURCE LINE # 143
	JB   	tc_Retry?345,?C0015
; 		{
			; SOURCE LINE # 144
; 			tc_Retry=1;
			; SOURCE LINE # 145
	SETB 	tc_Retry?345
; 		}
			; SOURCE LINE # 146
	SJMP 	?C0020
?C0015:
; 		else
; 		{
			; SOURCE LINE # 148
; 		    gc_SPI_Addr1+=0x02;
			; SOURCE LINE # 149
	MOV  	DPTR,#gc_SPI_Addr1
	MOVX 	A,@DPTR
	ADD  	A,#02H
	MOVX 	@DPTR,A
; 			if(gc_SPI_Addr1==0x00)
			; SOURCE LINE # 150
	MOVX 	A,@DPTR
	JNZ  	?C0017
; 			{
			; SOURCE LINE # 151
; 				gc_SPI_Addr2++;
			; SOURCE LINE # 152
	MOV  	DPTR,#gc_SPI_Addr2
	MOVX 	A,@DPTR
	INC  	A
	MOVX 	@DPTR,A
; 			}
			; SOURCE LINE # 153
?C0017:
; 		    gc_ProgRAM_Index+=0x02;	// ProgRAM Index
			; SOURCE LINE # 154
	MOV  	DPTR,#gc_ProgRAM_Index
	MOVX 	A,@DPTR
	ADD  	A,#02H
	MOVX 	@DPTR,A
; 			u_Seccnt--;  
			; SOURCE LINE # 155
	MOV  	DPTR,#u_Seccnt?343
	MOVX 	A,@DPTR
	DEC  	A
	MOVX 	@DPTR,A
; 		}
			; SOURCE LINE # 156
?C0020:
; 	    SPI_DISABLE();
			; SOURCE LINE # 157
	MOV  	DPTR,#0BB18H
	MOVX 	A,@DPTR
	ORL  	A,#01H
	MOVX 	@DPTR,A
; 		for(i=0;i<20;i++);
			; SOURCE LINE # 158
	CLR  	A
	MOV  	i?344,A
?C0021:
	MOV  	A,i?344
	CLR  	C
	SUBB 	A,#014H
	JNC  	?C0010
	INC  	i?344
	SJMP 	?C0021
;     }
			; SOURCE LINE # 159
; } 
			; SOURCE LINE # 160
?C0024:
	RET  	
; END OF _SPI_Load_Code_To_DRAM

	END
