C51 COMPILER V9.00   DOSFAT                                                                07/10/2012 15:51:51 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DOSFAT
OBJECT MODULE PLACED IN .\obj\dosfat.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\LIBSOURCE\DOS\dosfat.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\l
                    -ibsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\dosfat.lst) OBJECT(.\obj\dosfat.obj)

line level    source

   1          #include <string.h>
   2          #include "SPDA2K.h"
   3          #include "dos\fs_struct.h"
   4          #include "dos\dosfat.h"
   5          #include "Memalloc.h"
   6          
   7          
   8          U8 DOS_CopyFATtoFAT(U32 tdw_StartCluster, U32 tdw_TailCluster, U8 tbt_fat1tofat2)
   9          {
  10   1              U8      tc_Status = DOS_SUCCESS;
  11   1              U32 tdw_StartSector;
  12   1              U32 tdw_EndSector;
  13   1              U32 tdw_CopySecSize;
  14   1              U32 tdw_CopySourceAddr;
  15   1              U32 tdw_CopyTargetAddr;
  16   1              U32 tdw_LoopCount;
  17   1              U32 tdw_MarkAddr;
  18   1              
  19   1              if (tdw_TailCluster >= gdw_DOS_FatMaxCluster)//exceed max cluster
  20   1              {
  21   2                      tdw_TailCluster = gdw_DOS_FatMaxCluster - 1;
  22   2              }
  23   1              
  24   1              //calculate start and end address of copying
  25   1              tdw_StartSector = (tdw_StartCluster << gc_DOS_FileSystemType)>>9;//(JC)Byte/512
  26   1              tdw_EndSector = (tdw_TailCluster << gc_DOS_FileSystemType)>>9;//(JC)Byte/512
  27   1              
  28   1              tdw_CopySecSize = (tdw_EndSector - tdw_StartSector)+1;
  29   1              //confirm the direction of the Copy operation
  30   1              if (tbt_fat1tofat2)
  31   1              {//FAT1 to FAT2
  32   2                      tdw_CopySourceAddr = gdw_DOS_Fat1Addr + tdw_StartSector;//copy source address
  33   2                      tdw_CopyTargetAddr = gdw_DOS_Fat2Addr + tdw_StartSector;//copy target address
  34   2                      tdw_MarkAddr = gdw_DOS_Fat2Addr;//mark updating address
  35   2              }
  36   1              else
  37   1              {//FAT2 to FAT1
  38   2                      tdw_CopySourceAddr = gdw_DOS_Fat2Addr + tdw_StartSector;
  39   2                      tdw_CopyTargetAddr = gdw_DOS_Fat1Addr + tdw_StartSector;
  40   2                      tdw_MarkAddr = gdw_DOS_Fat1Addr;
  41   2              }
  42   1              if (tdw_CopyTargetAddr != tdw_MarkAddr)
  43   1              {//mark updating flag 0xf8 ---> 0xaa
  44   2                      DOS_MarkFATUpdate(tdw_MarkAddr,0xaa);
  45   2              }
  46   1      
  47   1              for(tdw_LoopCount = 0; tdw_LoopCount < tdw_CopySecSize; tdw_LoopCount++)
  48   1              {
  49   2                      gb_ReadWriteDataArea = 0;//select gc_PlayRecordDataBuf[]
  50   2                      tc_Status=DOS_Read_LogicSector(tdw_CopySourceAddr, 1);
  51   2                      if(tc_Status)
  52   2                      {
  53   3                              return tc_Status;
  54   3                      }
C51 COMPILER V9.00   DOSFAT                                                                07/10/2012 15:51:51 PAGE 2   

  55   2                      //not close new block
  56   2                      if (tdw_LoopCount == 0 && tdw_CopyTargetAddr == tdw_MarkAddr)
  57   2                      {//first write sector is FAT1's start sector
  58   3                              gc_PlayRecordDataBuf[0] = 0xaa;
  59   3                      }
  60   2                      tc_Status=DOS_Write_LogicSector(tdw_CopyTargetAddr, 1, 0);
  61   2                      if(tc_Status)
  62   2                      {
  63   3                              return tc_Status;
  64   3                      }
  65   2                      tdw_CopySourceAddr++;//next sector
  66   2                      tdw_CopyTargetAddr++;//next sector
  67   2              }
  68   1              DOS_MarkFATUpdate(tdw_MarkAddr,0xf8);//mark updating is complete
  69   1              
  70   1              return tc_Status;
  71   1      }
  72          
  73          
  74          //---------------------------------------------------------------
  75          //! Mark the 1st byte of FAT
  76          /*! Mark the 1st byte of FAT sector while updating.
  77           *      \param  tdw_MarkFATAddr         The FAT LBA.
  78           *      \param  tc_MarkValue            The byte mark to be written.
  79           *      \return DOS_SUCCESS or DOS_FALSE.
  80           */
  81          U8 DOS_MarkFATUpdate(U32 tdw_MarkFATAddr, U8 tc_MarkValue)
  82          {
  83   1              U8      tc_Status;
  84   1                      
  85   1              gb_ReadWriteDataArea = 0;//select gc_PlayRecordDataBuf[]
  86   1              tc_Status = DOS_Read_LogicSector(tdw_MarkFATAddr, 1);//read sector
  87   1              if (tc_Status == DOS_SUCCESS)
  88   1              {
  89   2                      gc_PlayRecordDataBuf[0] = tc_MarkValue;//mark first byte
  90   2                      tc_Status = DOS_Write_LogicSector(tdw_MarkFATAddr, 1, 0);//write sector 
  91   2              }
  92   1              return tc_Status;
  93   1      }
  94          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    472    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      39
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
