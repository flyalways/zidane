C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE FLASH
OBJECT MODULE PLACED IN .\obj\Flash.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\libsource\FLASH\Flash.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\
                    -libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\Flash.lst) OBJECT(.\obj\Flash.obj)

line level    source

   1          /*
   2           *                          Sunplus mMedia Inc.
   3           *
   4           *   (c) Copyright 2008~, Sunplus mMedia Inc., Hsinchu, Taiwan R.O.C.
   5           *                          All Right Reserved
   6           */
   7          /*! \file       flash.c
   8           *      \brief  
   9           *
  10           *      \author jay
  11           */
  12          
  13          #include "SPDA2K.h"
  14          
  15          //! backup flash data (from gw_SourceBlock to gw_TargetBlock)
  16          /*!
  17           *      \param  StartPage               start sector address
  18           *      \param  EndPage                 end sector address
  19           *      \param  Spare_Mark              0:not care spare data 1:care spare data
  20           */
  21          void FLASH_Backup_Blcok(UWORD StartPage , UWORD EndPage , U8  Spare_Mark, U8 TargetDev) {       
  22   1              data    U16 tw_Page;    
  23   1      //dbprintf("A ");
  24   1              //DMA_REG[0xB1]    = 0x00;                                                                      // Disable DMA Auto address account
  25   1              //DEVICE_REG[0xA0] = 0x01;                                                                      // Reset ECC  
  26   1              //FLASH_REG[0xA3]  = 0x01;                                                                      // Enable ECC 
  27   1              //FLASH_REG[0xA0]  = 0x00;                                                                      // Disable Encode RS-Code
  28   1              //FLASH_REG[0xA1]  = 0x01;                                                                      // Start Decode RS-Code
  29   1              //FLASH_REG[0xA2] &= 0xF3;                                                                      // Clear ECC fail register
  30   1              ///////////////////////////////////////////////////////////////////////////////////////
  31   1              NAND_Set_Spare_Data(Spare_Mark,0);//set mark type 
  32   1              FDBP.cFDev= TargetDev;
  33   1              
  34   1              for(tw_Page=StartPage; tw_Page<EndPage;tw_Page++){
  35   2                      //-------------------------------------- //
  36   2                      Device_Read_SRAM_Index.BY[0] = 0x80;
  37   2                      Device_Read_SRAM_Index.BY[1] = 0x00; 
  38   2                      FDBP.cFPlane = tw_Page%NAND_INFO.cPLANE_NUM;
  39   2                      FDBP.wFBlock = gw_SourceBlock;// source block 
  40   2                      FDBP.wFPage  = tw_Page/NAND_INFO.cPLANE_NUM;
  41   2                      FDBP.cFInAddr =0;
  42   2                      Flash_Sequent_Read(NAND_INFO.cINADDRMAX);
  43   2                      //--------------------------------------//
  44   2                      Device_Write_SRAM_Index.BY[0] = 0x80;
  45   2                      Device_Write_SRAM_Index.BY[1] = 0x00;
  46   2                      FDBP.cFPlane = tw_Page%NAND_INFO.cPLANE_NUM;
  47   2                      FDBP.wFBlock = gw_TargetBlock;// Target block
  48   2                      FDBP.wFPage  = tw_Page/NAND_INFO.cPLANE_NUM;
  49   2                      FDBP.cFInAddr =0;
  50   2                      Flash_Sequent_Write(NAND_INFO.cINADDRMAX,1);
  51   2                      
  52   2                      
  53   2              }
  54   1      }
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 2   

  55          
  56          
  57          /*********************************************************************************
  58          * NAME:               void NAND_Fill_H2E_SBlock(U8 tc_Start_SBlock,U8 tc_END_SBlock)
  59          * DESCRIPTION:
  60          *********************************************************************************/
  61          void NAND_Fill_H2E_SBlock(U8 tc_Inx,U8 tc_END_SBlock){
  62   1              data    U8 tc_E_SBlock;
  63   1              data    U8 tc_XferPageCnt;
  64   1              NAND_Set_Spare_Data(0,tc_Inx);
  65   1              tc_E_SBlock =(Mapping_Table[Q2_INX+tc_Inx]>>8);
  66   1              for(; tc_E_SBlock<tc_END_SBlock;tc_E_SBlock++){
  67   2                      APort_FBlock[0]= APort_LBlock[0];
  68   2                      APort_FBlock[1]= APort_EBlock[0];                               
  69   2                      gw_SourcePage=((U16)tc_E_SBlock*H_INFO.cSMALLPAGE_NUM)+0;
  70   2              gw_TargetPage=((U16)tc_E_SBlock*H_INFO.cSMALLPAGE_NUM)+0;                                       
  71   2                      tc_XferPageCnt = H_INFO.cSMALLPAGE_NUM;
  72   2                      RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );
  73   2              }
  74   1              QTable.WD =Mapping_Table[Q2_INX+tc_Inx];
  75   1              QTable.BY[0] = tc_END_SBlock;
  76   1              //QTable.BY[1] = 0x0000;不要亂動∼∼會出現OVER WRITE
  77   1              Mapping_Table[Q2_INX+tc_Inx]= QTable.WD;
  78   1      }
  79          /*********************************************************************************
  80          * NAME:               void NAND_Fill_H2E_SBlock(U8 tc_Start_SBlock,U8 tc_END_SBlock)
  81          * DESCRIPTION:
  82          *********************************************************************************/
  83          void NAND_Fill_H2E_SPage(U8 tc_Inx,U8 tc_END_SPage){
  84   1              xdata   U8      tc_E_SBlock;
  85   1              xdata   U8      tc_E_SPage;
  86   1              xdata   U8      tc_XferPageCnt;
  87   1              NAND_Set_Spare_Data(0,tc_Inx);
  88   1              tc_E_SBlock =(Mapping_Table[Q2_INX+tc_Inx]>>8);
  89   1              tc_E_SPage = (U8)Mapping_Table[Q2_INX+tc_Inx];  
  90   1              APort_FBlock[0]= APort_LBlock[0];
  91   1              APort_FBlock[1]= APort_EBlock[0];                               
  92   1              gw_SourcePage=((U16)tc_E_SBlock*H_INFO.cSMALLPAGE_NUM)+tc_E_SPage;
  93   1          gw_TargetPage=((U16)tc_E_SBlock*H_INFO.cSMALLPAGE_NUM)+tc_E_SPage;                                  
  94   1              tc_XferPageCnt = (tc_END_SPage-tc_E_SPage);
  95   1              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );     
  96   1              QTable.WD =Mapping_Table[Q2_INX+tc_Inx];
  97   1              QTable.BY[1] = tc_END_SPage;
  98   1              Mapping_Table[Q2_INX+tc_Inx]= QTable.WD;
  99   1              //QTable.BY[0] = tc_E_SBlock;
 100   1              //QTable.BY[1] = tc_END_SPage;
 101   1              //Mapping_Table[Q2_INX+tc_Inx]= QTable.WD;
 102   1              
 103   1      }
 104          
 105          
 106          
 107          
 108          /*********************************************************************************
 109          * NAME:               void NAND_Combin_E_D_To_New_E(U8 tc_END_SBlock)
 110          * DESCRIPTION:
 111          *********************************************************************************/
 112          void NAND_Combin_E_D_To_New_E(U8 tc_Inx ,U8 tc_END_SBlock){
 113   1              data    U8      tc_Start_SBlock;
 114   1              data    bit     tbt_Not_D_SBlock;
 115   1              data    U8      tc_XferPageCnt ;
 116   1              data    U8      tc_Q1_SBlock;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 3   

 117   1      //dbprintf("D ");       
 118   1              ZSpare[0] = 0xA5;                                                       ZSpare[1] = (U8)Mapping_Table[PWR_INX+tc_Inx];
 119   1              ZSpare[2] = Mapping_Table[EINX+tc_Inx];         ZSpare[3] = APort_SCNT[0];      
 120   1              ZSpare[4] = 'Q';                                                        ZSpare[5] = 0x00;//0520 Jay add
 121   1              ZSpare[6] = 'Q';                                                        ZSpare[7] = 0x00;// update Q1 Block     
 122   1              tc_Q1_SBlock = (Mapping_Table[Q1_INX+tc_Inx]>>8);
 123   1              
 124   1              
 125   1              for(tc_Start_SBlock=0; tc_Start_SBlock<=tc_END_SBlock;tc_Start_SBlock++){
 126   2                      tbt_Not_D_SBlock=CHK_DSBlock_Exist_Or_New(tc_Inx,tc_Start_SBlock,0); 
 127   2                      
 128   2                      if(tbt_Not_D_SBlock){//not find D_SBlock
 129   3                              if(tc_Start_SBlock<tc_Q1_SBlock){               
 130   4                                      APort_FBlock[0]= APort_LBlock[0];
 131   4                              }
 132   3                              else{                   
 133   4                                      APort_FBlock[0]= APort_EBlock[0];
 134   4                              }
 135   3                              APort_FBlock[1]= APort_SBlock[0];                               
 136   3                              gw_SourcePage=((U16)tc_Start_SBlock*H_INFO.cSMALLPAGE_NUM)+0;
 137   3                      gw_TargetPage=((U16)tc_Start_SBlock*H_INFO.cSMALLPAGE_NUM)+0;                                   
 138   3                              if(tc_Start_SBlock==tc_END_SBlock){
 139   4                                      tc_XferPageCnt = (U8)Mapping_Table[Q2_INX+tc_Inx];
 140   4                              }
 141   3                              else{                           
 142   4                                      tc_XferPageCnt = H_INFO.cSMALLPAGE_NUM;
 143   4                              }
 144   3                      
 145   3                              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );
 146   3                      }
 147   2                      else{// 有資料在D_SBlock
 148   3                              // 0~~SQTable.BY[0]
 149   3                              if(SQTable.BY[0]){
 150   4                                      if(tc_Start_SBlock<tc_Q1_SBlock){               
 151   5                                              APort_FBlock[0]= APort_LBlock[0];
 152   5                                      }
 153   4                                      else{                   
 154   5                                              APort_FBlock[0]= APort_EBlock[0];
 155   5                                      }                       
 156   4                                      APort_FBlock[1]= APort_SBlock[0];                               
 157   4                                      gw_SourcePage=((U16)tc_Start_SBlock*H_INFO.cSMALLPAGE_NUM)+0;
 158   4                              gw_TargetPage=((U16)tc_Start_SBlock*H_INFO.cSMALLPAGE_NUM)+0;                                   
 159   4                                      tc_XferPageCnt =SQTable.BY[0];
 160   4                                                              
 161   4                                      RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );
 162   4                              }
 163   3                              // SQTable.BY[0]~SQTable.BY[1]  
 164   3                              APort_FBlock[0]= APort_DBlock[0];
 165   3                              APort_FBlock[1]= APort_SBlock[0];                               
 166   3                              gw_SourcePage=((U16)gc_D_SBlock*H_INFO.cSMALLPAGE_NUM)+0;
 167   3                      gw_TargetPage=((U16)tc_Start_SBlock*H_INFO.cSMALLPAGE_NUM)+SQTable.BY[0];                                       
 168   3                              tc_XferPageCnt =(SQTable.BY[1]-SQTable.BY[0]);
 169   3                                              
 170   3                              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );     
 171   3                              // SQTable.BY[1]~~~H_INFO.cSMALLBPAGE_NUM;
 172   3                              if(tc_Start_SBlock<tc_Q1_SBlock){               
 173   4                                      APort_FBlock[0]= APort_LBlock[0];
 174   4                              }
 175   3                              else{                   
 176   4                                      APort_FBlock[0]= APort_EBlock[0];
 177   4                              }                       
 178   3                              APort_FBlock[1]= APort_SBlock[0];                               
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 4   

 179   3                              gw_SourcePage=((U16)tc_Start_SBlock*H_INFO.cSMALLPAGE_NUM)+SQTable.BY[1];
 180   3                      gw_TargetPage=((U16)tc_Start_SBlock*H_INFO.cSMALLPAGE_NUM)+SQTable.BY[1];                                       
 181   3                              tc_XferPageCnt =(H_INFO.cSMALLPAGE_NUM-SQTable.BY[1]);
 182   3                              
 183   3                              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );
 184   3                                      
 185   3                      }
 186   2              }
 187   1              // Updata Mapping Table //
 188   1              Mapping_Table[EBK+tc_Inx] = APort_SBlock[0];                            
 189   1              Wear_Table[ECNT+tc_Inx]  = APort_SCNT[0];
 190   1              NAND_Erase_Block_LEDR(1); // erase external 
 191   1              Mapping_Table[DBK+tc_Inx]=APort_EBlock[0];
 192   1              Wear_Table[DCNT+tc_Inx]= (APort_ECNT[0]+1);
 193   1              NAND_Erase_Block_LEDR(2); // earse dummy
 194   1              Mapping_Table[SBK]=APort_DBlock[0];
 195   1              Wear_Table[SCNT]= (APort_DCNT[0]+1);    
 196   1              //Mapping_Table[Q2_INX+tc_Inx]=((U16)tc_END_SBlock<<8);//0514不應該動
 197   1              Mapping_Table[Q1_INX+tc_Inx]= 0x0000;
 198   1              Load_E_D_Block_From_MAP(0,tc_Inx);      // updat E D block              
 199   1              APort_SBlock[0] = Mapping_Table[SBK];//update SBlock
 200   1              APort_SCNT[0] = Wear_Table[SCNT];       
 201   1              NAND_Clear_D_SBlock_Flag(tc_Inx);
 202   1              
 203   1      
 204   1      }
 205          /*********************************************************************************
 206          * NAME:               void NAND_Combin_E_D_To_New_E(U8 tc_END_SBlock)
 207          * DESCRIPTION:
 208          *********************************************************************************/
 209          void NAND_Combin_H_E_D_To_New_H(U8 tc_Inx){
 210   1              data    U8      tc_Offset;
 211   1              xdata   U8      tc_i;
 212   1              data    bit     tbt_Find_D_SBlock=0;
 213   1              data    U8      tc_Q1_SBlock;
 214   1      //dbprintf("E ");       
 215   1              tc_Q1_SBlock = Mapping_Table[Q1_INX+tc_Inx]>>8;
 216   1              tc_Offset= (tc_Inx* MAX_DUMMY_PAGE); 
 217   1              for(tc_i=0; tc_i<MAX_DUMMY_PAGE;tc_i++){
 218   2                      if(Mapping_Table[D_HPAGE+tc_Offset+tc_i]!=0xFFFF){
 219   3                              tbt_Find_D_SBlock=1;
 220   3                              break;
 221   3                      }
 222   2              }
 223   1              QTable.WD = Mapping_Table[Q2_INX+tc_Inx];
 224   1              if(tbt_Find_D_SBlock||(tc_Q1_SBlock!=0)){// 有D_SBlock或是 Q1_Sblock!=0 應該是要寫swap block    
 225   2                      NAND_Combin_E_D_To_New_E(tc_Inx ,QTable.BY[0]);         
 226   2              }
 227   1              QTable.WD = Mapping_Table[Q2_INX+tc_Inx];
 228   1              if(QTable.BY[1]){ 
 229   2                      NAND_Close_E_SBlock(tc_Inx);
 230   2              }       
 231   1              NAND_Fill_H2E_SBlock(tc_Inx,H_INFO.cSMALLBLOCK_NUM);
 232   1              //---------  Updata Mapping Table -----------------//
 233   1              tc_Offset =Mapping_Table[EINX+tc_Inx];
 234   1              Mapping_Table[tc_Offset]=APort_EBlock[0];
 235   1              Wear_Table[tc_Offset] = APort_ECNT[0];
 236   1              NAND_Erase_Block_LEDR(0);
 237   1              Mapping_Table[EBK+tc_Inx] =APort_LBlock[0];// Swap Block -->New External Block                          
 238   1              Wear_Table[ECNT+tc_Inx] = (APort_LCNT[0]+1);
 239   1              Mapping_Table[Q2_INX+tc_Inx]=0x0000;
 240   1              Mapping_Table[Q1_INX+tc_Inx]=0x0000;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 5   

 241   1              Mapping_Table[EINX+tc_Inx]=0xFFFF;
 242   1      }
 243          /*********************************************************************************
 244          * NAME:               void NAND_Combin_E_D_To_New_E(U8 tc_END_SBlock)
 245          * DESCRIPTION:
 246          *********************************************************************************/
 247          void NAND_Combin_H_R_To_New_H(U8 tc_Inx){
 248   1              xdata   U16     tw_Page;
 249   1              data    U8  tc_Temp_HBlock;
 250   1              data    U8  tc_Offset;
 251   1              xdata   U8  tc_PwrInx;
 252   1      //dbprintf("F ");       
 253   1              tc_Offset = tc_Inx*MAX_RANDOM_HPAGE;
 254   1              tc_Temp_HBlock = Wear_Table[RINX+tc_Inx];
 255   1              APort_LBlock[0] =       Mapping_Table[tc_Temp_HBlock];
 256   1              APort_LCNT[0] =         Wear_Table[tc_Temp_HBlock];
 257   1              //------- update PWR_INX ---------------//
 258   1              FDBP.cFDev=gc_HDev;
 259   1              FDBP.cFPlane = 0;
 260   1              FDBP.wFBlock = APort_LBlock[0];
 261   1              FDBP.wFPage  = 0;
 262   1              FDBP.cFInAddr =0;  
 263   1              Device_Read_SRAM_Index.WD=0x8000;
 264   1              Flash_ReadSpare(4);  // get Hblock spare data 
 265   1              tc_PwrInx =ZSpare[1];
 266   1              //----------------------------------------//
 267   1              
 268   1              
 269   1              ZSpare[0] = 0xA5;                   ZSpare[1] = tc_PwrInx+1;
 270   1              ZSpare[2] = tc_Temp_HBlock;     ZSpare[3] = APort_SCNT[0];      
 271   1              ZSpare[4] = 'Q';                        ZSpare[5] = 0;// Q1_INX
 272   1              ZSpare[6] = 'Q';                        ZSpare[7] = 0;// Q1_INX 
 273   1              APort_FBlock[1]= APort_SBlock[0];
 274   1              for(tw_Page =0; tw_Page<H_INFO.wHBLOCKPAGE; tw_Page++){
 275   2                      if(CHK_RandomPage_Exist(tc_Inx,tw_Page)){
 276   3                              APort_FBlock[0]= APort_RBlock[0];
 277   3                              gw_SourcePage = Mapping_Table[R_PAGE+tc_Offset+gc_NowIndex];
 278   3                      }
 279   2                      else{
 280   3                              APort_FBlock[0]=  APort_LBlock[0];
 281   3                              gw_SourcePage = tw_Page;
 282   3                      }
 283   2                      gw_TargetPage= tw_Page;                                 
 284   2                      RW_Data_Stage(gw_SourcePage,gw_TargetPage,1);                   
 285   2              }
 286   1              // Updata Mapping Table //
 287   1              NAND_Erase_Block_LEDR(0);// Erase old L_block   
 288   1              Mapping_Table[SBK]=APort_LBlock[0];
 289   1              Wear_Table[SCNT]= (APort_LCNT[0]+1);
 290   1              Mapping_Table[tc_Temp_HBlock] =APort_SBlock[0];                                 
 291   1              Wear_Table[tc_Temp_HBlock] =APort_SCNT[0];      
 292   1              APort_SBlock[0]= Mapping_Table[SBK];    
 293   1              APort_SCNT[0] = Wear_Table[SCNT];       
 294   1              APort_LBlock[0] = Mapping_Table[HBlock.WD];
 295   1              APort_LCNT[0] = Wear_Table[HBlock.WD];
 296   1              NAND_Clear_R_PageFlag(tc_Inx);          
 297   1              
 298   1              //gw_R_SPage=Mapping_Table[RPAGEINX];不要亂般∼∼到時候再說
 299   1              //if(gw_R_SPage>= (H_INFO.wHBLOCKPAGE-H_INFO.cSMALLPAGE_NUM)){//保留至少32K的空間可以寫入不用換,跟哪一個g
             -roup 無關
 300   1              //      NAND_Close_Random_Block();                 // 只是將現有的random page 從新整理
 301   1              //}
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 6   

 302   1              
 303   1      }
 304          
 305          
 306          /*********************************************************************************
 307          * NAME:               bit CHK_RandomPage_Space(U8 tc_Inx);
 308          * DESCRIPTION:
 309          *********************************************************************************/
 310          U8 CHK_RandomPage_Space(U8 tc_Inx){
 311   1              xdata   U8      tc_Offset;
 312   1              xdata   U8      tc_i;
 313   1              data    bit     tbt_FindPage=0;
 314   1              tc_Offset = tc_Inx*MAX_RANDOM_HPAGE;
 315   1              for(tc_i=0; tc_i<MAX_RANDOM_HPAGE;tc_i++){
 316   2                      if(Mapping_Table[R_HPAGE+tc_Offset+tc_i] ==0xFFFF){
 317   3                              gc_NowIndex =tc_i;
 318   3                              tbt_FindPage=1;
 319   3                              break;
 320   3                      }       
 321   2              }       
 322   1              return tbt_FindPage;
 323   1      }
 324          
 325          
 326          /*********************************************************************************
 327          * NAME:               void NAND_Erase_Block_LEDR(U8 tc_Inx);
 328          * DESCRIPTION:
 329          *********************************************************************************/
 330          void NAND_Erase_Block_LEDR(U8 tc_Inx){
 331   1              FDBP.cFDev=gc_HDev;     
 332   1              FDBP.cFPlane =0;
 333   1              FDBP.wFPage =0;
 334   1              FDBP.cFInAddr =0;
 335   1              switch(tc_Inx){
 336   2                      case 0:
 337   2                              FDBP.wFBlock =APort_LBlock[0];                  
 338   2                              Flash_MultiBank_Erase(0);//not chk busy         
 339   2                              break;
 340   2                      case 1:
 341   2                              FDBP.wFBlock=APort_EBlock[0];
 342   2                              
 343   2                              Flash_MultiBank_Erase(0);//not chk busy         
 344   2                              break;          
 345   2                      case 2:
 346   2                              FDBP.wFBlock=APort_DBlock[0];
 347   2                              
 348   2                              Flash_MultiBank_Erase(0);//not chk busy 
 349   2                              break;  
 350   2                      case 3:
 351   2                              FDBP.wFBlock=APort_RBlock[0];
 352   2                              
 353   2                              Flash_MultiBank_Erase(0);//not chk busy         
 354   2                              break;
 355   2                      default:
 356   2                              // nothing to do
 357   2                              break;
 358   2              }
 359   1                      
 360   1              
 361   1      }
 362          /*********************************************************************************
 363          * NAME:               void NAND_Clear_D_SBlock_Flag(U8 tc_group);
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 7   

 364          * DESCRIPTION:
 365          *********************************************************************************/
 366          void NAND_Clear_D_SBlock_Flag(U8 tc_group){
 367   1              xdata   U8 tc_Offset;
 368   1              xdata   U8      tc_i;
 369   1      //dbprintf("I ");       
 370   1              tc_Offset= (tc_group* MAX_DUMMY_PAGE); 
 371   1              for(tc_i=0; tc_i<MAX_DUMMY_PAGE;tc_i++){
 372   2                      Mapping_Table[D_HPAGE+tc_Offset+tc_i]=0xFFFF;
 373   2                      Mapping_Table[D_PAGE+tc_Offset+tc_i]=0xFFFF;            
 374   2              }       
 375   1              Mapping_Table[Q1_INX+tc_group] =0x0000;
 376   1      }
 377          /*********************************************************************************
 378          * NAME:               void NAND_Clear_D_SBlock_Flag(U8 tc_group);
 379          * DESCRIPTION:// 先將clear info 寫入
 380          *********************************************************************************/
 381          void NAND_Clear_R_PageFlag(U8 tc_group){
 382   1              data    U8 tc_Offset;
 383   1              data    U8      tc_i;
 384   1      //dbprintf("J ");       
 385   1              gw_R_SPage=Mapping_Table[RPAGEINX];
 386   1              /*//不能先清
 387   1              Wear_Table[RINX+tc_group]=0xFF;//0520 Jay add
 388   1              tc_Offset= (tc_group* MAX_RANDOM_HPAGE); 
 389   1              for(tc_i=0; tc_i<MAX_RANDOM_HPAGE;tc_i++){
 390   1                      Mapping_Table[R_HPAGE+tc_Offset+tc_i]=0xFFFF;
 391   1                      Mapping_Table[R_PAGE+tc_Offset+tc_i]=0xFFFF;
 392   1              }*/     
 393   1              if(gw_R_SPage==H_INFO.wHBLOCKPAGE){
 394   2                      Wear_Table[RINX+tc_group]=0xFF;//0513將Random block 處理
 395   2                      tc_Offset= (tc_group* MAX_RANDOM_HPAGE); 
 396   2                      for(tc_i=0; tc_i<MAX_RANDOM_HPAGE;tc_i++){
 397   3                              Mapping_Table[R_HPAGE+tc_Offset+tc_i]=0xFFFF;
 398   3                              Mapping_Table[R_PAGE+tc_Offset+tc_i]=0xFFFF;
 399   3                      }       
 400   2                      //dbprintf("\n clear R_1");
 401   2                      NAND_Close_Random_Block();
 402   2              }
 403   1              else{
 404   2                      ZSpare[0] =0x55;
 405   2                      ZSpare[1] =0xCC;// clear flag
 406   2                      ZSpare[2] =Wear_Table[RINX+tc_group]; // 要被clear 的Block inx
 407   2                      ZSpare[3] =0xCC; // clear flag 
 408   2                      Wear_Table[RINX+tc_group]=0xFF;
 409   2                      for(tc_i=0; tc_i<MAX_RANDOM_HBLOCK;tc_i++){
 410   3                              ZSpare[4+tc_i]= Wear_Table[RINX+tc_i];
 411   3                      }               
 412   2                      Device_Write_SRAM_Index.BY[0] = 0x80;
 413   2                      Device_Write_SRAM_Index.BY[1] = 0x00;           
 414   2                      FDBP.cFPlane = gw_R_SPage%NAND_INFO.cPLANE_NUM;
 415   2                      FDBP.wFBlock = APort_RBlock[0];
 416   2                      FDBP.wFPage  = gw_R_SPage/NAND_INFO.cPLANE_NUM;
 417   2                      FDBP.cFInAddr =0;
 418   2                      Flash_Sequent_Write(4,1);
 419   2                      gw_R_SPage++;
 420   2                      Mapping_Table[RPAGEINX]=gw_R_SPage;
 421   2                      //dbprintf("\n clear R_2");
 422   2                      tc_Offset= (tc_group* MAX_RANDOM_HPAGE); 
 423   2                      for(tc_i=0; tc_i<MAX_RANDOM_HPAGE;tc_i++){
 424   3                              Mapping_Table[R_HPAGE+tc_Offset+tc_i]=0xFFFF;
 425   3                              Mapping_Table[R_PAGE+tc_Offset+tc_i]=0xFFFF;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 8   

 426   3                      }
 427   2                      
 428   2               }
 429   1      
 430   1      }
 431          
 432          
 433          /*********************************************************************************
 434          * NAME:               void NAND_Update_PWR_INX(U8 tc_Inx);
 435          * DESCRIPTION:
 436          *********************************************************************************/
 437          void NAND_Update_PWR_INX(U8 tc_Inx){
 438   1              xdata   U8      tc_Hblock;
 439   1              tc_Hblock =Mapping_Table[EINX+tc_Inx];
 440   1              FDBP.cFDev=gc_HDev;
 441   1              FDBP.cFPlane = 0;
 442   1              FDBP.wFBlock = Mapping_Table[tc_Hblock];
 443   1              FDBP.wFPage  = 0;
 444   1              FDBP.cFInAddr =0;  
 445   1              Device_Read_SRAM_Index.WD=0x8000;
 446   1              Flash_ReadSpare(4);  // get Hblock spare data 
 447   1              QTable.BY[0] = ZSpare[1];
 448   1              QTable.BY[1] = ZSpare[1]+1;
 449   1              Mapping_Table[PWR_INX+tc_Inx]=QTable.WD; 
 450   1      
 451   1      }
 452          /*********************************************************************************
 453          * NAME:               void NAND_Write_Q1_Mark(U8 tc_Inx);
 454          * DESCRIPTION:
 455          *********************************************************************************/
 456          void NAND_Write_Q1_Mark(U8 tc_Inx){
 457   1      //dbprintf("L ");       
 458   1              ZSpare[0] = 0xA5;                                                       ZSpare[1] = (U8)Mapping_Table[PWR_INX+tc_Inx];
 459   1              ZSpare[2] = Mapping_Table[EINX+tc_Inx];         ZSpare[3] = Wear_Table[ECNT+tc_Inx];    
 460   1              ZSpare[4] = 'Q';                                                        ZSpare[5] = Mapping_Table[Q1_INX+tc_Inx]>>8;
 461   1              ZSpare[6] = 'Q';                                                        ZSpare[7] = Mapping_Table[Q1_INX+tc_Inx]>>8;
 462   1              //memset(XBYTE_8000,0xAA,1024);
 463   1              FDBP.cFDev=gc_HDev;
 464   1              FDBP.cFPlane = 0;
 465   1              FDBP.wFBlock = Mapping_Table[EBK+tc_Inx];
 466   1              FDBP.wFPage  = 0;
 467   1              FDBP.cFInAddr =0;  
 468   1              Device_Write_SRAM_Index.BY[0] = 0x80;
 469   1              Device_Write_SRAM_Index.BY[1] = 0x00;           
 470   1              Flash_Sequent_Write(4,1);
 471   1               
 472   1      
 473   1      }
 474          
 475          
 476          /*********************************************************************************
 477          * NAME:               void NAND_Set_FBlock(U8 tc_Inx);
 478          * DESCRIPTION:gc_write_EDRS 
 479          *********************************************************************************/
 480          void NAND_Set_FBlock(U8 tc_Inx){
 481   1              switch(tc_Inx){
 482   2                      case 0: // program  External Block
 483   2                              APort_FBlock[0]=APort_EBlock[0];
 484   2                              break;
 485   2                      case 1: // program  dummy block 
 486   2                              APort_FBlock[0]=APort_DBlock[0];
 487   2                              break;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 9   

 488   2                      case 2: // program  Random block  
 489   2                              APort_FBlock[0]=APort_RBlock[0];
 490   2                              
 491   2                              break;
 492   2                      default: 
 493   2                              APort_FBlock[0] = APort_SBlock[0];
 494   2                              break;
 495   2              }
 496   1      
 497   1      }
 498          /*********************************************************************************
 499          * NAME:               void NAND_Set_Mark_Register(U8 tc_Inx);
 500          * DESCRIPTION:gc_write_EDRS 
 501          *********************************************************************************/
 502          void NAND_Set_Mark_Register(U8 tbt_2nd_data){
 503   1              xdata   U8      tc_i;
 504   1              for(tc_i=0; tc_i<4;tc_i++){
 505   2                      if(tbt_2nd_data){
 506   3                              FLASH_REG[0x60+tc_i] =ZSpare[4+tc_i];
 507   3                      }
 508   2                      else{
 509   3                              FLASH_REG[0x60+tc_i] =ZSpare[tc_i];
 510   3                      }               
 511   2              }
 512   1      }
 513          /*********************************************************************************
 514          * NAME:              void USB_To_BUf(U8 tc_BufPtr , bit tbt_1024);
 515          * DESCRIPTION:gc_write_EDRS 
 516          *********************************************************************************/
 517          void USB_To_BUf(U8 tc_BufPtr , U8 tbt_1024){
 518   1              USB_CHK_Bank0_1_BulkOut_Done(0);
 519   1              Reset_DMA();
 520   1              DMA_REG[0x01]  = SRAM2SRAM;
 521   1              if(tbt_1024){                           
 522   2                      DMA_REG[0x03]  = 0x03;                                                  
 523   2                      DMA_REG[0x02]  = 0xFF;
 524   2              }
 525   1              else{
 526   2                      DMA_REG[0x03]  = 0x01;                                                  
 527   2                      DMA_REG[0x02]  = 0xFF;
 528   2              }
 529   1              CPU_REG[0x13]  = USB_BUF_Bank0_HIGH;                    
 530   1              CPU_REG[0x12]  = 0x00;
 531   1              CPU_REG[0x15]  = 0x80+(tc_BufPtr*2);
 532   1              CPU_REG[0x14]  = 0x00;
 533   1              Trigger_Data_Transfer_Done();           
 534   1              
 535   1      
 536   1      }
 537          
 538          
 539          
 540          
 541          /*********************************************************************************
 542          * NAME:               void USB_Rcevie_Data_To_BUf(U8 tc_BufPtr , U8 tc_Xfercnt);
 543          * DESCRIPTION:gc_write_EDRS 
 544          *********************************************************************************/
 545          void USB_Rcevie_Data_To_BUf(U8 tc_BufPtr , U8 tc_Xfercnt){
 546   1              bit tbt_USB_Sel=0;
 547   1              bit tbt_Xfer_512_OR_1024=0;
 548   1              
 549   1              if(gbt_USB_Data_In_Buf){
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 10  

 550   2                      gbt_USB_Data_In_Buf=0;
 551   2                      if(tc_Xfercnt==0x01){
 552   3                              USB_To_BUf(tc_BufPtr,0);//512
 553   3                              tc_Xfercnt--;
 554   3                              tc_BufPtr+=1;
 555   3                      }
 556   2                      else{
 557   3                              USB_To_BUf(tc_BufPtr,1);//1024
 558   3                              tc_Xfercnt-=2;
 559   3                              tc_BufPtr+=2;
 560   3                      }                       
 561   2              }
 562   1              if(tc_Xfercnt){
 563   2                      tbt_Xfer_512_OR_1024 =0;
 564   2                      tbt_USB_Sel =0;         
 565   2                      USB_Bank0_1_BulkOut(0,tbt_Xfer_512_OR_1024);
 566   2                      tc_Xfercnt--;
 567   2                      while(tc_Xfercnt){                      
 568   3                              if (tbt_USB_Sel) { //Bank 1-> RAM, USB -> Bank 0
 569   4                                      USB_CHK_Bank0_1_BulkOut_Done(1);
 570   4                                      if(!gbt_USB_Detected){
 571   5                                              return;
 572   5                                      }                               
 573   4                                      DMA_REG[0x01]  = SRAM2SRAM;                                             //SRAM->SRAM
 574   4                                      DMA_REG[0x03]  = 0x01;                                                  //512byte
 575   4                                      DMA_REG[0x02]  = 0xFF;
 576   4                                      CPU_REG[0x13]  = USB_BUF_Bank1_HIGH;                    // 080104 joyce add
 577   4                                      CPU_REG[0x12]  = 0x00;
 578   4                                      CPU_REG[0x15]  = 0x80+(tc_BufPtr*2);
 579   4                                      CPU_REG[0x14]  = 0x00;
 580   4                                      Trigger_Data_Transfer();
 581   4                                      
 582   4                                      USB_Bank0_1_BulkOut(0,tbt_Xfer_512_OR_1024);
 583   4                                      
 584   4                              }
 585   3                              else{ //Bank 0 -> RAM, USB -> Bank 1
 586   4                                      USB_CHK_Bank0_1_BulkOut_Done(0);                                                
 587   4                                      if(!gbt_USB_Detected){
 588   5                                              return;
 589   5                                      }                               
 590   4                                      DMA_REG[0x01]  = SRAM2SRAM;                                             //SRAM->SRAM
 591   4                                      DMA_REG[0x03]  = 0x01;                                                  //512byte
 592   4                                      DMA_REG[0x02]  = 0xFF;
 593   4                                      CPU_REG[0x13]  = USB_BUF_Bank0_HIGH;                    // 080104 joyce mark
 594   4                                      CPU_REG[0x12]  = 0x00;
 595   4                                      CPU_REG[0x15]  = 0x80+(tc_BufPtr*2);
 596   4                                      CPU_REG[0x14]  = 0x00;                          
 597   4                                      Trigger_Data_Transfer();                                                        //Trigger Data Xfer
 598   4                                      
 599   4                                      USB_Bank0_1_BulkOut(1,tbt_Xfer_512_OR_1024);
 600   4                                      
 601   4                              }
 602   3                              tbt_USB_Sel=!tbt_USB_Sel;
 603   3                              tc_Xfercnt--;
 604   3                              tc_BufPtr++;
 605   3                              CHK_Data_Transfer_Done();                       
 606   3                      }
 607   2                      if (tbt_USB_Sel) { //Bank 1-> RAM, USB -> Bank 0
 608   3                              USB_CHK_Bank0_1_BulkOut_Done(1);
 609   3                              if(!gbt_USB_Detected){
 610   4                                              return;
 611   4                              }               
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 11  

 612   3                              DMA_REG[0x01]  = SRAM2SRAM;                                             //SRAM->SRAM
 613   3                              DMA_REG[0x03]  = 0x01;                                                  //512byte
 614   3                              DMA_REG[0x02]  = 0xFF;
 615   3                              CPU_REG[0x13]  = USB_BUF_Bank1_HIGH;                    // 080104 joyce add
 616   3                              CPU_REG[0x12]  = 0x00;
 617   3                              CPU_REG[0x15]  = 0x80+(tc_BufPtr*2);
 618   3                              CPU_REG[0x14]  = 0x00;                  
 619   3                              Trigger_Data_Transfer_Done();
 620   3                      }
 621   2                      else{ //Bank 0 -> RAM, USB -> Bank 1
 622   3                                      
 623   3                              USB_CHK_Bank0_1_BulkOut_Done(0);                                                
 624   3                              if(!gbt_USB_Detected){
 625   4                                              return;
 626   4                              }               
 627   3                              DMA_REG[0x01]  = SRAM2SRAM;                                             //SRAM->SRAM
 628   3                              DMA_REG[0x03]  = 0x01;                                                  //512byte
 629   3                              DMA_REG[0x02]  = 0xFF;
 630   3                              CPU_REG[0x13]  = USB_BUF_Bank0_HIGH;                    // 080104 joyce mark
 631   3                              CPU_REG[0x12]  = 0x00;
 632   3                              CPU_REG[0x15]  = 0x80+(tc_BufPtr*2);
 633   3                              CPU_REG[0x14]  = 0x00;                          
 634   3                              Trigger_Data_Transfer_Done();                                                   //Trigger Data Xfer
 635   3                                      
 636   3                      }
 637   2                      
 638   2              }
 639   1              
 640   1      
 641   1      }
 642          /*********************************************************************************
 643          * NAME:               void USB_Bank0_BulkOut(bit Xfer_1024){ (void)
 644          * DESCRIPTION:
 645          *********************************************************************************/
 646          void USB_Bank0_1_BulkOut(U8 Use_Bank1 ,U8 Xfer_1024){
 647   1              USB_REG[0x11]       = 0x01;     //BulkoutEn auto turn-on(dma over)
 648   1              if(Xfer_1024){  
 649   2                      USB_REG[0x19]  = 0x01; // 1024
 650   2              }
 651   1              else{
 652   2                      USB_REG[0x19]  = 0x00;
 653   2              }
 654   1              if(Use_Bank1){
 655   2                      USB_REG[0xE9]  = 0x20;                                                  //Clear Bulk-Out(EP2) Buffer
 656   2                      if(Xfer_1024){  
 657   3                              //USB_REG[0x19]  = 0x01; // 1024
 658   3                              USB_REG[0x16]  = 0x04;                                                  //512Byte
 659   3                              USB_REG[0x15]  = 0x00;
 660   3                      }
 661   2                      else{
 662   3                              //USB_REG[0x19]  = 0x00; // 1024
 663   3                              USB_REG[0x16]  = 0x02;                                                  //512Byte
 664   3                              USB_REG[0x15]  = 0x00;
 665   3                      }
 666   2                      USB_REG[0xA2]  = 0x02;          
 667   2              }
 668   1              else{
 669   2                                                                                                                      //Allow Bulk-Out Tx.    
 670   2                      USB_REG[0xE9]  = 0x02;                                                  //Clear Bulk-Out(EP2) Buffer
 671   2                      if(Xfer_1024){  
 672   3                              //USB_REG[0x19]  = 0x01; // 1024
 673   3                              USB_REG[0x16]  = 0x04;                                                  
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 12  

 674   3                              USB_REG[0x15]  = 0x00;
 675   3                      }
 676   2                      else{
 677   3                              //USB_REG[0x19]  = 0x00; 
 678   3                              USB_REG[0x16]  = 0x02;                                                  //512Byte
 679   3                              USB_REG[0x15]  = 0x00;
 680   3                      }
 681   2                      USB_REG[0xA1]  = 0x02;                                                  //Allow Bulk-Out Tx.    
 682   2              
 683   2              }
 684   1      }
 685          /*********************************************************************************
 686          * NAME:               void USB_CHK_Bank0_1_BulkOut_Done(bit Chk_Bank1)
 687          * DESCRIPTION:
 688          *********************************************************************************/
 689          void USB_CHK_Bank0_1_BulkOut_Done(U8 Chk_Bank1){
 690   1              if(Chk_Bank1){
 691   2                      while(USB_REG[0xA2]&0x02){//Bank 1
 692   3                              if(!(GLOBAL_REG[0xD1]&0x02)){// 081023 Jay add                  
 693   4                                      gbt_USB_Detected = 0;
 694   4                                      return ;
 695   4                              }
 696   3                      }
 697   2                      USB_REG[0xC2] &= 0xDF;
 698   2                      USB_REG[0x11]  = 0x00;  
 699   2              }
 700   1              else{
 701   2                      while(USB_REG[0xA1]&0x02){  // Bank 0
 702   3                              if(!(GLOBAL_REG[0xD1]&0x02)){// 081023 Jay add                  
 703   4                                      gbt_USB_Detected = 0;
 704   4                                      return ;
 705   4                              }
 706   3                      }       
 707   2                      USB_REG[0xC2] &= 0xFD;  
 708   2                      USB_REG[0x11]  = 0x00;
 709   2              }
 710   1      }
 711          
 712          /***************************************************************************
 713          * NAME:      void RW_Stage_EtoS(UWORD StartPage,UWORD EndPage,bit L_E)
 714          * DESCRIPTION:
 715          *     This subroutine is to do the Host Read Sector.
 716          *     Input  Vars: small block 
 717          ***************************************************************************/
 718          void RW_Data_Stage(UWORD tw_SourcePage,UWORD tw_TargetPage,U8 tc_Xfe_PageCnt ){ 
 719   1              
 720   1              #if 1// Normal R W
 721   1              data    U8 tc_i;        
 722   1              //U8 tc_Temp;
 723   1              FDBP.cFDev =gc_HDev;
 724   1              for(tc_i=0; tc_i<tc_Xfe_PageCnt ;tc_i++){
 725   2                      //-------------------------------------- //
 726   2                      Device_Read_SRAM_Index.BY[0] = 0x80;
 727   2                      Device_Read_SRAM_Index.BY[1] = 0x00;            
 728   2                      FDBP.cFPlane = tw_SourcePage%NAND_INFO.cPLANE_NUM;
 729   2                      FDBP.wFBlock = APort_FBlock[0];// source block 
 730   2                      FDBP.wFPage  = tw_SourcePage/NAND_INFO.cPLANE_NUM;
 731   2                      FDBP.cFInAddr =0;
 732   2                      Flash_Sequent_Read(NAND_INFO.cINADDRMAX);
 733   2                      //--------------------------------------//
 734   2                      Device_Write_SRAM_Index.BY[0] = 0x80;
 735   2                      Device_Write_SRAM_Index.BY[1] = 0x00;           
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 13  

 736   2                      FDBP.cFPlane = tw_TargetPage%NAND_INFO.cPLANE_NUM;
 737   2                      FDBP.wFBlock = APort_FBlock[1];// Target block
 738   2                      FDBP.wFPage  = tw_TargetPage/NAND_INFO.cPLANE_NUM;
 739   2                      FDBP.cFInAddr =0;
 740   2                      Flash_Sequent_Write(NAND_INFO.cINADDRMAX,1);
 741   2                      tw_SourcePage++;
 742   2                      tw_TargetPage++;
 743   2              }
 744   1              #endif 
 745   1      
 746   1      }
 747          /*********************************************************************************
 748          * NAME:                  void NAND_OverWrite_Mode(U8 tc_Extend_Count)
 749          * DESCRIPTION:以SBlock 方式來處理
 750          *********************************************************************************/
 751          void NAND_OverWrite_Mode(U8 tc_Extend_Count){
 752   1              data    U8      tc_XferPageCnt;
 753   1              data    U8      tc_Pre_XferCnt;
 754   1              data    U8      tc_BigSectorCnt;
 755   1              data    U8      tc_SmallSectorCnt;
 756   1              data    U8      tc_Offset;
 757   1              data    U8      tc_Page_Offset;
 758   1              data    bit     tbt_DoSendCommand;
 759   1              gbt_Send_80_81_CMD =0;
 760   1              tc_Page_Offset=0;
 761   1              //NAND_Set_Mark_Register(0);// set mark register        
 762   1              
 763   1              if(gbt_Data_In_Buf){// 處理先前零碎或是無法寫滿一個page
 764   2                      if(gc_HInAddr){
 765   3                              tc_XferPageCnt= NAND_INFO.cINADDRMAX-gc_HInAddr;
 766   3                      }
 767   2                      else{   
 768   3                              tc_XferPageCnt = NAND_INFO.cINADDRMAX;
 769   3                      }
 770   2                      tc_Pre_XferCnt = (tc_XferPageCnt<=TotalXferPageNum.WD)? tc_XferPageCnt: TotalXferPageNum.WD;            
 771   2                      USB_Rcevie_Data_To_BUf(gc_HInAddr,tc_Pre_XferCnt);      
 772   2                      TotalXferPageNum.WD = TotalXferPageNum.WD- tc_Pre_XferCnt;
 773   2                      Device_Write_SRAM_Index.BY[0] = 0x80;                   
 774   2                      Device_Write_SRAM_Index.BY[1] = 0x00;
 775   2                      NAND_SBlock_SPage_To_FDBP(); // 
 776   2                      Flash_Sequent_Write(NAND_INFO.cINADDRMAX,1);
 777   2                      gbt_USB_Data_In_Buf =0;
 778   2                      gbt_Data_In_Buf =0;
 779   2                      gc_SPage++;
 780   2                      gw_TargetPage++;        
 781   2                      gc_HInAddr =0;
 782   2                      HPage.WD++;
 783   2                      tc_Page_Offset ++;
 784   2                      if(!gbt_USB_Detected){
 785   3                              goto USB_CLOSE_BLOCK;
 786   3                      }
 787   2                      
 788   2              }
 789   1              
 790   1              tc_BigSectorCnt = TotalXferPageNum.WD/NAND_INFO.cINADDRMAX;
 791   1              tc_SmallSectorCnt = TotalXferPageNum.WD%NAND_INFO.cINADDRMAX;
 792   1              if(gc_SPage==H_INFO.cSMALLPAGE_NUM){
 793   2                      tc_Offset = tc_Extend_Count*MAX_DUMMY_PAGE;
 794   2                      SQTable.BY[1] = gc_SPage;
 795   2                      Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex] = SQTable.WD;
 796   2                      QTable.BY[0] =gc_SBlock;
 797   2                      QTable.BY[1] =gc_T_SBlock;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 14  

 798   2                      Mapping_Table[D_HPAGE+tc_Offset+gc_NowIndex] = QTable.WD;               
 799   2                      QTable.WD= Mapping_Table[Q1_INX+tc_Extend_Count];
 800   2                      QTable.BY[1] =gc_T_SBlock+1;
 801   2                      Mapping_Table[Q1_INX+tc_Extend_Count]=QTable.WD;
 802   2                      return;
 803   2              }
 804   1              if(tc_BigSectorCnt){//full page write
 805   2                      if(!gbt_USB_Data_In_Buf){
 806   3                              USB_Bank0_1_BulkOut(0,1);
 807   3                              USB_CHK_Bank0_1_BulkOut_Done(0);                
 808   3                      }
 809   2                      if(!gbt_USB_Detected){
 810   3                              goto USB_CLOSE_BLOCK;
 811   3                      }               
 812   2                      NAND_SBlock_SPage_To_FDBP(); // 
 813   2                      if(FDBP.cFPlane||(tc_BigSectorCnt==1)||(gc_SPage == (H_INFO.cSMALLPAGE_NUM-1))){
 814   3                              gc_Flash_CMD1 =0x80;
 815   3                              gc_Flash_CMD2 =0x10;
 816   3                              gbt_Send_80_81_CMD =0;
 817   3                      }
 818   2                      else{
 819   3                              gc_Flash_CMD1 =0x80;
 820   3                              if(NAND_INFO.cSUPPORT_CACHE_RW){                        
 821   4                                      gc_Flash_CMD2 =0x15;// 2_plan:0x11
 822   4                              }
 823   3                              else{
 824   4                                      gc_Flash_CMD2=0x10;
 825   4                              }
 826   3                              gbt_Send_80_81_CMD =1;
 827   3                      }               
 828   2                      NAND_Set_Mark_Register(0);
 829   2                      gc_Flash_CMD_Type = 0x0F;//0630 Jay fix for Hynix M die
 830   2                      Device_Write_SRAM_Index.BY[0] = USB_BUF_Bank0_HIGH;;
 831   2                      Device_Write_SRAM_Index.BY[1] = 0x00;                   
 832   2                      Device_Xfer_DataLength.WD = 0x03FF;                     
 833   2                      SET_DEVICE_WRITE();
 834   2                      ENA_ECC_Encode();
 835   2                      TRIGGER_FLASH_CMD_COL_ADDR_CMD();
 836   2                      tbt_DoSendCommand =0;
 837   2                      gbt_OddTemp=0;
 838   2                      gc_HInAddr =0;
 839   2                      while(tc_BigSectorCnt) {// 處理以page為單位的data               
 840   3                              
 841   3                              if (gc_SPage == H_INFO.cSMALLPAGE_NUM) {
 842   4                                      
 843   4                                      tc_Offset = tc_Extend_Count*MAX_DUMMY_PAGE;
 844   4                                      SQTable.BY[1] = gc_SPage;                       
 845   4                                      Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex] =SQTable.WD;
 846   4                                      QTable.BY[0] =gc_SBlock;
 847   4                                      QTable.BY[1] =gc_T_SBlock;
 848   4                                      Mapping_Table[D_HPAGE+tc_Offset+gc_NowIndex] = QTable.WD;
 849   4                                      QTable.WD= Mapping_Table[Q1_INX+tc_Extend_Count];
 850   4                                      QTable.BY[1] =gc_T_SBlock+1;
 851   4                                      Mapping_Table[Q1_INX+tc_Extend_Count]=QTable.WD;                                
 852   4                                      
 853   4                                      return ;
 854   4                              }                       
 855   3                              
 856   3                              if (tbt_DoSendCommand) {
 857   4                                      NAND_SBlock_SPage_To_FDBP();
 858   4                                      if(gbt_Send_80_81_CMD){
 859   5                                              gc_Flash_CMD1 =0x80;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 15  

 860   5                                              if(NAND_INFO.cSUPPORT_CACHE_RW){                        
 861   6                                                      gc_Flash_CMD2 =0x15;// 2_plan:0x11
 862   6                                              }
 863   5                                              else{
 864   6                                                      gc_Flash_CMD2=0x10;
 865   6                                              }
 866   5                                              gbt_Send_80_81_CMD=0;
 867   5                                      }
 868   4                                      else{
 869   5                                              gc_Flash_CMD1 =0x80;
 870   5                                              if(NAND_INFO.cSUPPORT_CACHE_RW){                        
 871   6                                                      gc_Flash_CMD2 =0x15;// 2_plan:0x11
 872   6                                              }
 873   5                                              else{
 874   6                                                      gc_Flash_CMD2=0x10;
 875   6                                              }
 876   5                                              gbt_Send_80_81_CMD=1;
 877   5                                      }                                       
 878   4                                      if((tc_BigSectorCnt==1)||(gc_SPage == (H_INFO.cSMALLPAGE_NUM-1))){
 879   5                                              gc_Flash_CMD2 = 0x10;
 880   5                                      }
 881   4                                      gc_Flash_CMD_Type = 0x0F;//0630 Jay fix for Hynix M die                         
 882   4                                      tbt_DoSendCommand =0;
 883   4                                      TRIGGER_FLASH_CMD_COL_ADDR_CMD();       
 884   4                              }                       
 885   3                              for(gc_HInAddr=0; gc_HInAddr<NAND_INFO.cINADDRMAX;gc_HInAddr+=2){
 886   4                                      if(gc_HInAddr==(NAND_INFO.cINADDRMAX-2)){
 887   5                                              FLASH_REG[0x1A] =0x11;
 888   5                                              if((tc_BigSectorCnt==1)||(gc_SPage == (H_INFO.cSMALLPAGE_NUM-1))){
 889   6                                                      tc_Pre_XferCnt =0;
 890   6                                              }
 891   5                                              else{
 892   6                                                      tc_Pre_XferCnt =2;
 893   6                                              }                               
 894   5                                      }
 895   4                                      else{
 896   5                                              FLASH_REG[0x1A] =0x10;
 897   5                                              tc_Pre_XferCnt =2;
 898   5                                      }               
 899   4      
 900   4                                      NAND_Set_Mark_Register((gc_HInAddr>>1)&0x01);
 901   4                                              
 902   4                                      if(gbt_OddTemp) { //Bank 1-> Flash, USB -> Bank 0
 903   5                                              USB_CHK_Bank0_1_BulkOut_Done(1); //chk Bank 0 done
 904   5                                              if(!gbt_USB_Detected){
 905   6                                                      goto USB_CLOSE_BLOCK;
 906   6                                              }               
 907   5                                              CPU_REG[0x13]    = USB_BUF_Bank1_HIGH;                  // 080104 joyce add
 908   5                                              CPU_REG[0x12]    = 0x00;
 909   5                                              DEVICE_REG[0xA0] = 0x01;                                                //Reset ECC
 910   5                                              FLASH_REG[0xA0]  = 0x01;                                                //Start Encode RS-Code
 911   5                                              Trigger_Data_Transfer();                                                                
 912   5                                              if(tc_Pre_XferCnt){
 913   6                                                      USB_Bank0_1_BulkOut(0,1);
 914   6                                              }
 915   5                                      }
 916   4                                      else { //Bank 0 -> Flash, USB -> Bank 1
 917   5                                              USB_CHK_Bank0_1_BulkOut_Done(0);// chk Bank 1 done              
 918   5                                              if(!gbt_USB_Detected){
 919   6                                                      goto USB_CLOSE_BLOCK;
 920   6                                              }               
 921   5                                              
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 16  

 922   5                                              CPU_REG[0x13]    = USB_BUF_Bank0_HIGH;                  // 080104 joyce mark
 923   5                                              CPU_REG[0x12]    = 0x00;
 924   5                                              DEVICE_REG[0xA0] = 0x01;                                                //Reset ECC
 925   5                                              FLASH_REG[0xA0]  = 0x01;                                                //Start Encode RS-Code                                                                          
 926   5                                              Trigger_Data_Transfer();                                                
 927   5                                              if(tc_Pre_XferCnt){
 928   6                                                      USB_Bank0_1_BulkOut(1,1);
 929   6                                                      
 930   6                                              }
 931   5                                      }               
 932   4                                      gbt_OddTemp = !(gbt_OddTemp);
 933   4                                      TotalXferPageNum.WD-=2;
 934   4                                      CHK_Data_Transfer_Done();
 935   4                                      while (FLASH_REG[0xA2] & 0x40);                                                 
 936   4                                      CHK_NandAutocmp_Done();
 937   4                              }                       
 938   3                              if(gc_HInAddr==NAND_INFO.cINADDRMAX){
 939   4                                      FLASH_REG[0x06]  = gc_Flash_CMD2;//     0630 Jay add                                                            
 940   4                                      FLASH_REG[0x04] = 0x08;                                                                         
 941   4                                      TRIGGER_FLASH_CMD();
 942   4                                      gc_HInAddr =0;
 943   4                                      gc_SPage++;
 944   4                                      gw_TargetPage++;
 945   4                                      tc_BigSectorCnt--;
 946   4                                      HPage.WD++;
 947   4                                      tc_Page_Offset ++;
 948   4                                      tbt_DoSendCommand = 1;                                                          
 949   4                                      gbt_USB_Data_In_Buf=0;//目前usb data buf 內已經沒有任何資料了∼
 950   4                              }
 951   3                              
 952   3                      }// end while loop      
 953   2                      if (gc_SPage == H_INFO.cSMALLPAGE_NUM) {
 954   3                                      
 955   3                              tc_Offset = tc_Extend_Count*MAX_DUMMY_PAGE;
 956   3                              SQTable.BY[1] = gc_SPage;                       
 957   3                              Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex] =SQTable.WD;
 958   3                              QTable.BY[0] =gc_SBlock;
 959   3                              QTable.BY[1] =gc_T_SBlock;
 960   3                              Mapping_Table[D_HPAGE+tc_Offset+gc_NowIndex] = QTable.WD;
 961   3                              QTable.WD= Mapping_Table[Q1_INX+tc_Extend_Count];
 962   3                              QTable.BY[1] =gc_T_SBlock+1;
 963   3                              Mapping_Table[Q1_INX+tc_Extend_Count]=QTable.WD;                                
 964   3                              
 965   3                              return ;
 966   3                      }       
 967   2              
 968   2              
 969   2              
 970   2              }
 971   1      
 972   1              if(tc_SmallSectorCnt){  //處理後面的零碎檔案
 973   2                      
 974   2                      tc_Offset = tc_Extend_Count*MAX_DUMMY_PAGE;//0622 Jay fix
 975   2                      QTable.WD= Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex];
 976   2                      if((gc_SPage>=QTable.BY[0])&&(gc_SPage<QTable.BY[1])){
 977   3                              APort_FBlock[0]= APort_DBlock[0];
 978   3                              gw_SourcePage=((U16)gc_D_SBlock*H_INFO.cSMALLPAGE_NUM)+(gc_SPage-QTable.BY[0]);
 979   3                              
 980   3                      }
 981   2                      else{           
 982   3                              if(gc_SBlock<gc_Q1_SBlock){
 983   4                                      APort_FBlock[0] = APort_LBlock[0];
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 17  

 984   4                              }
 985   3                              else{                   
 986   4                                      APort_FBlock[0]= APort_EBlock[0];
 987   4                              }                                       
 988   3                              gw_SourcePage=((U16)gc_SBlock*H_INFO.cSMALLPAGE_NUM)+gc_SPage;
 989   3                      }
 990   2                      NAND_Laod_Data_To_Buf(gw_SourcePage,0);
 991   2                      //---------- USB To RAM----------//
 992   2                      gbt_OddTemp=0;  
 993   2                      USB_Rcevie_Data_To_BUf(gc_HInAddr,tc_SmallSectorCnt);
 994   2                      TotalXferPageNum.WD-=tc_SmallSectorCnt;
 995   2                      Device_Write_SRAM_Index.BY[0] = 0x80;                   
 996   2                      Device_Write_SRAM_Index.BY[1] = 0x00;
 997   2                      APort_FBlock[0]= APort_DBlock[0];               
 998   2                      NAND_SBlock_SPage_To_FDBP();            
 999   2                      Flash_Sequent_Write(NAND_INFO.cINADDRMAX,1);
1000   2                      gbt_USB_Data_In_Buf =0;
1001   2                      gc_SPage++;
1002   2                      gw_TargetPage++;        
1003   2                      gc_HInAddr =0;
1004   2                      HPage.WD++;
1005   2                      tc_Page_Offset ++;
1006   2                      
1007   2              }
1008   1      USB_CLOSE_BLOCK:        
1009   1              if (gc_SPage == H_INFO.cSMALLPAGE_NUM) {
1010   2                      tc_Offset = tc_Extend_Count*MAX_DUMMY_PAGE;
1011   2                      SQTable.BY[1] = gc_SPage;                       
1012   2                      Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex] =SQTable.WD;
1013   2                      QTable.BY[0] =gc_SBlock;
1014   2                      QTable.BY[1] =gc_T_SBlock;
1015   2                      Mapping_Table[D_HPAGE+tc_Offset+gc_NowIndex] = QTable.WD;
1016   2                      QTable.WD= Mapping_Table[Q1_INX+tc_Extend_Count];
1017   2                      QTable.BY[1] =gc_T_SBlock+1;
1018   2                      Mapping_Table[Q1_INX+tc_Extend_Count]=QTable.WD;
1019   2                      
1020   2                      return ;
1021   2              }               
1022   1              else{// 重新整理Table   
1023   2                      
1024   2                      gc_Q1_SBlock = (Mapping_Table[Q1_INX+tc_Extend_Count]>>8);
1025   2                      tc_Offset = tc_Extend_Count*MAX_DUMMY_PAGE;
1026   2                      QTable.WD= Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex];
1027   2                      
1028   2                      if(gc_SPage<QTable.BY[0]){                      
1029   3                              
1030   3                              if(gc_SBlock<gc_Q1_SBlock){
1031   4                                      APort_FBlock[0] = APort_LBlock[0];
1032   4                              }
1033   3                              else{                   
1034   4                                      APort_FBlock[0]= APort_EBlock[0];
1035   4                              }                       
1036   3                              APort_FBlock[1]= APort_DBlock[0];
1037   3                              tc_XferPageCnt = QTable.BY[0]-gc_SPage;
1038   3                              
1039   3                              gw_SourcePage=((U16)gc_SBlock*H_INFO.cSMALLPAGE_NUM)+gc_SPage;
1040   3                      //gw_TargetPage=((U16)gc_T_SBlock*H_INFO.cSMALLPAGE_NUM)+tc_Page_Offset;//0520 Jay mark                                 
1041   3                              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );
1042   3                              //tc_Page_Offset += tc_XferPageCnt;//0520 Jay mark
1043   3                              gw_TargetPage+=tc_XferPageCnt;//0520 Jay add
1044   3                              // move Q1~Q2 to new D SBlock   
1045   3                              APort_FBlock[0]= APort_DBlock[0];
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 18  

1046   3                              APort_FBlock[1]= APort_DBlock[0];
1047   3                              tc_XferPageCnt = QTable.BY[1]-QTable.BY[0];
1048   3                              
1049   3                              gw_SourcePage=((U16)gc_D_SBlock*H_INFO.cSMALLPAGE_NUM)+0;
1050   3                      //gw_TargetPage=((U16)gc_T_SBlock*H_INFO.cSMALLPAGE_NUM)+tc_Page_Offset;//0520 Jay mark                                 
1051   3                              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );
1052   3                              //tc_Offset = tc_Extend_Count*MAX_RANDOM_HPAGE;
1053   3                              Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex] =SQTable.WD;
1054   3                              
1055   3                              
1056   3                      }               
1057   2                      else if((gc_SPage>=QTable.BY[0])&&(gc_SPage<QTable.BY[1])){
1058   3                              
1059   3                              APort_FBlock[0]= APort_DBlock[0];
1060   3                              APort_FBlock[1]= APort_DBlock[0];
1061   3                              tc_XferPageCnt = QTable.BY[1]-gc_SPage;
1062   3                              
1063   3                              gw_SourcePage=((U16)gc_D_SBlock*H_INFO.cSMALLPAGE_NUM)+(gc_SPage-QTable.BY[0]);
1064   3                      //gw_TargetPage=((U16)gc_T_SBlock*H_INFO.cSMALLPAGE_NUM)+tc_Page_Offset;//0520 Jay mark                                         
1065   3                              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );
1066   3                              //tc_Offset = tc_Extend_Count*MAX_RANDOM_HPAGE;
1067   3                              Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex] =SQTable.WD;
1068   3                              
1069   3                              
1070   3                      }
1071   2                      else{  //gc_SPage>QTable.BY[1]
1072   3                              //tc_Offset = tc_Extend_Count*MAX_RANDOM_HPAGE;
1073   3                              SQTable.BY[1] = gc_SPage;
1074   3                              Mapping_Table[D_PAGE+tc_Offset+gc_NowIndex] =SQTable.WD;
1075   3                              
1076   3                      }
1077   2              
1078   2                      QTable.BY[0] =gc_SBlock;
1079   2                      QTable.BY[1] =gc_T_SBlock;              
1080   2                      Mapping_Table[D_HPAGE+tc_Offset+gc_NowIndex] = QTable.WD;
1081   2                      QTable.WD= Mapping_Table[Q1_INX+tc_Extend_Count];
1082   2                      QTable.BY[1] =gc_T_SBlock+1;            
1083   2                      Mapping_Table[Q1_INX+tc_Extend_Count]=QTable.WD;
1084   2              }
1085   1              
1086   1      }
1087          
1088          /*********************************************************************************
1089          * NAME:                  void NAND_OverWrite_Mode(U8 tc_Extend_Count)
1090          * DESCRIPTION:
1091          *********************************************************************************/
1092          void NAND_SequentWrite_Mode(U8 tc_Extend_Count)
1093          {
1094   1              data    bit     tbt_Find_D_SBlock;      
1095   1              data    U8      tc_XferPageCnt;
1096   1              data    U8      tc_Pre_XferCnt;
1097   1              data    U8      tc_BigSectorCnt;
1098   1              data    U8      tc_SmallSectorCnt;
1099   1              data    U8      tc_Offset;
1100   1              data    U8      tc_i;
1101   1              data    bit tbt_DoSendCommand;
1102   1              gbt_Send_80_81_CMD =0;
1103   1              //tc_Page_Offset=0;     
1104   1              tbt_Find_D_SBlock=0;
1105   1              USB_PlugDetect();                                                                                       // 081014 Jay add for usb plug out
1106   1              if(!gbt_USB_Detected){
1107   2                      return ;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 19  

1108   2              }
1109   1              NAND_Set_Mark_Register(0);// set mark register
1110   1              if(gbt_Data_In_Buf){// 處理先前零碎或是無法寫滿一個page
1111   2                      if(gc_HInAddr){
1112   3                              tc_XferPageCnt= NAND_INFO.cINADDRMAX-gc_HInAddr;
1113   3                      }
1114   2                      else{   
1115   3                              tc_XferPageCnt = NAND_INFO.cINADDRMAX;
1116   3                      }
1117   2                      tc_Pre_XferCnt = (tc_XferPageCnt<=TotalXferPageNum.WD)? tc_XferPageCnt: TotalXferPageNum.WD;
1118   2                      USB_Rcevie_Data_To_BUf(gc_HInAddr,tc_Pre_XferCnt);      
1119   2                      TotalXferPageNum.WD = TotalXferPageNum.WD- tc_Pre_XferCnt;
1120   2                      Device_Write_SRAM_Index.BY[0] = 0x80;                   
1121   2                      Device_Write_SRAM_Index.BY[1] = 0x00;
1122   2                      NAND_SBlock_SPage_To_FDBP(); // 
1123   2                      Flash_Sequent_Write(NAND_INFO.cINADDRMAX,1);
1124   2                      gbt_USB_Data_In_Buf =0;
1125   2                      gbt_Data_In_Buf =0;
1126   2                      gc_SPage++;
1127   2                      gw_TargetPage++;        
1128   2                      gc_HInAddr =0;
1129   2                      HPage.WD++;
1130   2                      //tc_Page_Offset ++;
1131   2                      if(gw_TargetPage==H_INFO.wHBLOCKPAGE){// 準備換HBlock 　
1132   3                              gc_Q1_SBlock = (Mapping_Table[Q1_INX+tc_Extend_Count]>>8);
1133   3                              tc_Offset= (tc_Extend_Count* MAX_DUMMY_PAGE); 
1134   3                              tbt_Find_D_SBlock =0;
1135   3                              for(tc_i=0; tc_i<MAX_DUMMY_PAGE;tc_i++){
1136   4                                      if(Mapping_Table[D_HPAGE+tc_Offset+tc_i]!=0xFFFF){
1137   5                                              tbt_Find_D_SBlock=1;
1138   5                                              break;
1139   5                                      }
1140   4                              }
1141   3                              if(tbt_Find_D_SBlock||gc_Q1_SBlock){
1142   4                                      QTable.BY[0] =H_INFO.cSMALLBLOCK_NUM;
1143   4                                      QTable.BY[1] = 0x00;
1144   4                                      Mapping_Table[Q2_INX+tc_Extend_Count]=QTable.WD;        
1145   4                                      NAND_Combin_E_D_To_New_E(tc_Extend_Count,H_INFO.cSMALLBLOCK_NUM);
1146   4                              }               
1147   3                              Mapping_Table[HBlock.WD] =APort_EBlock[0];
1148   3                              Wear_Table[HBlock.WD] =APort_ECNT[0];
1149   3                              NAND_Erase_Block_LEDR(0);
1150   3                              //Mapping_Table[DBK+tc_Extend_Count] =APort_LBlock[0];
1151   3                              //Wear_Table[DCNT+tc_Extend_Count]= APort_LCNT[0]+1;
1152   3                              /*if(!tbt_Find_D_SBlock){
1153   3                                      NAND_Erase_Block_LEDR(2);
1154   3                                      APort_DCNT[0]+=1;       
1155   3                              }*/
1156   3                              Mapping_Table[SBK] =APort_LBlock[0];
1157   3                              Wear_Table[SCNT] =(APort_LCNT[0]+1);
1158   3                              Mapping_Table[EBK+tc_Extend_Count] =APort_SBlock[0];
1159   3                              Wear_Table[ECNT+tc_Extend_Count]=APort_SCNT[0];
1160   3                              Mapping_Table[EINX+tc_Extend_Count]=0xFFFF;
1161   3                              Mapping_Table[Q2_INX+tc_Extend_Count]=0x0000;                   
1162   3                              Mapping_Table[Q1_INX+tc_Extend_Count] =0x0000;
1163   3                              //dbprintf("\n0 seq return");                           
1164   3                              return;
1165   3                      }       
1166   2      
1167   2              }
1168   1              if(!gbt_USB_Detected){
1169   2                      goto USB_CLOSE_E_BLOCK;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 20  

1170   2              }
1171   1              //P3_0=0;P3_0=1;
1172   1              tc_BigSectorCnt = TotalXferPageNum.WD/NAND_INFO.cINADDRMAX;
1173   1              tc_SmallSectorCnt= TotalXferPageNum.WD%NAND_INFO.cINADDRMAX;
1174   1              
1175   1              
1176   1              if(tc_BigSectorCnt){//full page write
1177   2                      
1178   2                      if(!gbt_USB_Data_In_Buf){
1179   3                              USB_Bank0_1_BulkOut(0,1);
1180   3                      }
1181   2                      
1182   2                      NAND_SBlock_SPage_To_FDBP(); // 
1183   2                      if(FDBP.cFPlane||(tc_BigSectorCnt==1)||(gw_TargetPage == (H_INFO.wHBLOCKPAGE-1))){
1184   3                              gc_Flash_CMD1 =0x80;
1185   3                              gc_Flash_CMD2 =0x10;
1186   3                              gbt_Send_80_81_CMD =0;
1187   3                      }
1188   2                      else{
1189   3                              gc_Flash_CMD1 =0x80;
1190   3                              if(NAND_INFO.cSUPPORT_CACHE_RW){                        
1191   4                                      gc_Flash_CMD2 =0x15;// 2_plan:0x11
1192   4                              }
1193   3                              else{
1194   4                                      gc_Flash_CMD2=0x10;
1195   4                              }
1196   3                              gbt_Send_80_81_CMD =1;
1197   3                      }               
1198   2                      NAND_Set_Mark_Register(0);
1199   2                      gc_Flash_CMD_Type = 0x0F;//0630 Jay fix for Hynix M die
1200   2                      Device_Write_SRAM_Index.BY[0] = USB_BUF_Bank0_HIGH;;
1201   2                      Device_Write_SRAM_Index.BY[1] = 0x00;                   
1202   2                      Device_Xfer_DataLength.WD = 0x03FF;                     
1203   2                      SET_DEVICE_WRITE();
1204   2                      ENA_ECC_Encode();
1205   2                      TRIGGER_FLASH_CMD_COL_ADDR_CMD();                               
1206   2                      tbt_DoSendCommand =0;
1207   2                      gbt_OddTemp=0;
1208   2                      gc_HInAddr =0;
1209   2                      
1210   2                      while(tc_BigSectorCnt) {// 處理以page為單位的data               
1211   3                              if (gw_TargetPage == H_INFO.wHBLOCKPAGE) {
1212   4                                      
1213   4                                      gc_Q1_SBlock = (Mapping_Table[Q1_INX+tc_Extend_Count]>>8);
1214   4                                      tc_Offset= (tc_Extend_Count* MAX_DUMMY_PAGE); 
1215   4                                      tbt_Find_D_SBlock =0;
1216   4                                      for(tc_i=0; tc_i<MAX_DUMMY_PAGE;tc_i++){
1217   5                                              if(Mapping_Table[D_HPAGE+tc_Offset+tc_i]!=0xFFFF){
1218   6                                                      tbt_Find_D_SBlock=1;
1219   6                                                      break;
1220   6                                              }
1221   5                                      }
1222   4                                      if(tbt_Find_D_SBlock||gc_Q1_SBlock){
1223   5                                              QTable.BY[0] =H_INFO.cSMALLBLOCK_NUM;
1224   5                                              QTable.BY[1] = 0x00;
1225   5                                              Mapping_Table[Q2_INX+tc_Extend_Count]=QTable.WD;        
1226   5                                              NAND_Combin_E_D_To_New_E(tc_Extend_Count,H_INFO.cSMALLBLOCK_NUM);
1227   5                                      }                       
1228   4                                      Mapping_Table[HBlock.WD] =APort_EBlock[0];
1229   4                                      Wear_Table[HBlock.WD] =APort_ECNT[0];
1230   4                                      NAND_Erase_Block_LEDR(0);
1231   4                                      //Mapping_Table[DBK+tc_Extend_Count] =APort_LBlock[0];
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 21  

1232   4                                      //Wear_Table[DCNT+tc_Extend_Count]= APort_LCNT[0]+1;
1233   4                                      /*if(!tbt_Find_D_SBlock){
1234   4                                              NAND_Erase_Block_LEDR(2);
1235   4                                              APort_DCNT[0]+=1;       
1236   4                                      }*/
1237   4                                      Mapping_Table[SBK] =APort_LBlock[0];
1238   4                                      Wear_Table[SCNT] =(APort_LCNT[0]+1);
1239   4                                      Mapping_Table[EBK+tc_Extend_Count] =APort_SBlock[0];
1240   4                                      Wear_Table[ECNT+tc_Extend_Count]=APort_SCNT[0];
1241   4                                      Mapping_Table[EINX+tc_Extend_Count]=0xFFFF;
1242   4                                      Mapping_Table[Q2_INX+tc_Extend_Count]=0x0000;                   
1243   4                                      Mapping_Table[Q1_INX+tc_Extend_Count] =0x0000;
1244   4                                      //dbprintf("\n1 seq return");                           
1245   4                                      return ;
1246   4                              }                       
1247   3                              if (tbt_DoSendCommand) {
1248   4                                      NAND_SBlock_SPage_To_FDBP();
1249   4                                      if(gbt_Send_80_81_CMD){
1250   5                                              gc_Flash_CMD1 =0x80;
1251   5                                              if(NAND_INFO.cSUPPORT_CACHE_RW){                        
1252   6                                                      gc_Flash_CMD2 =0x15;// 2_plan:0x11
1253   6                                              }
1254   5                                              else{
1255   6                                                      gc_Flash_CMD2=0x10;
1256   6                                              }//2_plan 0x11 cache :0x15
1257   5                                              gbt_Send_80_81_CMD=0;
1258   5                                      }
1259   4                                      else{
1260   5                                              gc_Flash_CMD1 =0x80;
1261   5                                              if(NAND_INFO.cSUPPORT_CACHE_RW){                        
1262   6                                                      gc_Flash_CMD2 =0x15;// 2_plan:0x11
1263   6                                              }
1264   5                                              else{
1265   6                                                      gc_Flash_CMD2=0x10;
1266   6                                              }
1267   5                                              gbt_Send_80_81_CMD=1;
1268   5                                      }                                       
1269   4                                      if((tc_BigSectorCnt==1)||(gw_TargetPage == (H_INFO.wHBLOCKPAGE-1))){
1270   5                                              gc_Flash_CMD2 = 0x10;
1271   5                                      }
1272   4                                      gc_Flash_CMD_Type = 0x0F;               //0630 Jay fix for Hynix M die          
1273   4                                      tbt_DoSendCommand =0;
1274   4                                      TRIGGER_FLASH_CMD_COL_ADDR_CMD();       
1275   4                              }                       
1276   3                              
1277   3                              for(gc_HInAddr=0; gc_HInAddr<NAND_INFO.cINADDRMAX;gc_HInAddr+=2){
1278   4                                      
1279   4                                      if(gc_HInAddr==(NAND_INFO.cINADDRMAX-2)){
1280   5                                              FLASH_REG[0x1A] =0x11;
1281   5                                              
1282   5                                              if((tc_BigSectorCnt==1)||(gw_TargetPage == (H_INFO.wHBLOCKPAGE-1))){
1283   6                                                      tc_Pre_XferCnt =0;
1284   6                                              }
1285   5                                              else{
1286   6                                                      tc_Pre_XferCnt =2;
1287   6                                              }                               
1288   5                                      }
1289   4                                      else{
1290   5                                              FLASH_REG[0x1A] =0x10;
1291   5                                              tc_Pre_XferCnt =2;
1292   5                                      }               
1293   4                                      
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 22  

1294   4                                      NAND_Set_Mark_Register((gc_HInAddr>>1)&0x01);
1295   4                                                              
1296   4                                      if(gbt_OddTemp) { //Bank 1-> Flash, USB -> Bank 0
1297   5                                              
1298   5                                              USB_CHK_Bank0_1_BulkOut_Done(1); //chk Bank 0 done
1299   5                                              if(!gbt_USB_Detected){
1300   6                                                      goto USB_CLOSE_E_BLOCK;
1301   6                                              }                                       
1302   5                                              CPU_REG[0x13]    = USB_BUF_Bank1_HIGH;                  // 080104 joyce add
1303   5                                              CPU_REG[0x12]    = 0x00;
1304   5                                              DEVICE_REG[0xA0] = 0x01;                                                //Reset ECC
1305   5                                              FLASH_REG[0xA0]  = 0x01;                                                //Start Encode RS-Code
1306   5                                              Trigger_Data_Transfer();
1307   5                                              
1308   5                                              if(tc_Pre_XferCnt){                                                     
1309   6                                                      USB_Bank0_1_BulkOut(0,1);
1310   6                                                      
1311   6                                              }
1312   5                                      }
1313   4                                      else { //Bank 0 -> Flash, USB -> Bank 1
1314   5                                              
1315   5                                              USB_CHK_Bank0_1_BulkOut_Done(0);// chk Bank 1 done              
1316   5                                              if(!gbt_USB_Detected){
1317   6                                                      goto USB_CLOSE_E_BLOCK;
1318   6                                              }
1319   5                                              
1320   5                                              CPU_REG[0x13]    = USB_BUF_Bank0_HIGH;                  // 080104 joyce mark
1321   5                                              CPU_REG[0x12]    = 0x00;
1322   5                                              DEVICE_REG[0xA0] = 0x01;                                                //Reset ECC
1323   5                                              FLASH_REG[0xA0]  = 0x01;                                                //Start Encode RS-Code                                                                          
1324   5                                              Trigger_Data_Transfer();
1325   5                                              if(tc_Pre_XferCnt){                                             
1326   6                                                      USB_Bank0_1_BulkOut(1,1);
1327   6                                                      
1328   6                                              }
1329   5                                      }               
1330   4                                      gbt_OddTemp = !(gbt_OddTemp);
1331   4                                      TotalXferPageNum.WD-=2;
1332   4                                                                      
1333   4                                      CHK_Data_Transfer_Done();
1334   4                                      while (FLASH_REG[0xA2] & 0x40);                                                 
1335   4                                      CHK_NandAutocmp_Done();
1336   4                              }                       
1337   3                              if(gc_HInAddr==NAND_INFO.cINADDRMAX){
1338   4                                      FLASH_REG[0x06]  = gc_Flash_CMD2;//     0630 Jay add                                                            
1339   4                                      FLASH_REG[0x04] = 0x08;                                                                         
1340   4                                      TRIGGER_FLASH_CMD();
1341   4                                      gc_HInAddr =0;
1342   4                                      gc_SPage++;
1343   4                                      gw_TargetPage++;
1344   4                                      tc_BigSectorCnt--;
1345   4                                      HPage.WD++;                             
1346   4                                      tbt_DoSendCommand = 1;                                                          
1347   4                                      gbt_USB_Data_In_Buf=0;//目前usb data buf 內已經沒有任何資料了∼
1348   4                              }       
1349   3                              
1350   3                      }// end while loop
1351   2                      if (gw_TargetPage == H_INFO.wHBLOCKPAGE) {
1352   3                                      gc_Q1_SBlock = (Mapping_Table[Q1_INX+tc_Extend_Count]>>8);
1353   3                                      tc_Offset= (tc_Extend_Count* MAX_DUMMY_PAGE); 
1354   3                                      tbt_Find_D_SBlock =0;
1355   3                                      for(tc_i=0; tc_i<MAX_DUMMY_PAGE;tc_i++){
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 23  

1356   4                                              if(Mapping_Table[D_HPAGE+tc_Offset+tc_i]!=0xFFFF){
1357   5                                                      tbt_Find_D_SBlock=1;
1358   5                                                      break;
1359   5                                              }
1360   4                                      }
1361   3                                      if(tbt_Find_D_SBlock||gc_Q1_SBlock){
1362   4                                              QTable.BY[0] =H_INFO.cSMALLBLOCK_NUM;
1363   4                                              QTable.BY[1] = 0x00;
1364   4                                              Mapping_Table[Q2_INX+tc_Extend_Count]=QTable.WD;        
1365   4                                              NAND_Combin_E_D_To_New_E(tc_Extend_Count,H_INFO.cSMALLBLOCK_NUM);
1366   4                                      }                       
1367   3                                      
1368   3                                      Mapping_Table[HBlock.WD] =APort_EBlock[0];
1369   3                                      Wear_Table[HBlock.WD] =APort_ECNT[0];
1370   3                                      NAND_Erase_Block_LEDR(0);
1371   3                                      //Mapping_Table[DBK+tc_Extend_Count] =APort_LBlock[0];
1372   3                                      //Wear_Table[DCNT+tc_Extend_Count]= APort_LCNT[0]+1;
1373   3                                      /*if(!tbt_Find_D_SBlock){
1374   3                                              NAND_Erase_Block_LEDR(2);
1375   3                                              APort_DCNT[0]+=1;       
1376   3                                      }*/
1377   3                                      Mapping_Table[SBK] =APort_LBlock[0];
1378   3                                      Wear_Table[SCNT] =(APort_LCNT[0]+1);
1379   3                                      Mapping_Table[EBK+tc_Extend_Count] =APort_SBlock[0];
1380   3                                      Wear_Table[ECNT+tc_Extend_Count]=APort_SCNT[0];
1381   3                                      Mapping_Table[EINX+tc_Extend_Count]=0xFFFF;
1382   3                                      Mapping_Table[Q2_INX+tc_Extend_Count]=0x0000;                   
1383   3                                      Mapping_Table[Q1_INX+tc_Extend_Count] =0x0000;
1384   3                                      //dbprintf("\ntc_bigend seq return");                           
1385   3                                      return ;
1386   3                      }
1387   2                      
1388   2              }
1389   1              if(tc_SmallSectorCnt){  //處理後面的零碎檔案
1390   2              
1391   2                      APort_FBlock[0]= APort_LBlock[0];                                       
1392   2                      gw_SourcePage=HPage.WD;
1393   2                      NAND_Laod_Data_To_Buf(gw_SourcePage,0);
1394   2                      
1395   2                      //---------- USB To RAM----------//
1396   2                      gbt_OddTemp=0;          
1397   2                      USB_Rcevie_Data_To_BUf(gc_HInAddr,tc_SmallSectorCnt);
1398   2                      TotalXferPageNum.WD-=tc_SmallSectorCnt;
1399   2                      Device_Write_SRAM_Index.BY[0] = 0x80;                   
1400   2                      Device_Write_SRAM_Index.BY[1] = 0x00;
1401   2                      APort_FBlock[0]= APort_EBlock[0];
1402   2                      
1403   2                      NAND_SBlock_SPage_To_FDBP(); // 
1404   2                      Flash_Sequent_Write(NAND_INFO.cINADDRMAX,1);//have marked 
1405   2                      gbt_USB_Data_In_Buf =0;
1406   2                      gbt_Data_In_Buf =0;
1407   2                      gw_TargetPage++;        
1408   2                      gc_HInAddr =0;
1409   2                      HPage.WD++;
1410   2                      
1411   2              }
1412   1      USB_CLOSE_E_BLOCK:
1413   1              if (gw_TargetPage == H_INFO.wHBLOCKPAGE)  {
1414   2                      
1415   2                      gc_Q1_SBlock = (Mapping_Table[Q1_INX+tc_Extend_Count]>>8);
1416   2                      tc_Offset= (tc_Extend_Count* MAX_DUMMY_PAGE); 
1417   2                      tbt_Find_D_SBlock =0;
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 24  

1418   2                      for(tc_i=0; tc_i<MAX_DUMMY_PAGE;tc_i++){
1419   3                              if(Mapping_Table[D_HPAGE+tc_Offset+tc_i]!=0xFFFF){
1420   4                                      tbt_Find_D_SBlock=1;
1421   4                                      break;
1422   4                              }
1423   3                      }
1424   2                      if(tbt_Find_D_SBlock||gc_Q1_SBlock){
1425   3                              QTable.BY[0] =H_INFO.cSMALLBLOCK_NUM;
1426   3                              QTable.BY[1] = 0x00;
1427   3                              Mapping_Table[Q2_INX+tc_Extend_Count]=QTable.WD;        
1428   3                              NAND_Combin_E_D_To_New_E(tc_Extend_Count,H_INFO.cSMALLBLOCK_NUM);
1429   3                      }               
1430   2                      Mapping_Table[HBlock.WD] =APort_EBlock[0];
1431   2                      Wear_Table[HBlock.WD] =APort_ECNT[0];
1432   2                      NAND_Erase_Block_LEDR(0);
1433   2                      //Mapping_Table[DBK+tc_Extend_Count] =APort_LBlock[0];
1434   2                      //Wear_Table[DCNT+tc_Extend_Count]= APort_LCNT[0]+1;
1435   2                      /*if(!tbt_Find_D_SBlock){
1436   2                              NAND_Erase_Block_LEDR(2);
1437   2                              APort_DCNT[0]+=1;       
1438   2                      }*/
1439   2                      Mapping_Table[SBK] =APort_LBlock[0];
1440   2                      Wear_Table[SCNT] =(APort_LCNT[0]+1);
1441   2                      Mapping_Table[EBK+tc_Extend_Count] =APort_SBlock[0];
1442   2                      Wear_Table[ECNT+tc_Extend_Count]=APort_SCNT[0];
1443   2                      Mapping_Table[EINX+tc_Extend_Count]=0xFFFF;
1444   2                      Mapping_Table[Q2_INX+tc_Extend_Count]=0x0000;                   
1445   2                      Mapping_Table[Q1_INX+tc_Extend_Count] =0x0000;
1446   2                      
1447   2                      return ;
1448   2              }               
1449   1              else{
1450   2                      
1451   2                      QTable.BY[0] = HPage.WD/H_INFO.cSMALLPAGE_NUM;
1452   2                      QTable.BY[1] = HPage.WD%H_INFO.cSMALLPAGE_NUM; 
1453   2                      Mapping_Table[Q2_INX+tc_Extend_Count ] =QTable.WD;
1454   2                      
1455   2              }       
1456   1              
1457   1      }
1458          
1459          
1460          /***************************************************************************
1461          * NAME:      void RW_Stage_EtoS_Copyback(UWORD StartPage,UWORD EndPage,bit L_E)
1462          * DESCRIPTION:
1463          *     This subroutine is to do the Host Read Sector.
1464          *     Input  Vars: L_E =1;Last to Swap
1465          ***************************************************************************/
1466          void NAND_Laod_Data_To_Buf(UWORD tw_StartPage,U8 tc_Bufaddr){ 
1467   1              xdata   U8      tc_XferCnt;
1468   1              FDBP.cFDev =gc_HDev;
1469   1              Device_Read_SRAM_Index.BY[0] = 0x80+(tc_Bufaddr<<1);
1470   1              Device_Read_SRAM_Index.BY[1] = 0x00;            
1471   1              FDBP.cFPlane = tw_StartPage%NAND_INFO.cPLANE_NUM;
1472   1              FDBP.wFBlock = APort_FBlock[0];// source block 
1473   1              FDBP.wFPage  = tw_StartPage/NAND_INFO.cPLANE_NUM;
1474   1              FDBP.cFInAddr= tc_Bufaddr;
1475   1              tc_XferCnt = (NAND_INFO.cINADDRMAX-tc_Bufaddr);
1476   1              Flash_Sequent_Read(tc_XferCnt);
1477   1      
1478   1      }
1479          /*********************************************************************************
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 25  

1480          * NAME:                  void Flash_Close_SmallBlock(void)
1481          * DESCRIPTION:
1482          *********************************************************************************/
1483          void NAND_Close_Random_Block(void){
1484   1              data    U16 tw_Page;
1485   1              data    U8      tc_Offset;
1486   1              data    U8      tc_Inx;
1487   1              data    U8      tc_i;
1488   1              xdata   U8      tc_XferPageCnt;
1489   1              tw_Page =0;
1490   1              ZSpare[0] =0x55;
1491   1      //dbprintf("X ");       
1492   1              for(tc_Inx=0; tc_Inx<MAX_RANDOM_HBLOCK;tc_Inx++){
1493   2                      ZSpare[4+tc_Inx]= Wear_Table[RINX+tc_Inx];
1494   2              }
1495   1              APort_FBlock[0] = APort_RBlock[0];  // source block 
1496   1              APort_FBlock[1] = APort_SBlock[0];      // target block 
1497   1              for(tc_Inx=0; tc_Inx<MAX_RANDOM_HBLOCK;tc_Inx++){
1498   2                      //ZSpare[2] =0xFF;
1499   2                      if(Wear_Table[RINX+tc_Inx]!=0xFF){//表示有效的random block 
1500   3                              tc_Offset = tc_Inx*MAX_RANDOM_HPAGE;
1501   3                              ZSpare[2] = Wear_Table[RINX+tc_Inx];            
1502   3                              for(tc_i=0; tc_i<MAX_RANDOM_HPAGE;tc_i++){
1503   4                                      QTable.WD = Mapping_Table[R_HPAGE+tc_Offset+tc_i];
1504   4                                      if(QTable.WD!=0xFFFF){ // random page是有效的
1505   5                                              ZSpare[1] = QTable.BY[0];
1506   5                                              ZSpare[3] = QTable.BY[1];
1507   5                                              gw_SourcePage = Mapping_Table[R_PAGE+tc_Offset+tc_i];
1508   5                                              gw_TargetPage = tw_Page;
1509   5                                              tc_XferPageCnt = RANDOM_SBLK_SIZE;                              
1510   5                                              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt);
1511   5                                              Mapping_Table[R_PAGE+tc_Offset+tc_i] =tw_Page;
1512   5                                              tw_Page++;
1513   5                                      }       
1514   4                              }       
1515   3                      }
1516   2              }
1517   1              // Updata Mapping Table //
1518   1              Mapping_Table[RBK]=APort_SBlock[0];
1519   1              Wear_Table[RCNT]= APort_SCNT[0];
1520   1              Mapping_Table[SBK] =APort_RBlock[0];                            
1521   1              Wear_Table[SCNT]  =(APort_RCNT[0]+1);
1522   1              NAND_Erase_Block_LEDR(3);       
1523   1              Mapping_Table[RPAGEINX]=tw_Page; // new RPAGEINX        
1524   1              APort_RBlock[0] = Mapping_Table[RBK]; 
1525   1              APort_SBlock[0] = Mapping_Table[SBK];
1526   1              APort_RCNT[0] = Wear_Table[RCNT];
1527   1              APort_SCNT[0] = Wear_Table[SCNT];
1528   1              
1529   1      }
1530          /*********************************************************************************
1531          * NAME:      void NAND_Close_Dummy(U8 tc_Inx)
1532          * DESCRIPTION:先判斷是否Ext &Dummy 是否已經超過一半了
1533          *********************************************************************************/
1534          void NAND_Close_Dummy_Block(U8 tc_Inx){
1535   1              data    U8      tc_i;
1536   1              data    U8      tc_Offset;
1537   1              data    U8      tc_XferPageCnt;
1538   1              data    U8      tc_D_SBlock=0;
1539   1      //dbprintf("Y ");       
1540   1              tc_Offset= (tc_Inx* MAX_DUMMY_PAGE); 
1541   1              for(tc_i=0; tc_i<MAX_DUMMY_PAGE;tc_i++){
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 26  

1542   2                      if(Mapping_Table[D_HPAGE+tc_Offset+tc_i]!=0xFFFF){
1543   3                              tc_i++;
1544   3                              break;
1545   3                      }
1546   2              }
1547   1              if(tc_i>(MAX_DUMMY_PAGE>>1)){//被佔了超過一半的位置直接收起來吧
1548   2                      tc_XferPageCnt=Mapping_Table[Q2_INX+tc_Inx]>>8;//借用變數而已
1549   2                      NAND_Combin_E_D_To_New_E(tc_Inx,tc_XferPageCnt);
1550   2              }               
1551   1              else{//沒有超過一半表示是一直寫同一個位置-->處理Dummy block 即可
1552   2                      APort_FBlock[0]= APort_DBlock[0];
1553   2                      APort_FBlock[1]= APort_SBlock[0];                               
1554   2                      for(tc_i=0; tc_i<MAX_DUMMY_PAGE;tc_i++){
1555   3                              if(Mapping_Table[D_HPAGE+tc_Offset+tc_i]!=0xFFFF){
1556   4                                      QTable.WD= Mapping_Table[D_HPAGE+tc_Offset+tc_i];
1557   4                                      SQTable.WD = Mapping_Table[D_PAGE+tc_Offset+tc_i];
1558   4                                      ZSpare[0] = 0x5A;                                                       ZSpare[1] = QTable.BY[0];
1559   4                                      ZSpare[2] = Mapping_Table[EINX+tc_Inx];         ZSpare[3] = SQTable.BY[0];
1560   4                                      ZSpare[4] = 0x5A;                                                       ZSpare[5] = QTable.BY[0];
1561   4                                      ZSpare[6] = Mapping_Table[EINX+tc_Inx];         ZSpare[7] = SQTable.BY[0];                      
1562   4                                      gw_SourcePage=((U16)QTable.BY[1]*H_INFO.cSMALLPAGE_NUM)+0;
1563   4                              gw_TargetPage=((U16)tc_D_SBlock*H_INFO.cSMALLPAGE_NUM)+0;                                       
1564   4                                      tc_XferPageCnt = SQTable.BY[1]-SQTable.BY[0];
1565   4                                      RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );                     
1566   4                                      QTable.BY[1] =tc_D_SBlock;//update 相對應的 D_SBlock 
1567   4                                      Mapping_Table[D_HPAGE+tc_Offset+tc_i]=QTable.WD;
1568   4                                      tc_D_SBlock++;
1569   4                              }
1570   3                      }
1571   2                      // update Mapping_Table
1572   2                      Mapping_Table[DBK+tc_Inx] =APort_SBlock[0];
1573   2                      Wear_Table[DCNT+tc_Inx] =APort_SCNT[0];
1574   2                      NAND_Erase_Block_LEDR(2);
1575   2                      Mapping_Table[SBK]= APort_DBlock[0];
1576   2                      Wear_Table[SCNT]= APort_DCNT[1]+1;
1577   2                      QTable.WD =Mapping_Table[Q1_INX+tc_Inx];
1578   2                      QTable.BY[1] =tc_D_SBlock;
1579   2                      Mapping_Table[Q1_INX+tc_Inx] =QTable.WD;
1580   2                      APort_DBlock[0]= Mapping_Table[DBK+tc_Inx];
1581   2                      APort_DCNT[0] = Wear_Table[DCNT+tc_Inx];
1582   2                      APort_SBlock[0]=Mapping_Table[SBK];
1583   2                      APort_SCNT[0] = Wear_Table[SCNT];
1584   2      
1585   2              }       
1586   1      
1587   1      }
1588          
1589          
1590          
1591          
1592          /*********************************************************************************
1593          * NAME:      void NAND_Close_E_SBlock(void)
1594          * DESCRIPTION:
1595          *********************************************************************************/
1596          void NAND_Close_E_SBlock(U8 tc_Inx){
1597   1              xdata   U8      tc_XferPageCnt;
1598   1      //dbprintf("Z ");       
1599   1              /*ZSpare[0] = 0xA5;                             ZSpare[1] = (U8)Mapping_Table[PWR_INX+tc_Inx];//set E Block power inx
1600   1              ZSpare[2] = Mapping_Table[EINX+tc_Inx];                 ZSpare[3] = APort_ECNT[0];      //0601 Jay fix  
1601   1              ZSpare[4] = 0xFF;                               ZSpare[5] = 0xFF;
1602   1              ZSpare[6] = 0xFF;                               ZSpare[7] = 0xFF;*/
1603   1              NAND_Set_Spare_Data(0,tc_Inx);//0601 Jay fix    
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 27  

1604   1              APort_FBlock[0]= APort_LBlock[0];
1605   1              APort_FBlock[1]= APort_EBlock[0];                               
1606   1              QTable.WD= Mapping_Table[Q2_INX+tc_Inx];
1607   1              gw_SourcePage=((U16)QTable.BY[0]*H_INFO.cSMALLPAGE_NUM)+QTable.BY[1];
1608   1          gw_TargetPage=((U16)QTable.BY[0]*H_INFO.cSMALLPAGE_NUM)+QTable.BY[1];                                       
1609   1              tc_XferPageCnt = H_INFO.cSMALLPAGE_NUM-QTable.BY[1];
1610   1              RW_Data_Stage(gw_SourcePage,gw_TargetPage,tc_XferPageCnt );
1611   1              QTable.BY[0]+=1;
1612   1              QTable.BY[1] =0x00;
1613   1              Mapping_Table[Q2_INX+tc_Inx]= QTable.WD;// update table
1614   1      }
1615          /***************************************************************************
1616          * NAME:         void NAND_Set_Spare_Data(U8 tc_Type,U8 tc_Inx)
1617          * DESCRIPTION:
1618          *          
1619          ***************************************************************************/
1620          void NAND_Set_Spare_Data(U8 tc_Type,U8 tc_Inx){
1621   1              xdata   U8 tc_i;
1622   1              switch(tc_Type){
1623   2                      case 0://write External
1624   2                              ZSpare[0] = 0xA5;                                                       ZSpare[1] = (U8)Mapping_Table[PWR_INX+tc_Inx];
1625   2                              ZSpare[2] = Mapping_Table[EINX+tc_Inx];         ZSpare[3] = Wear_Table[ECNT+tc_Inx];    
1626   2                              ZSpare[4] = 'Q';                                                        ZSpare[5] = (Mapping_Table[Q1_INX+tc_Inx]>>8);//Q1
1627   2                              ZSpare[6] = 'Q';                                                        ZSpare[7] = (Mapping_Table[Q1_INX+tc_Inx]>>8);//Q1
1628   2                              break;
1629   2                      case 1:// write dummy 
1630   2                              ZSpare[0] = 0x5A;                                                       ZSpare[1] = gc_SBlock;
1631   2                              ZSpare[2] = Mapping_Table[EINX+tc_Inx];         ZSpare[3] = SQTable.BY[0];
1632   2                              ZSpare[4] = 0x5A;                                                       ZSpare[5] = gc_SBlock;
1633   2                              ZSpare[6] = Mapping_Table[EINX+tc_Inx];         ZSpare[7] = SQTable.BY[0];
1634   2                              break;
1635   2                      case 2:// write random 
1636   2                              ZSpare[0] =0x55;                                                        ZSpare[1] = HPage.BY[0];
1637   2                              ZSpare[2] = HBlock.WD;                      ZSpare[3] = HPage.BY[1];
1638   2                      
1639   2                              for(tc_i=0; tc_i<MAX_RANDOM_HBLOCK;tc_i++){
1640   3                                      ZSpare[4+tc_i]= Wear_Table[RINX+tc_i];
1641   3                              }               
1642   2                              break;          
1643   2                      case 3:
1644   2                              ZSpare[0] = 'C';                                                        ZSpare[1] = 'O';
1645   2                              ZSpare[2] = 'D';                                                        ZSpare[3] = 'E';
1646   2                              ZSpare[4] = 'C';                                                        ZSpare[5] = 'O';
1647   2                              ZSpare[6] = 'D';                                                        ZSpare[7] = 'E';
1648   2                              break;  
1649   2                      case 4:
1650   2                              ZSpare[0] = 'B';                                                        ZSpare[1] = 'A';
1651   2                              ZSpare[2] = 'N';                                                        ZSpare[3] = 'K';
1652   2                              ZSpare[4] = 'B';                                                        ZSpare[5] = 'A';
1653   2                              ZSpare[6] = 'N';                                                        ZSpare[7] = 'K';
1654   2                              break;  
1655   2              }       
1656   1      }
1657          
1658          
1659          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   6999    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      33
C51 COMPILER V9.00   FLASH                                                                 07/10/2012 15:51:45 PAGE 28  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      35
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       8
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
