C51 COMPILER V9.00   DOS_FILEPLAY                                                          07/10/2012 15:51:52 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DOS_FILEPLAY
OBJECT MODULE PLACED IN .\obj\dos_fileplay.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\LIBSOURCE\DOS\dos_fileplay.C LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDI
                    -R(..\libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\dos_fileplay.lst) OBJECT(.\obj\dos_fileplay.
                    -obj)

line level    source

   1          #include <string.h>
   2          #include "SPDA2K.h"
   3          #include "dos\fs_struct.h"
   4          #include "dos\dosfat.h"
   5          #include "dos\dosfdb.h"
   6          #include "dos\dosrw.h"
   7          #include "Memalloc.h"
   8          #include "Rambase.h"
   9          #include "PROTOTYP.h"
  10          
  11          extern U8  code Unicode_Offset[];
  12          extern U8  code Unicode_Offset2[];
  13          extern  U8      fdb_check_sum(U8 xdata * p);
  14          extern  xdata   U8      gc_HostSectorUnit;
  15          //! Read 512 bytes form a file.
  16          /*!
  17           *      \param  tc_FileHandle   The file handle to be read.
  18           *      \return 
  19           *                      - DOS_STARTCLUSTER_ERR
  20           *                      - DOS_CLUSTER_LINK_ERR
  21           *                      - DOS_END_OF_FILE
  22           *                      - DOS_SUCCESS
  23           *                      - DOS_FALSE
  24           */
  25          U8 DOS_Read_File(U8 tc_FileHandle)
  26          {
  27   1              U8      tc_ResidueSector;
  28   1              U32     tdw_DataPoint;
  29   1      
  30   1              if(gs_File_FCB[tc_FileHandle].dw_File_StartCluster==0xffffffff)
  31   1              {
  32   2                      return DOS_STARTCLUSTER_ERR;
  33   2              }
  34   1      
  35   1              if(gs_File_FCB[tc_FileHandle].dw_File_DataPoint < gs_File_FCB[tc_FileHandle].dw_File_TotalSize)
  36   1              {//not at file end.
  37   2                      tc_ResidueSector=(gs_File_FCB[tc_FileHandle].dw_File_DataPoint>>9)&(gc_DOS_SectorPerCluster*gc_HostSecto
             -rUnit-1);
  38   2                      if((tc_ResidueSector==0)&&(gs_File_FCB[tc_FileHandle].dw_File_DataPoint!=0))
  39   2                      {//next cluster.
  40   3                              gs_File_FCB[tc_FileHandle].dw_File_CurrentCluster = DOS_GetNextCluster(gs_File_FCB[tc_FileHandle].dw_Fi
             -le_CurrentCluster,1);
  41   3                              if(gs_File_FCB[tc_FileHandle].dw_File_CurrentCluster == 0xffffffff)
  42   3                              {
  43   4                                      return DOS_CLUSTER_LINK_ERR;
  44   4                              }
  45   3                      }
  46   2                      tdw_DataPoint = DOS_ClusterLogicAddr(gs_File_FCB[tc_FileHandle].dw_File_CurrentCluster) + tc_ResidueSect
             -or;
  47   2                      gb_ReadWriteDataArea = 0;
  48   2                      gs_File_FCB[tc_FileHandle].dw_File_DataPoint += 512;
  49   2                      return (DOS_Read_LogicSector(tdw_DataPoint, 1));
  50   2              }
C51 COMPILER V9.00   DOS_FILEPLAY                                                          07/10/2012 15:51:52 PAGE 2   

  51   1              else
  52   1              {
  53   2                      return DOS_END_OF_FILE;
  54   2              }
  55   1      }
  56          
  57          
  58          U8 DOS_GetLongFileName(U8 tc_FileHandle, U8 * tpc_LongName)
  59          {
  60   1              xdata   U16     i;
  61   1              xdata   U8  tc_Array[26];
  62   1              data    bit     tc_EndSign=0;
  63   1              data    U8      j;
  64   1              data    U8      tc_Chksum=0;
  65   1              data    U8      tc_LogAddrNum=1;
  66   1              data    U16     tw_FDB_Offset;
  67   1              data    U16     tw_LFN_Offset;
  68   1              data    U16     tw_FileNameLen;
  69   1              xdata   U32     tdw_Addr;
  70   1              
  71   1              tdw_Addr=gs_File_FCB[tc_FileHandle].dw_FDB_LogAdd;
  72   1              tw_FDB_Offset=gs_File_FCB[tc_FileHandle].w_FDB_Offset;
  73   1              gb_ReadWriteDataArea=1;
  74   1              DOS_Read_LogicSector(tdw_Addr, 1);
  75   1      
  76   1              memcpy(tc_Array,&gc_UserDataBuf[tw_FDB_Offset],11);
  77   1              tc_Chksum = fdb_check_sum(tc_Array);
  78   1              tw_LFN_Offset=tw_FDB_Offset;
  79   1              i=5;//fill the UNICODE from the offset 3! 
  80   1              while(i<512)
  81   1              {        
  82   2                      U8 xdata * p;
  83   2                      if(tw_LFN_Offset>=32)
  84   2                      {       
  85   3                              tw_LFN_Offset-=32;
  86   3                      }
  87   2                      else
  88   2                      {
  89   3                              if(tc_LogAddrNum==1)
  90   3                              {
  91   4                                      tdw_Addr=gs_File_FCB[tc_FileHandle].dw_LongFDB_LogAdd0;
  92   4                                      tc_LogAddrNum=2;
  93   4                              }
  94   3                              else if(tc_LogAddrNum==2) 
  95   3                              {
  96   4                                      tdw_Addr=gs_File_FCB[tc_FileHandle].dw_LongFDB_LogAdd1;
  97   4                              }
  98   3                              gb_ReadWriteDataArea=1;
  99   3                              DOS_Read_LogicSector(tdw_Addr, 1);
 100   3                              tw_LFN_Offset=512-32;
 101   3                      }
 102   2                      p = &(gc_UserDataBuf[tw_LFN_Offset]);
 103   2                      
 104   2                      if((*p&0x40)==0x40)
 105   2                      {
 106   3                              tc_EndSign=1;
 107   3                      }       
 108   2      
 109   2                      if(((p[11]==0x0f)||(p[11]==0x3f))&&(p[12]==0x00)&&(p[13]==tc_Chksum))
 110   2                      {        
 111   3                              for (j=0; j<26; j++)
 112   3                                      tpc_LongName[i++]=p[Unicode_Offset2[j]];//fill  the long file name into the array
C51 COMPILER V9.00   DOS_FILEPLAY                                                          07/10/2012 15:51:52 PAGE 3   

 113   3      //--------------------------------------------------------------------------------------------------
 114   3      //if  tc_Chksum is not right,or if sign number is not right,fill the short file name into the array
 115   3      //----------------------------------------------------------------------------------------------------          
 116   3                      } 
 117   2                      else 
 118   2                      { 
 119   3                              j=0;
 120   3                              gb_ReadWriteDataArea=1;
 121   3                              DOS_Read_LogicSector(gs_File_FCB[tc_FileHandle].dw_FDB_LogAdd, 1);
 122   3                              tpc_LongName[0]=0;
 123   3                              tpc_LongName[1]=0;
 124   3                              tpc_LongName[2]=K_ShortFileName;
 125   3                              tpc_LongName[3]=0;
 126   3                              while(j<8)
 127   3                              {
 128   4                                      tpc_LongName[5+j]=tc_Array[j];
 129   4                                      if(tc_Array[j]==0x20)
 130   4                                      {
 131   5                                              break;
 132   5                                      }       
 133   4                                      j++;
 134   4                              }
 135   3                              if (tc_Array[8] != 0x20)
 136   3                              {
 137   4                                      tpc_LongName[5+j]=0x2e;
 138   4                                      j+=1;
 139   4                              }
 140   3                              if (tc_Array[8] != 0x20)
 141   3                              {
 142   4                                      tpc_LongName[5+j]=tc_Array[8];
 143   4                                      j++;
 144   4                                      if (tc_Array[9] != 0x20)
 145   4                                      {
 146   5                                              tpc_LongName[5+j]=tc_Array[9];
 147   5                                              j++;
 148   5                                              if (tc_Array[10] != 0x20)
 149   5                                              {
 150   6                                                      tpc_LongName[5+j]=tc_Array[10];
 151   6                                                      j++;
 152   6                                              }
 153   5                                      }
 154   4                              }
 155   3                              tpc_LongName[4]=j;
 156   3                              return 0;               
 157   3                      }
 158   2                      
 159   2                      if(tc_EndSign) //when end,fill the first 3 bytes indicate the information of long file name!
 160   2                      {
 161   3                              tpc_LongName[0]=*p;
 162   3                              tpc_LongName[2]=K_LongFileName;
 163   3      
 164   3                              for (j = 0; j < 26; j+=2)
 165   3                              {
 166   4                                      if((p[Unicode_Offset2[j]]==0)&&(p[Unicode_Offset2[j+1]]==0))
 167   4                                      {
 168   5                                              break; 
 169   5                                      }
 170   4                              }
 171   3                              j = 26-j;
 172   3                              tpc_LongName[1] = j;
 173   3                              tw_FileNameLen=(((tpc_LongName[0]&0x3f)-1)*26)+(26-tpc_LongName[1]);//(JC)H0305
 174   3                              tpc_LongName[3] = ((UBYTE *)(&tw_FileNameLen))[0];            //save the high 4bit 
C51 COMPILER V9.00   DOS_FILEPLAY                                                          07/10/2012 15:51:52 PAGE 4   

 175   3                              tpc_LongName[4] = ((UBYTE *)(&tw_FileNameLen))[1];          //save the low 4bit
 176   3                              return 0;       
 177   3                      }
 178   2              }
 179   1      
 180   1              return 0;
 181   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1068    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      44
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       9
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
