C51 COMPILER V9.00   DSPUSER                                                               07/10/2012 15:51:49 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE DSPUSER
OBJECT MODULE PLACED IN .\obj\dspuser.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\LIBSOURCE\DSP\dspuser.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\
                    -libsource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\dspuser.lst) OBJECT(.\obj\dspuser.obj)

line level    source

   1          #include "SPDA2K.h"
   2          #include "DSP.h"
   3          #include "dspphysic.h"
   4          #include "dspuser.h"
   5          
   6          
   7          extern  data    bit  gb_Play_firstPlay;  //20090420 chiayen add
   8          
   9          
  10          void DSP_WakeUp(U8 tc_Flag)
  11          {
  12   1              if (tc_Flag & DSP_CLK_CTRL)
  13   1              {
  14   2                      GLOBAL_REG[0x10] |= 0x04;       //(JC)H0520; wake up DSP  
  15   2              }
  16   1      
  17   1              // 2T-SRAM Enable
  18   1              if (tc_Flag & SRAM2T_CTRL)
  19   1              {
  20   2                      GLOBAL_REG[0xF6] &= 0xF8;
  21   2                      GLOBAL_REG[0xF7] |= 0x07;
  22   2                      GLOBAL_REG[0xF8] |= 0x07;
  23   2                      GLOBAL_REG[0xF9] |= 0x07;
  24   2              }
  25   1      }
  26          
  27          void DSP_ClearReady(void)
  28          {
  29   1              U16 tw_Data;
  30   1      
  31   1              tw_Data = L2_DSP_Read_DMem16(DSP_CMDExeStatus);
  32   1              L2_DSP_Write_DMem16(DSP_CMDExeStatus, tw_Data&0xFFFE); //clear DSP 0x3F0B.0 ready status
  33   1      }
  34          
  35          U8 DSP_SearchSunplusKey(void)
  36          {
  37   1              code U8 SunplusKey[8] = {'S','u','n','p','l','u','s',0x00} ;
  38   1              data    U8      ta_GetString[8];
  39   1              data    U8      tc_Cnt;
  40   1              data    U16     tw_AddressIndex = DSP_SunplusKeyAddr;   // 0x3F11
  41   1              data    U8      *tpc_String = ta_GetString;
  42   1      
  43   1              // Read "SunplusKey" from DSP DM and put them into GetString[8].
  44   1              for(tc_Cnt=0; tc_Cnt<4; ++tc_Cnt)
  45   1              {
  46   2                      U16     tc_Data = L2_DSP_Read_DMem16(tw_AddressIndex++);
  47   2      
  48   2                      *(tpc_String+2*tc_Cnt)  = HIBYTE(tc_Data);
  49   2                      *(tpc_String+2*tc_Cnt+1)= LOBYTE(tc_Data);
  50   2              }
  51   1              for(tc_Cnt=0; tc_Cnt<8; tc_Cnt++)
  52   1              {
  53   2                      if(*(tpc_String+tc_Cnt) == SunplusKey[tc_Cnt])
  54   2                      {
C51 COMPILER V9.00   DSPUSER                                                               07/10/2012 15:51:49 PAGE 2   

  55   3                              return 0;
  56   3                      }
  57   2              }
  58   1              return 1;
  59   1      }
  60          
  61          
  62          U8 DSP_Download(U8 tc_CurrentIMID, U8 tc_CurrentPMID)
  63          {
  64   1              U8 tc_TotalIDNum;
  65   1              U8 tc_TempLoop;
  66   1              U16 tw_DSPCodeIMphyadr,tw_DSPCodePMphyadr;
  67   1              U16 tw_IDIndexOffset;
  68   1              U16 tw_Loop;
  69   1              U8 tc_value;
  70   1      
  71   1      
  72   1              //1. Turn off DSP CLK
  73   1              tc_value=GLOBAL_REG[0x10] & 0xFE;
  74   1              GLOBAL_REG[0x10]=tc_value;//GLOBAL_REG[0x10] &= 0xFE;                                                   // Turn off DSP clk
  75   1              //2. Download DSP IMPM
  76   1              {
  77   2                      //initial IM and PM phyadr value is 0xffff
  78   2                      tw_DSPCodeIMphyadr = 0xffff;
  79   2                      tw_DSPCodePMphyadr = 0xffff;
  80   2      
  81   2                      DSPHZK_Block_Read(0,0+1,1,gc_PlayRecordDataBufHB);
  82   2                      tc_TotalIDNum = gc_PlayRecordDataBuf[0];
  83   2      
  84   2                      for (tc_TempLoop = 0; tc_TempLoop < tc_TotalIDNum; tc_TempLoop ++)
  85   2                      {//Scan the IMIP ID in the all ID index
  86   3                              tw_IDIndexOffset = ((U16)tc_TempLoop * 9);
  87   3                              if ((gc_PlayRecordDataBuf[tw_IDIndexOffset + 1]) == tc_CurrentIMID)
  88   3                              {//if it is IM,move IM to DSP
  89   4                                      ((U8 *)(&tw_DSPCodeIMphyadr))[0] = gc_PlayRecordDataBuf[tw_IDIndexOffset + 2];
  90   4                                      ((U8 *)(&tw_DSPCodeIMphyadr))[1] = gc_PlayRecordDataBuf[tw_IDIndexOffset + 3]; 
  91   4                                      for(tw_Loop = 0; tw_Loop < 96; tw_Loop ++)
  92   4                                      {
  93   5                                              DSPHZK_Block_Read(0,tw_DSPCodeIMphyadr+1,1,gc_PlayRecordDataBufHB);
  94   5                                              L2_DSP_MCU_IM_DMA(tw_Loop, (U16)gc_PlayRecordDataBuf);
  95   5      
  96   5                                              tw_DSPCodeIMphyadr ++;
  97   5                                      }
  98   4                                      DSPHZK_Block_Read(0,0+1,1,gc_PlayRecordDataBufHB);
  99   4                              }
 100   3                              else if ((gc_PlayRecordDataBuf[tw_IDIndexOffset + 1]) == tc_CurrentPMID)
 101   3                              {//if it is PM,move PM to DSP
 102   4                                      U8 tc_buf_idx_start = 0;
 103   4      
 104   4                                      ((U8 *)(&tw_DSPCodePMphyadr))[0] = gc_PlayRecordDataBuf[tw_IDIndexOffset + 2];
 105   4                                      ((U8 *)(&tw_DSPCodePMphyadr))[1] = gc_PlayRecordDataBuf[tw_IDIndexOffset + 3]; 
 106   4      
 107   4                                      if((tc_CurrentPMID == 0x23)||(tc_CurrentPMID == 0x24)||(tc_CurrentPMID == 0x25))//(Jimi 091028)to save
             - spi
 108   4                                              tc_buf_idx_start = 24;
 109   4                                      for(tw_Loop = tc_buf_idx_start; tw_Loop < 48; tw_Loop ++)
 110   4                                      {
 111   5                                              DSPHZK_Block_Read(0,tw_DSPCodePMphyadr+1,1,gc_PlayRecordDataBufHB);
 112   5                                              L2_DSP_MCU_PM_DMA(tw_Loop, (U16)gc_PlayRecordDataBuf);
 113   5      
 114   5                                              tw_DSPCodePMphyadr ++;
 115   5                                      }
C51 COMPILER V9.00   DSPUSER                                                               07/10/2012 15:51:49 PAGE 3   

 116   4                                      DSPHZK_Block_Read(0,0+1,1,gc_PlayRecordDataBufHB);
 117   4                              }
 118   3      
 119   3                      }
 120   2                      if ((tw_DSPCodePMphyadr == 0xffff) && (tw_DSPCodeIMphyadr == 0xffff))   
 121   2                      {//the IM and PM is no exist
 122   3                              return DSP_IMPM_INEXISTENCE_ERROR;
 123   3                      }
 124   2              }
 125   1      
 126   1              //4. Reset DSP 
 127   1      #if DSP_RESET  //  ycc081031    
                      GLOBAL_REG[0x02] |= 0x01;                                                             
              #else
 130   1              tc_value=GLOBAL_REG[0x10] | 0x01;
 131   1      #endif
 132   1      
 133   1              //5. Enable DSP CLK
 134   1              GLOBAL_REG[0x10]=tc_value;//GLOBAL_REG[0x10] |= 0x01;
 135   1      
 136   1              //6. Release DSP reset
 137   1              GLOBAL_REG[0x02] &= 0xFE;                             // Enable DSP Run Normal Mode                     
 138   1                              
 139   1              DSP_REG[0x16]=0x00;  //Enable DM,IM,PM
 140   1      
 141   1              return DSP_SUCCESS;
 142   1      }
 143          
 144          
 145          U8 DSP_PlayInit(void)
 146          {
 147   1      #if DSP_RESET   //ycc081030 test
              #else 
 149   1              // Jimi 091104 for EQ mode pop noise as next/prev
 150   1              if(gb_Play_firstPlay == 1)
 151   1              {
 152   2                      L2_DSP_Write_DMem16(DSP_PostProcessSelect, 0x8003);
 153   2                      gb_Play_firstPlay = 0;
 154   2              }
 155   1              else
 156   1              {
 157   2                      L2_DSP_Write_DMem16(DSP_PostProcessSelect, 0x0003);
 158   2              }
 159   1      
 160   1              //U16 tw_temp;
 161   1              L2_DSP_SendCommandSet(DCMD_Restart); // ycc081031,force DSP jump 0 without hardware reset
 162   1              L2_DSP_Write_DMem16(DSP_RestartFlag,0x1235); // ycc081031
 163   1      #endif
 164   1      
 165   1              //DSP_Write_MMR16(0x3FC0, 0x05B5);  // jimi,  ycc 081205
 166   1      
 167   1              if(DSP_SearchSunplusKey()!=DSP_SUCCESS)
 168   1              {
 169   2                      return DSP_CHECK_SUNPLUSKEY_ERROR;
 170   2              }       
 171   1              else
 172   1              {
 173   2      //              dbprintf("Find DSPSunplusKey !!\n");
 174   2              }
 175   1      
 176   1              // Clear all buffers in DSP
 177   1              DSP_ClearReady();
C51 COMPILER V9.00   DSPUSER                                                               07/10/2012 15:51:49 PAGE 4   

 178   1              L2_DSP_Write_DMem16(DSP_GoControl,0x1235);            
 179   1              {
 180   2                      U16 dbgTmp;
 181   2                  U16 TimeOUT = 0xFFFF;
 182   2          
 183   2                      do{
 184   3                      dbgTmp = L2_DSP_Read_DMem16(DSP_CMDExeStatus)&0x0001;  //read DSP 0x3F0B.0 ready status
 185   3                      TimeOUT --;
 186   3                      if(TimeOUT==0)
 187   3                      {
 188   4                              return DSP_CMD_EXE_STATUS0_ERROR;
 189   4                      } 
 190   3                      }while(dbgTmp!=1);
 191   2              }
 192   1      
 193   1              return DSP_SUCCESS;
 194   1      }
 195          
 196          
 197          void DSP_SurroundDisable(void)
 198          {
 199   1          data        U16 tc_Data;
 200   1      
 201   1              tc_Data = L2_DSP_Read_DMem16(DSP_EffectControl);
 202   1          L2_DSP_Write_DMem16(DSP_EffectControl, tc_Data&0xF7FF);
 203   1              tc_Data = L2_DSP_Read_DMem16(DSP_SurroundDPCFLAG);
 204   1              L2_DSP_Write_DMem16(DSP_SurroundDPCFLAG,0xFFFD & tc_Data);
 205   1      }
 206          
 207          void DSP_SurroundEnable(void)
 208          {
 209   1          data        U16     tc_Data;
 210   1      
 211   1          tc_Data = L2_DSP_Read_DMem16(DSP_EffectControl);
 212   1          L2_DSP_Write_DMem16(DSP_EffectControl, tc_Data&0xFDFF);
 213   1      
 214   1          tc_Data = L2_DSP_Read_DMem16(DSP_EffectControl);
 215   1          L2_DSP_Write_DMem16(DSP_EffectControl, tc_Data|0x0800);
 216   1              L2_DSP_Write_DMem16(DSP_SurroundDPCFLAG,0x0003);
 217   1      }
 218           
 219          
 220          U8 DSP_PauseCmd(void)  //20090803 chiayen modify
 221          {
 222   1              if(L2_DSP_SendCommandSet(DCMD_Pause)!=DCMD_Pause)
 223   1              {
 224   2                      return DSP_PAUSE_COMMAND_ERROR;
 225   2              }
 226   1      
 227   1              return DSP_SUCCESS;
 228   1      }
 229          
 230          
 231          U8  DSP_StopCmd(void)
 232          {
 233   1          if(L2_DSP_SendCommandSet(DCMD_Stop) != DCMD_Stop)
 234   1              {
 235   2                      return DSP_STOP_COMMAND_ERROR;
 236   2              }
 237   1      
 238   1              return DSP_SUCCESS;
 239   1      }
C51 COMPILER V9.00   DSPUSER                                                               07/10/2012 15:51:49 PAGE 5   

 240          
 241          void DSP_EQ_Cmd(U8 tc_EQType)
 242          {
 243   1              code U8  EQ_TABLE[][7]=
 244   1              {
 245   1                      24,24,20,20,14,9,5,      //DBB
 246   1                      18,16,14,1,16,18,17, //JAZZ
 247   1                      20,20,15,10,2,8,22,      //ROCK
 248   1                      12,18,4,12,18,12,8,      //POP
 249   1                      7,10,14,17,18,10,7,      //LIVE(CLASSIC)
 250   1              };
 251   1              data    U16 tw_TmpData;
 252   1              xdata   U8  *tpc_EQPoint;
 253   1      
 254   1              tw_TmpData=L2_DSP_Read_DMem16(DSP_EffectControl); 
 255   1      
 256   1              if(tc_EQType == EQ_SSRmode) 
 257   1              {
 258   2                      L2_DSP_Write_DMem16(DSP_EffectControl,tw_TmpData&0xFDFF);//change to NORMAL
 259   2                      DSP_SurroundEnable(); 
 260   2              }
 261   1              else 
 262   1              {
 263   2                      DSP_SurroundDisable();
 264   2                      if(!tc_EQType) 
 265   2                      {       //EQ disable == NORMAL MODE
 266   3                              L2_DSP_Write_DMem16(DSP_EffectControl,tw_TmpData&0xFDFF);////EQ disable trigger
 267   3                      }
 268   2                      else 
 269   2                      {                               // EQ enable
 270   3                              if(tc_EQType == EQ_USERDEFINE)
 271   3                              {//user EQ
 272   4                                      tpc_EQPoint = &EQ_TABLE[tc_EQType][0];   // user define
 273   4                              }
 274   3                              else
 275   3                              {//default EQ
 276   4                                      tc_EQType--;
 277   4                                      tpc_EQPoint = &EQ_TABLE[tc_EQType][0];
 278   4                              }
 279   3                              L2_DSP_Write_DMem16(DSP_EQBand0,(U16)(tpc_EQPoint[0]));
 280   3                              L2_DSP_Write_DMem16(DSP_EQBand1,(U16)(tpc_EQPoint[1]));
 281   3                              L2_DSP_Write_DMem16(DSP_EQBand2,(U16)(tpc_EQPoint[2]));
 282   3                              L2_DSP_Write_DMem16(DSP_EQBand3,(U16)(tpc_EQPoint[3]));
 283   3                              L2_DSP_Write_DMem16(DSP_EQBand4,(U16)(tpc_EQPoint[4]));
 284   3                              L2_DSP_Write_DMem16(DSP_EQBand5,(U16)(tpc_EQPoint[5]));
 285   3                              L2_DSP_Write_DMem16(DSP_EQBand6,(U16)(tpc_EQPoint[6]));
 286   3                              tw_TmpData &= 0xFF7F;////'Spectrum Only' disable trigger
 287   3                              L2_DSP_Write_DMem16(DSP_EffectControl,tw_TmpData|0x0300);//EQ enable trigger
 288   3                      }
 289   2              }
 290   1      }
 291          
 292          void DSP_SpectrumOn(void)
 293          {
 294   1              data    U16     tw_TmpData;
 295   1      
 296   1              tw_TmpData=L2_DSP_Read_DMem16(DSP_EffectControl); 
 297   1              L2_DSP_Write_DMem16(DSP_EffectControl,tw_TmpData|0x0400);       //Open Spectrum
 298   1      }
 299          
 300          U8  DSP_ResetCmd(void)  //Jimi 080522
 301          {
C51 COMPILER V9.00   DSPUSER                                                               07/10/2012 15:51:49 PAGE 6   

 302   1          if(L2_DSP_SendCommandSet(DCMD_Reset) != DCMD_Reset)
 303   1              {
 304   2                      return DSP_STOP_COMMAND_ERROR;
 305   2              }
 306   1      
 307   1              return DSP_SUCCESS;
 308   1      }
 309          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1160    ----
   CONSTANT SIZE    =     43    ----
   XDATA SIZE       =   ----      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
