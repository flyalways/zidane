C51 COMPILER V9.00   USB                                                                   07/10/2012 15:51:43 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE USB
OBJECT MODULE PLACED IN .\obj\USB.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\libsource\USB\USB.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libs
                    -ource\header) DEFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\USB.lst) OBJECT(.\obj\USB.obj)

line level    source

   1          #include "SPDA2K.h"
   2          #include "..\..\turnkey_xbb\LCM\TFT_display.h"          // TFT  
   3          
   4          extern void Get_KeyValue(UBYTE ADCValue);
   5          extern data bit gb_USB_ISR_Detected;
   6          U32 gdw_USB_CountDown=0;  //080925chiayen add
   7          
   8          data    bit gb_cmd_timeout=0;
   9          data    bit     gb_ShowUSB=0;
  10          
  11          void USB_DisConnect(void)
  12          {
  13   1              XBYTE[0xB01D] = 0x01;
  14   1      
  15   1              USB_REG[0xA1]=0x00;
  16   1              USB_REG[0x27] = 0x01;   // 080324 USB disconnect PC
  17   1              GLOBAL_REG[0x17]=0x00;
  18   1              USB_REG[0xC0]=0x00;     //clear suspend/resume/configuration change,turn off USB D+
  19   1              
  20   1              //Adding for avoid losting power
  21   1              USB_REG[0xD0]=0x00;
  22   1              USB_REG[0xD1]=0x00;
  23   1              USB_REG[0xD2]=0x00;
  24   1              USB_REG[0xD3]=0x00;
  25   1              GLOBAL_REG[0x16]=0x05;  //Close USB UTMI 30Mhz
  26   1      
  27   1              GLOBAL_REG[0x16] = 0x01;//Close USB UTMI 30Mhz
  28   1              GLOBAL_REG[0x11] &= 0xEF;       //Close USB clk source
  29   1          USER_DelayDTms(20);
  30   1      }
  31          
  32          
  33          void USB_Mode(void) 
  34          {
  35   1              gb_cmd_timeout=0;
  36   1              set_clock_mode(CLOCK_MODE_USB); 
  37   1          PowerOn_Init_USB();
  38   1              Fill_EndpointDataTable_Into_ExRamBase();
  39   1              USBInitialize(); 
  40   1              Init_Flash_Reg();
  41   1              Init_Flash_Variable();
  42   1              gc_WriteProof = 0x00;
  43   1              InitFlash();
  44   1              
  45   1              USB_REG[0x27]    = 0x00;        // 080304 jay change for new fpga
  46   1              GLOBAL_REG[0x17] = 0x01;        // UDC O/P      
  47   1          IE = 0x83;     
  48   1      
  49   1              gdw_USB_CountDown = USB_DETECT_TIMEOUT;
  50   1      
  51   1              if(gb_cmd_timeout==1)  //080925chiayen modify
  52   1              {
  53   2                      USB_DisConnect();
  54   2                      set_clock_mode(CLOCK_MODE_MP3); 
C51 COMPILER V9.00   USB                                                                   07/10/2012 15:51:43 PAGE 2   

  55   2                      InitFlash();
  56   2                      return;
  57   2              }
  58   1                 
  59   1              for(;;)
  60   1              {
  61   2                      USB_PlugDetect();
  62   2                      if(!gbt_USB_Detected)
  63   2                      {//usb connected 
  64   3                              USB_DisConnect();
  65   3                              set_clock_mode(CLOCK_MODE_MP3);
  66   3                              InitFlash();
  67   3                              break;
  68   3                      }
  69   2                      else
  70   2                      {
  71   3                              if (gc_USBStage == CBWStage) 
  72   3                              {
  73   4                                      if(gbt_USB_Connect_Flag)
  74   4                                      {
  75   5                                          //tdw_CMD_In_Count =0x02FFFFF;
  76   5                                      }
  77   4                                      else
  78   4                                      {
  79   5                                          gdw_USB_CountDown =0x01FFFF;  //081208  detect charge first
  80   5                                      }
  81   4                                      EA=1;                                                   
  82   4                                      while (!gbt_USB_CMD_IN)                        // Bulk_In_Out  將跳出while 迴圈
  83   4                                      {
  84   5                                              USB_PlugDetect();
  85   5                                              if(!gbt_USB_Detected)
  86   5                                              {
  87   6                                                      break;
  88   6                                              }
  89   5                                              if(gbt_USB_Connect_Flag)
  90   5                                              {
  91   6                                                  if(gbt_USER_Remove_Flag)
  92   6                                                      {
  93   7                                                      gb_cmd_timeout=1;
  94   7                                                          break;
  95   7                                                      }
  96   6                                              } 
  97   5                                              else
  98   5                                              {
  99   6                                              if((--gdw_USB_CountDown==0)&&(!gb_USB_ISR_Detected)) 
 100   6                                                      {
 101   7                                                              gb_cmd_timeout=1;
 102   7                                                      break;
 103   7                                              }
 104   6                                              }
 105   5                                      }
 106   4                                      EA=0;                                       // 表示有 SCSI CMD 進入 關閉中斷避免常常進入                        
 107   4                                      if((!gbt_USB_Detected)||(gb_cmd_timeout==1))  //080925chiayen modify
 108   4                                      {
 109   5                                              USB_DisConnect();
 110   5                                              set_clock_mode(CLOCK_MODE_MP3); 
 111   5                                              InitFlash();            
 112   5                                              break;
 113   5                                      }
 114   4                                      gbt_USB_CMD_IN = 0;
 115   4                                      SD_Card_Detect();               
 116   4                                      gbt_USB_Connect_Flag =1; // 081208 jay add                      
C51 COMPILER V9.00   USB                                                                   07/10/2012 15:51:43 PAGE 3   

 117   4                                      Save_CBW_Packet();
 118   4                                      Decode_CBW_Command();                             // 解CBW和記錄相關手續                    
 119   4                              }
 120   3      
 121   3                              if(gb_ShowUSB==0)
 122   3                              {
 123   4                                      TFT_ShowUSBIcon();      
 124   4                                      gb_ShowUSB=1;
 125   4                              }
 126   3      
 127   3                              if (gc_USBStage == BulkInReadSectorsStage) 
 128   3                              {
 129   4                                      USB_REG[0xD2]      &= 0xDD;                             //Disable Bulk-Out中斷
 130   4                                      ReadSectors();                      
 131   4                                      USB_REG[0xE9]       = 0x11;
 132   4                                      if (gc_ErrorCode == SET_ABRT) 
 133   4                                      {
 134   5                                              gc_RequestSenseCode = 0x06;        //ECC Error                          
 135   5                                              gdw_dCBW_DataXferLength.LW = ((LWORD)TotalXferPageNum.WD) << 9;
 136   5                                              gc_bCSWStatus = 0x01;
 137   5                                      }
 138   4                                      else if (gc_ErrorCode == ID_NOT_FND) 
 139   4                                      {
 140   5                                              gc_RequestSenseCode = 0x07;                                     //over range
 141   5                                              gdw_dCBW_DataXferLength.LW = ((LWORD)TotalXferPageNum.WD) << 9;
 142   5                                              gc_bCSWStatus = 0x01;
 143   5                                      }
 144   4                                      else 
 145   4                                      {
 146   5                                              gdw_dCBW_DataXferLength.LW = 0;
 147   5                                      }
 148   4                                      gc_USBStage = CSWStage;                                   // 進入Comand Status Wrapper
 149   4                              }
 150   3                              if (gc_USBStage == BulkOutWriteSectorsStage) 
 151   3                              {
 152   4                                      USB_REG[0xD2]      &= 0xDD;                             //Disable Bulk-Out中斷
 153   4                                      USB_REG[0x11]       = 0x01;   //HW auto ACK 
 154   4                                      WriteSectors();
 155   4                                      USB_REG[0x11]       = 0x00;
 156   4                                      USB_REG[0xE9]       = 0x22;
 157   4      
 158   4                                      if (gc_ErrorCode == SET_ABRT) 
 159   4                                      {
 160   5                                              gc_bCSWStatus = 0x01;
 161   5                                              gc_RequestSenseCode = 0x08;                                             // write error 
 162   5                                      }
 163   4                                      else if (gc_ErrorCode == ID_NOT_FND) 
 164   4                                      {
 165   5                                              gc_RequestSenseCode = 0x07;                                             //over range
 166   5                                              gc_bCSWStatus = 0x01;
 167   5                                      }
 168   4                                      else 
 169   4                                      {
 170   5                                              gc_bCSWStatus = 0x00;
 171   5                                              gc_RequestSenseCode = 0xFF;                        // normal
 172   5                                      }
 173   4                                      gdw_dCBW_DataXferLength.LW = 0;
 174   4                                      gc_USBStage = CSWStage;
 175   4                              }
 176   3                              if (gc_USBStage == BulkInResponseStage) 
 177   3                              {                          // '4' BulkInProcess
 178   4                                      USB_REG[0xD2]      &= 0xDD;                             //Disable Bulk-Out中斷
C51 COMPILER V9.00   USB                                                                   07/10/2012 15:51:43 PAGE 4   

 179   4                                      if (gbt_XferNormalResponseData_or_ModeSense) 
 180   4                                      {                      // '1':Normal
 181   5                                              if (COMD_IN[0] == 0x23) 
 182   5                                              {
 183   6                                                      gdw_dCBW_DataXferLength.WD[1] = 0x00;
 184   6                                                      USB_REG[0x16]  = 0x00;
 185   6                                                      USB_REG[0x15]  = 0x0C;
 186   6                                                      USB_REG[0xA1] |= 0x01;
 187   6                                                      while (USB_REG[0xA1] & 0x01)
 188   6                                                      {
 189   7                                                              USB_PlugDetect();  // 081014 Jay add for usb plug out
 190   7                                                              if(!gbt_USB_Detected) break;
 191   7                                                      }
 192   6                                                      USB_REG[0xE9]  = 0x01;
 193   6                                              }
 194   5                                              else 
 195   5                                              {
 196   6                                                      while (gdw_dCBW_DataXferLength.WD[1]) 
 197   6                                                      {
 198   7                                                              if (gdw_dCBW_DataXferLength.WD[1] > 64) 
 199   7                                                              {
 200   8                                                                      gdw_dCBW_DataXferLength.WD[1] = gdw_dCBW_DataXferLength.WD[1] - 64;
 201   8                                                              USB_REG[0x16] = 0x00;
 202   8                                                                      USB_REG[0x15] = 0x40;
 203   8                                                              }
 204   7                                                              else 
 205   7                                                              {
 206   8                                                              USB_REG[0x16] = gdw_dCBW_DataXferLength.BY[2] & 0x0F;
 207   8                                                                      USB_REG[0x15] = gdw_dCBW_DataXferLength.BY[3];
 208   8                                                              gdw_dCBW_DataXferLength.WD[1] = 0x00;
 209   8                                                      }
 210   7                                                              USB_REG[0xA1] |= 0x01;
 211   7                                                              while (USB_REG[0xA1] & 0x01)
 212   7                                                              {  //081014 Jay add for usb plug out
 213   8                                                                      USB_PlugDetect();
 214   8                                                                      if(!gbt_USB_Detected) break;
 215   8                                                              }
 216   7                                                              USB_REG[0xE9]  = 0x01;
 217   7                                                      }
 218   6                                              }
 219   5                                      }
 220   4                                      else 
 221   4                                      {
 222   5                                              if (COMD_IN[0] == 0x1A) 
 223   5                                              {
 224   6                                                      gdw_dCBW_DataXferLength.WD[1] = 0x00;
 225   6                                                      USB_REG[0x15]  = 0x04;
 226   6                                                      USB_REG[0x16]  = 0x00;
 227   6                                                      USB_REG[0xA1] |= 0x01;
 228   6                                                      while (USB_REG[0xA1] & 0x01)
 229   6                                                      {  //081014 Jay add for usb plug out
 230   7                                                                      USB_PlugDetect();
 231   7                                                                      if(!gbt_USB_Detected) break;
 232   7                                                      }
 233   6                                                      USB_REG[0xE9]  = 0x01;
 234   6                                              }
 235   5                                              else 
 236   5                                              {
 237   6                                                      gdw_dCBW_DataXferLength.WD[1] = 0x00;
 238   6                                                      USB_REG[0x15]  = 0x08;
 239   6                                                      USB_REG[0x16]  = 0x00;
 240   6                                                      USB_REG[0xA1] |= 0x01;
C51 COMPILER V9.00   USB                                                                   07/10/2012 15:51:43 PAGE 5   

 241   6                                                      while (USB_REG[0xA1] & 0x01)
 242   6                                                      {  //081014 Jay add for usb plug out
 243   7                                                              USB_PlugDetect();
 244   7                                                              if(!gbt_USB_Detected) break;
 245   7                                                      }
 246   6                                                      USB_REG[0xE9]  = 0x01;
 247   6                                              }
 248   5                                              gbt_XferNormalResponseData_or_ModeSense = NormalResponseData;// 將預設設為一般型
 249   5                                      }
 250   4                                      gc_USBStage = CSWStage;
 251   4                              }
 252   3                              if (gc_USBStage == BulkStallStage) 
 253   3                              {
 254   4                                      StallBulkRW();
 255   4                                      gc_USBStage = CSWStage;
 256   4                              }
 257   3                              if (gc_USBStage == BulkInReadBufferStage) 
 258   3                              {
 259   4                                      USB_REG[0xD2]      &= 0xDD;                             //Disable Bulk-Out中斷
 260   4                                      NoCard_ReadSectors();               
 261   4                                      USB_REG[0xE9]       = 0x11;
 262   4                                      gdw_dCBW_DataXferLength.LW = 0;                 
 263   4                                      gc_USBStage = CSWStage;                                   // 進入Comand Status Wrapper                               
             -             
 264   4                              }
 265   3                              if (gc_USBStage == BulkOutWriteBufferStage) 
 266   3                              {
 267   4                                      USB_REG[0xD2]      &= 0xDD;                             //Disable Bulk-Out中斷
 268   4                                      USB_REG[0x11]       = 0x01;   //HW auto ACK 
 269   4                                      NoCard_WriteSectors();                  
 270   4                                      USB_REG[0x11]       = 0x00;
 271   4                                      USB_REG[0xE9]       = 0x22;
 272   4                                      gdw_dCBW_DataXferLength.LW = 0;
 273   4                                      gc_USBStage = CSWStage;
 274   4                              }                               
 275   3                              if (gc_USBStage == CSWStage) 
 276   3                              {
 277   4                                      gc_USBStage = CBWStage;                                   // 重新準備收下一筆command
 278   4                                      USB_BUF_Bank0[ 0] = 'U';                                        // 以下由SetCSWData expand
 279   4                                      USB_BUF_Bank0[ 1] = 'S';
 280   4                                      USB_BUF_Bank0[ 2] = 'B';
 281   4                                      USB_BUF_Bank0[ 3] = 'S';
 282   4                                      USB_BUF_Bank0[ 4] = dCBW_Tag[0];
 283   4                                      USB_BUF_Bank0[ 5] = dCBW_Tag[1];
 284   4                                      USB_BUF_Bank0[ 6] = dCBW_Tag[2];
 285   4                                      USB_BUF_Bank0[ 7] = dCBW_Tag[3];
 286   4                                      USB_BUF_Bank0[ 8] = gdw_dCBW_DataXferLength.BY[3];                  // LSB 記錄剩下未被傳輸的資料
 287   4                                      USB_BUF_Bank0[ 9] = gdw_dCBW_DataXferLength.BY[2];                  //     記錄剩下未被傳輸的資料
 288   4                                      USB_BUF_Bank0[10] = gdw_dCBW_DataXferLength.BY[1];                  //     記錄剩下未被傳輸的資料
 289   4                                      USB_BUF_Bank0[11] = gdw_dCBW_DataXferLength.BY[0];                  // MSB 記錄剩下未被傳輸的資料
 290   4                                      USB_BUF_Bank0[12] = gc_bCSWStatus;                                 // Command Status 見BulkOnly P.15說
             -明各種碼的情形
 291   4                                      USB_REG[0x2B]  = 0x00; 
 292   4                                      USB_REG[0x16]  = 0x00;
 293   4                                      USB_REG[0x15]  = 0x0D;
 294   4                                      USB_REG[0xA1] |= 0x01;
 295   4                                      while (USB_REG[0xA1] & 0x01)
 296   4                                      {  //081014 Jay add for usb plug out
 297   5                                              USB_PlugDetect();
 298   5                                              if(!gbt_USB_Detected) break;
 299   5                                      }
 300   4                              }
C51 COMPILER V9.00   USB                                                                   07/10/2012 15:51:43 PAGE 6   

 301   3                              USB_REG[0xE9]  = 0x01;                  
 302   3                              USB_REG[0xD2]  |= 0x02; //Enable Bulk-Out中斷
 303   3                              USB_REG[0xA1]  |= 0x02;         //下一筆31Byte Bulk-Out
 304   3                      }
 305   2              }
 306   1      }
 307          
 308          
 309          void Fill_EndpointDataTable_Into_ExRamBase(void)
 310          {
 311   1              U8      i;
 312   1      
 313   1              for(i=0;i<Device_DescriptorTable_Length;i++)
 314   1              {       // 18 bytes
 315   2                  EndPoint0Table[Device_DescriptorTable_Begine+i]=Device_DescriptorTable[i];
 316   2              }
 317   1      
 318   1              for(i=0;i<iManufacturer_DescriptorTable_Length;i++)
 319   1              {   // 26 bytes
 320   2                      EndPoint0Table[iManufacturer_DescriptorTable_Begine+i]=iManufacturer_DescriptorTable[i];
 321   2              }
 322   1      
 323   1              for(i=0;i<iProduct_DescriptorTable_Length;i++)
 324   1              {       // 48 bytes
 325   2                      EndPoint0Table[iProduct_DescriptorTable_Begine+i]=iProduct_DescriptorTable[i];
 326   2              }
 327   1                      
 328   1              for(i=0;i<iSerialNumber_DescriptorTable_Length;i++)
 329   1              {       // 28 bytes
 330   2                      EndPoint0Table[iSerialNumber_DescriptorTable_Begine+i]=iSerialNumber_DescriptorTable[i];
 331   2              }
 332   1                      
 333   1          for(i=0;i<Configuration_DescriptorTable_Length;i++)
 334   1              {       // 32 bytes
 335   2                      EndPoint0Table[Configuration_DescriptorTable_Begine+i]=Configuration_DescriptorTable[i];
 336   2              }
 337   1      
 338   1              for(i=0;i<iLANGID_DescriptorTable_Length;i++)
 339   1              {       //  4 bytes
 340   2                      EndPoint0Table[iLANGID_DescriptorTable_Begine+i]=iLANGID_DescriptorTable[i];
 341   2              }
 342   1      
 343   1              for(i=0;i<iConfiguraiton_DescriptorTable_Length;i++)
 344   1              {       // 10 bytes
 345   2                      EndPoint0Table[iConfiguraiton_DescriptorTable_Begine+i]=iConfiguraiton_DescriptorTable[i];
 346   2              }
 347   1      
 348   1              for(i=0;i<iDeviceQualifierString_DescriptorTable_Length;i++)
 349   1              {       // 10 bytes
 350   2                      EndPoint0Table[iDeviceQualifierString_DescriptorTable_Begine+i]=iDeviceQualifierString_DescriptorTable[i
             -];
 351   2              }
 352   1      
 353   1              for(i=0;i<iInterface_DescriptorTable_Length;i++)
 354   1              {       // 10 bytes
 355   2                      EndPoint0Table[iInterface_DescriptorTable_Begine+i]=iInterface_DescriptorTable[i];
 356   2              }
 357   1              
 358   1              for(i=0;i<Other_Speed_Configuration_DescriptorTable_Length;i++)
 359   1              {       // 32 bytes
 360   2                      EndPoint0Table[Other_Speed_Configuration_DescriptorTable_Begine+i]=Other_Speed_Configuration_DescriptorT
             -able[i];
C51 COMPILER V9.00   USB                                                                   07/10/2012 15:51:43 PAGE 7   

 361   2              }
 362   1              
 363   1              for(i=0;i<DeviceQualifier_DescriptorTable_Length;i++)
 364   1              {       // 10 bytes
 365   2                      EndPoint0Table[DeviceQualifier_DescriptorTable_Begine+i]=DeviceQualifier_DescriptorTable[i];
 366   2              }
 367   1      }
 368          
 369          
 370          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1054    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
