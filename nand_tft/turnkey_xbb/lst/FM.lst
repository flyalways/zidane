C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE FM
OBJECT MODULE PLACED IN .\obj\FM.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE IR\FM.c LARGE OPTIMIZE(9,SIZE) BROWSE NOAREGS INCDIR(..\libsource\header) D
                    -EFINE(K_ICTYPE=0x03) DEBUG OBJECTEXTEND PRINT(.\lst\FM.lst) OBJECT(.\obj\FM.obj)

line level    source

   1          #include "..\Header\SPDA2K.h"
   2          #include "..\header\PROTOTYP.h"
   3          #include "..\header\dos\fs_struct.h"
   4          #include "..\IR\remote.h"
   5          #include "..\IR\FM.h"
   6          #include "..\header\variables.h"
   7          
   8          //void  FM_FREQ_CHG(U8 tc_UP_DOWN,U8 offset);
   9          void    FM_drive(void);
  10          void    FM_initial(void);
  11          void    I2C_ZI2020_Send_data(U8 add,U8 dat);
  12          void    I2C_ZI2020_SendByte(U8 dat);
  13          void    I2C_ZI2020_StartBit(void);
  14          void    I2C_ZI2020_StopBit(void);
  15          void    IIC_Start(void);
  16          void    IIC_Stop(void);
  17          void    IIC_SendAck(bit k);
  18          void    AS6200_init(void);
  19          void    AS6200_Write_Data(U8 Reg,U16 Reg_val);
  20          void    AS6200_Set_Freq(U16 frq);
  21          void    AS6200_Read_Freq(void);
  22          void    I2C_Wait(U16 tt); //chiayen0805
  23          void    FM_FREQ_CHG(U8 tc_UP_DOWN,U8 offset);
  24          U8              IIC_WriteByte(U8 addr);
  25          U8              IIC_ReadByte(U8 ack);
  26          U16             AS6200_Read_Data(U8 Reg); //AS6200 read data according to Reg
  27          unsigned int I2C_ZI2020_read_data(U8 add);
  28          //===================8027Home======================
  29          xdata   U8 qnd_i2c;
  30          xdata   U8 qnd_i2c_timeout;
  31          //====================================================
  32          
  33          
  34          void FM_FREQ_CHG(U8 tc_UP_DOWN,U8 offset)       // 1=UP  0=DOWN
  35          {
  36   1              gb_Frequency_Song=0;    // 0=Show Frequency    1=Show Song Number/EQ
  37   1              gc_SelectVol=0;                 // 1=Show Vol
  38   1              gb_SelectEQ=0;                  // 0=Show Song Number  1=Show EQ
  39   1              gc_ShowTimer=0;
  40   1              gb_ChannelSet=0;
  41   1              gc_TuneVolFreqStatus=2;
  42   1              gc_ShowTimer=72;
  43   1      
  44   1              if(tc_UP_DOWN==1)
  45   1              {
  46   2                      gw_FM_frequency+=offset;
  47   2                      if(gw_FM_frequency>1080)
  48   2                      {
  49   3                              gw_FM_frequency=gw_FM_frequency-206;
  50   3                      }
  51   2              }
  52   1              else
  53   1              {
  54   2                      gw_FM_frequency-=offset;
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 2   

  55   2                      if(gw_FM_frequency<875)
  56   2                      {
  57   3                              gw_FM_frequency=206+gw_FM_frequency;
  58   3                      }
  59   2              }
  60   1              FM_drive();
  61   1              gw_IR_Setting_Timer=120;
  62   1              gb_IR_Setting=1;
  63   1      }
  64          
  65          
  66          void FM_drive(void)
  67          {
  68   1              U8  tc_FMModule_Type;
  69   1              U16     tw_FM_frequency;
  70   1      
  71   1              gw_LogData_Timer=60; //chiayen0812
  72   1              tc_FMModule_Type=FM_MODULE;
  73   1      
  74   1              if(tc_FMModule_Type==FM_ZI2020) // ZI2020
  75   1              {
  76   2                  tw_FM_frequency=0xF000|gw_FM_frequency;
  77   2      
  78   2                  I2C_ZI2020_Send_data(0x00,(U8)tw_FM_frequency);
  79   2              I2C_ZI2020_Send_data(0x01,tw_FM_frequency>>8);
  80   2              }
  81   1              else if((tc_FMModule_Type==FM_AS6001) || (tc_FMModule_Type==FM_HY1418)) // AS6001, HY1418
  82   1              {
  83   2                      U8 i;
  84   2                      FM_EN=1;        // CE=1
  85   2                      tw_FM_frequency=gw_FM_frequency|0x4800;
  86   2      
  87   2                      for(i=0;i<16;i++)
  88   2                      {
  89   3                              if(tw_FM_frequency&0x01)
  90   3                              {
  91   4                                      FM_DAT=1;
  92   4                              }
  93   3                              else
  94   3                              {
  95   4                                      FM_DAT=0;
  96   4                              }
  97   3                              I2C_Wait(500);  
  98   3                              FM_CLK=1;       
  99   3                              I2C_Wait(500);  
 100   3                              FM_CLK=0;       
 101   3                              tw_FM_frequency>>=1;
 102   3                      }
 103   2                      
 104   2                      FM_EN=0;
 105   2                      I2C_Wait(500);
 106   2              }
 107   1              else if(tc_FMModule_Type==FM_AS6300)    // AS6300
 108   1              {
 109   2                      AS6200_Set_Freq(gw_FM_frequency);
 110   2                      AS6200_Read_Freq();
 111   2              }
 112   1              else if(tc_FMModule_Type==FM_QN8027)    // QN8027
 113   1              {
 114   2              QND_TuneToCH(gw_FM_frequency);
 115   2              }
 116   1      }
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 3   

 117          
 118          
 119          void FM_initial(void)
 120          {
 121   1              U8  tc_FMModule_Type,REG1,REG2;
 122   1      
 123   1              tc_FMModule_Type=FM_MODULE;
 124   1              if(tc_FMModule_Type==FM_AS6300)// AS6300 //chiayen0805
 125   1              {
 126   2                      AS6200_init();
 127   2              }
 128   1              else if(tc_FMModule_Type==FM_ZI2020)    // ZI2020
 129   1              {
 130   2                      /*FM_SCL=1;
 131   2                      FM_DAT=1;
 132   2                      // ZI2020 RESET
 133   2                      FM_RSTB=0;
 134   2                      I2C_Wait(300);
 135   2                      FM_RSTB=1;
 136   2                      I2C_Wait(300);
 137   2                      // Initial ZI2020
 138   2                      I2C_ZI2020_Send_data(0x00,0x81);
 139   2                      I2C_Wait(10);
 140   2                      I2C_ZI2020_Send_data(0x01,0x03);
 141   2                      I2C_Wait(10);
 142   2                      I2C_ZI2020_Send_data(0x02,0x00);
 143   2                      I2C_Wait(10);
 144   2                      I2C_ZI2020_Send_data(0x13,0x80);
 145   2                      I2C_Wait(10);*/
 146   2      
 147   2                      //共12M晶振//KT0803L 
 148   2                      REG1=I2C_ZI2020_read_data(0x17);
 149   2                      I2C_ZI2020_Send_data(0x17,REG1|0x08);
 150   2                      I2C_ZI2020_Send_data(0x1E,0x43);
 151   2                      REG2=I2C_ZI2020_read_data(0x0D);
 152   2                      I2C_ZI2020_Send_data(0x0D,REG2|0x02);
 153   2                      I2C_Wait(50);
 154   2              }
 155   1              else if(tc_FMModule_Type==FM_QN8027)    // QN8027
 156   1              {   
 157   2                      QND_Init();   
 158   2              }
 159   1              else/* if((FM_MODULE==FM_AS6001) || (FM_MODULE==FM_HY1418))     // AS6001, HY1418*/     // AS6001, HY1418, AS6002
             -, HY1417LP
 160   1              {
 161   2                      FM_EN=0;
 162   2                      FM_CLK=0;
 163   2                      I2C_Wait(500);
 164   2              }
 165   1      }
 166          
 167          unsigned int I2C_ZI2020_read_data(U8 add) //AS6200 read data according to Reg
 168          {
 169   1              unsigned char  value_l,value_h;
 170   1              unsigned int temp;
 171   1      //      addr =  ((Reg)<<1)|0x81;
 172   1      
 173   1          I2C_ZI2020_StartBit();              // I2C start
 174   1              I2C_ZI2020_SendByte(0x7c);      // I2C WR command
 175   1              I2C_ZI2020_SendByte(add);       // I2C address
 176   1      //    I2C_ZI2020_StopBit();             // I2C stop
 177   1      
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 4   

 178   1              I2C_ZI2020_StartBit();          // I2C start
 179   1              I2C_ZI2020_SendByte(0x7D);      // I2C WR command
 180   1          value_l = IIC_ReadByte(1);
 181   1              value_h = IIC_ReadByte(1);
 182   1          I2C_ZI2020_StopBit();               // I2C stop
 183   1      
 184   1              temp = (unsigned int)(value_h<<8)+value_l;
 185   1      //      dbprintf("add==%bx\n",add);
 186   1      //      dbprintf("temp==%x\n",temp);
 187   1              return temp;
 188   1              
 189   1      }
 190          void I2C_ZI2020_Send_data(U8 add,U8 dat)
 191          {
 192   1              I2C_ZI2020_StartBit();          // I2C start
 193   1              I2C_ZI2020_SendByte(0x7C);      // I2C WR command
 194   1              I2C_ZI2020_SendByte(add);       // I2C address
 195   1              I2C_ZI2020_SendByte(dat);       // I2C data
 196   1              I2C_ZI2020_StopBit();           // I2C stop
 197   1      }
 198          
 199          
 200          void I2C_ZI2020_StartBit(void)
 201          {
 202   1              FM_SCL=1;       // clk=1
 203   1              I2C_Wait(3);
 204   1              FM_SDA=1;       // dat=1
 205   1              I2C_Wait(3);
 206   1              FM_SDA=0;       // dat=0
 207   1              I2C_Wait(3);
 208   1              FM_SCL=0;       // clk=0
 209   1              I2C_Wait(3);
 210   1      }
 211          
 212          
 213          void I2C_ZI2020_StopBit(void)
 214          {
 215   1              FM_SDA=0;       // dat=0
 216   1              I2C_Wait(3);
 217   1              FM_SCL=1;       // clk=1
 218   1              I2C_Wait(3);
 219   1              FM_SDA=1;       // dat=1
 220   1              I2C_Wait(3);
 221   1      }
 222          
 223          
 224          void I2C_ZI2020_SendByte(U8 dat)
 225          {
 226   1              U8 i;
 227   1              for(i=0;i<8;i++)
 228   1              {
 229   2                      if(dat&0x80)
 230   2                      {
 231   3                              FM_SDA=1;       // dat=1
 232   3                      }
 233   2                      else 
 234   2                      {
 235   3                              FM_SDA=0;       // dat=0
 236   3                      }
 237   2                      dat<<=1;
 238   2                      I2C_Wait(3);
 239   2                      FM_SCL=1;               // clk=1
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 5   

 240   2                      I2C_Wait(3);
 241   2                      FM_SCL=0;               // clk=0
 242   2                      I2C_Wait(3);
 243   2              }
 244   1              XBYTE[0xB102]&=0xFD;// P1.1=Input
 245   1              FM_SDA=1;                       // dat=1
 246   1              I2C_Wait(3);
 247   1      
 248   1              // Wait ACK
 249   1              FM_SCL=1;               // clk=0
 250   1              I2C_Wait(3);
 251   1              FM_SCL=0;               // clk=1
 252   1              I2C_Wait(3);
 253   1      
 254   1              XBYTE[0xB102]|=0x02;// P1.1=Output
 255   1      }
 256          
 257          
 258          U16     AS6200_Write_BUFF[20] =
 259          {
 260                  0x2E00,
 261                  0x01D8,
 262                  0x27D3,
 263                  0x01C5,
 264                  0x4E03,
 265                  0x9CA0,                 //R5
 266                  0x8803,                 //R6
 267                  0x592C,
 268                  0x0881,                 //0x1881
 269                  0x0246,
 270                  0x0028,
 271                  0x0018,
 272                  0x1001,
 273                  0x0600,
 274                  0xE6DB,
 275                  0x0000,
 276                  0x0000,
 277                  0x0000,
 278                  0x0000,
 279                  0x0000,
 280          };
 281          
 282          unsigned int idata AS6200_Freq;
 283          unsigned char idata AS6200_Powc;
 284          unsigned char idata AS6200_Pc;
 285          
 286          
 287          void AS6200_init(void)
 288          {
 289   1              U8      cnt;
 290   1              for(cnt = 0; cnt < 20; cnt++)
 291   1              {
 292   2                      AS6200_Write_Data(cnt, AS6200_Write_BUFF[cnt]);
 293   2              }       
 294   1      
 295   1              //Set to Stereo
 296   1              AS6200_Write_BUFF[13]|=TX_MASK_ST;
 297   1              AS6200_Write_Data(13,AS6200_Write_BUFF[13]);
 298   1      
 299   1              AS6200_Powc=10;  //Set POWC to 5.6dB
 300   1              AS6200_Write_BUFF[10] = (AS6200_Write_BUFF[10] & TX_MSK_POWC) | AS6200_Powc;
 301   1              AS6200_Write_Data(10,AS6200_Write_BUFF[10]);
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 6   

 302   1      
 303   1              AS6200_Freq = AS6200_Default_Freq;      //Set to Default Freq
 304   1              AS6200_Set_Freq(AS6200_Freq);
 305   1      
 306   1              AS6200_Powc=(unsigned char)(AS6200_Read_Data(10)&TX_MASK_POWC);   //Read Powc
 307   1              AS6200_Pc=(unsigned char)(AS6200_Read_Data(9)&TX_MASK_PC);              //Read Pc       
 308   1      }
 309          
 310          
 311          void AS6200_Write_Data(unsigned char Reg, unsigned int Reg_val)  //AS6200 send data according to Reg
 312          {
 313   1              U8      ack,addr;
 314   1      
 315   1              addr = ((Reg)<<1)|0x80;
 316   1              IIC_Start();
 317   1              ack = IIC_WriteByte(addr);
 318   1              ack |= IIC_WriteByte(Reg_val >> 8);
 319   1              ack |= IIC_WriteByte(Reg_val & 0xff);
 320   1              IIC_Stop();
 321   1      }
 322          
 323          
 324          U16 AS6200_Read_Data(unsigned char Reg) //AS6200 read data according to Reg
 325          {
 326   1              U8      addr, value_l,value_h;
 327   1              U16     temp;
 328   1      
 329   1              addr =  ((Reg)<<1)|0x81;
 330   1              IIC_Start();
 331   1              IIC_WriteByte(addr);
 332   1              value_h = IIC_ReadByte(1);
 333   1              value_l = IIC_ReadByte(1);
 334   1              IIC_Stop();
 335   1              temp = (unsigned int)(value_h<<8)+value_l;
 336   1              return temp;
 337   1              
 338   1      }
 339          
 340          
 341          void AS6200_Set_Freq(U16 frq)
 342          {  
 343   1              U8      data    rfpll_pb;
 344   1              U8      data    rfpll_sb;
 345   1              U16     data    temp;
 346   1      
 347   1              temp = frq-4;
 348   1              rfpll_sb  = temp % 15;
 349   1              rfpll_pb = (temp - rfpll_sb) / 15 - 1;
 350   1              AS6200_Write_BUFF[5] = (rfpll_pb << REGPOS_RFPLL_PB) | (AS6200_Write_BUFF[5] & TX_MSK_RFPLL_PB);
 351   1      
 352   1              AS6200_Write_BUFF[5] = ((rfpll_sb ) << REGPOS_RFPLL_SB_L) | (AS6200_Write_BUFF[5] & TX_MSK_RFPLL_SB_L);
 353   1              AS6200_Write_BUFF[6] = ((rfpll_sb ) >> REGPOS_RFPLL_SB_H) | (AS6200_Write_BUFF[6] & TX_MSK_RFPLL_SB_H);
 354   1      
 355   1              AS6200_Write_Data(5, AS6200_Write_BUFF[5]);
 356   1              AS6200_Write_Data(6, AS6200_Write_BUFF[6]);
 357   1      }
 358          
 359          
 360          void AS6200_Read_Freq(void)
 361          {
 362   1              U16     data    temp1,temp2;
 363   1              U8      data    rfpll_p,rfpll_s;
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 7   

 364   1      
 365   1              temp1 = AS6200_Read_Data(5);
 366   1              temp2 = AS6200_Read_Data(6);
 367   1              rfpll_p = (unsigned char)(temp1 >> REGPOS_RFPLL_PB);    
 368   1              rfpll_s = (unsigned char)(AS6200_Read_Data(5) >> REGPOS_RFPLL_SB_L) | ((unsigned char) (AS6200_Read_Data(
             -6)&0x0007)<<REGPOS_RFPLL_SB_H);
 369   1              AS6200_Freq = 15*(rfpll_p+1)+rfpll_s+4;
 370   1      }
 371          
 372          
 373          void IIC_Delay(unsigned int t)
 374          {
 375   1              while(0 != t)
 376   1              {       
 377   2                      t--;
 378   2              }
 379   1      }
 380          
 381          
 382          void IIC_Start()                                //IIC start command
 383          {
 384   1              IIC_SDA_High;    /*发送起始条件的数据信号*/
 385   1              IIC_Delay(IIC_Delay_Time); 
 386   1              IIC_SCL_High;             /*起始条件建立时间大于4.7us,延时*/
 387   1             
 388   1              IIC_Delay(IIC_Delay_Time); 
 389   1              IIC_SDA_Low;    /*发送起始信号*/         /* 起始条件锁定时间大于4μs*/
 390   1            
 391   1              IIC_Delay(IIC_Delay_Time);        
 392   1              IIC_SCL_Low;    /*钳住IIC总线，准备发送或接收数据 */
 393   1              IIC_Delay(IIC_Delay_Time);  
 394   1      }
 395          
 396          
 397          void IIC_Stop()                         //IIC stop command
 398          {
 399   1              IIC_SDA_Low;    /*发送结束条件的数据信号*/
 400   1                              /*发送结束条件的时钟信号*/
 401   1              IIC_Delay(IIC_Delay_Time); 
 402   1              IIC_SCL_High;   /*结束条件建立时间大于4μs*/
 403   1              IIC_Delay(IIC_Delay_Time); 
 404   1              IIC_SDA_High;   /*发送IIC总线结束信号*/
 405   1              IIC_Delay(IIC_Delay_Time); 
 406   1      }
 407          
 408          
 409          unsigned char IIC_WriteByte(unsigned char c)            //IIC send a byte data, return ack signal(0:无应答，1:有应答
             -)
 410          {
 411   1              U8      ack, i;
 412   1      
 413   1              XBYTE[0xB102]|=0x20;
 414   1              for(i = 0; i < 8; i++)
 415   1              {
 416   2                      if((c << i) & 0x80)
 417   2                              IIC_SDA_High;
 418   2                      else
 419   2                              IIC_SDA_Low;
 420   2                      IIC_Delay(IIC_Delay_Time);
 421   2                      IIC_SCL_High;
 422   2                      IIC_Delay(IIC_Delay_Time);
 423   2                      IIC_SCL_Low;
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 8   

 424   2              }
 425   1              IIC_Delay(IIC_Delay_Time);
 426   1              IIC_SDA_Set_Input;                      /*8位发送完后释放数据线，准备接收应答位*/
 427   1              IIC_Delay(IIC_Delay_Time);
 428   1              IIC_SCL_High;                           //????
 429   1              IIC_Delay(IIC_Delay_Time);
 430   1              if(IIC_SDA_Test)                         /*判断是否接收到应答信号*/
 431   1                      ack = 0;                        ////
 432   1              else
 433   1                      ack = 1;
 434   1              IIC_SCL_Low;
 435   1              IIC_Delay(IIC_Delay_Time);
 436   1              IIC_SDA_Set_Output;
 437   1              return ack;
 438   1      }
 439          
 440          
 441          unsigned char IIC_ReadByte(unsigned char ack)           //IIC read a byte data, if ack = 1 ,send ack signal, if ack
             - = 0, no send ack signal  
 442          {
 443   1              unsigned char i, bits;
 444   1              bits = 0;
 445   1              IIC_SDA_Set_Input;
 446   1              for(i = 0; i < 8; i++)
 447   1                      {
 448   2                      IIC_SCL_Low;
 449   2                      IIC_Delay(IIC_Delay_Time);
 450   2                      IIC_SCL_High;
 451   2                      IIC_Delay(IIC_Delay_Time);
 452   2                      bits <<= 1;
 453   2                      if(IIC_SDA_Test)
 454   2                              bits += 1;
 455   2                      IIC_Delay(IIC_Delay_Time);
 456   2                      }
 457   1              IIC_SCL_Low;
 458   1              IIC_Delay(IIC_Delay_Time);
 459   1              IIC_SDA_Set_Output;
 460   1              if(ack == 1)
 461   1                      IIC_SendAck(0);
 462   1              else
 463   1                      IIC_SendAck(1);
 464   1              return bits;
 465   1                      
 466   1      }
 467          
 468          
 469          void IIC_SendAck(bit k)
 470          {
 471   1              if(k == 0)
 472   1                      IIC_SDA_Low;
 473   1              else
 474   1                      IIC_SDA_High;
 475   1              IIC_Delay(IIC_Delay_Time);
 476   1              IIC_SCL_High;
 477   1              IIC_Delay(IIC_Delay_Time);
 478   1              IIC_SCL_Low;
 479   1              IIC_Delay(IIC_Delay_Time);
 480   1      }
 481          
 482          
 483          void I2C_Wait(U16 tt)
 484          {
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 9   

 485   1              while(tt>0)
 486   1              {
 487   2                      tt--;
 488   2              }
 489   1      }
 490          //========================================================================================================
             -==========
 491          //              fmtx fuction end
 492          //========================================================================================================
             -==========
 493          
 494          //==========QN8027================
 495          /////////////////////////////////////////////////////////////////////////
 496          
 497          
 498          ///////////////////////////////////8027zhanggw//////////////////////////////////////
 499          
 500          
 501          void Start(void)               
 502          { 
 503   1          IIC_Delay(1);
 504   1          IIC_SCL_High;
 505   1          IIC_Delay(1);
 506   1          IIC_SDA_High;
 507   1          IIC_Delay(1);
 508   1          IIC_SDA_Low;
 509   1          IIC_Delay(2);
 510   1          IIC_SCL_Low;
 511   1      }
 512          
 513          void Stop(void)              
 514          {
 515   1          IIC_Delay(1);
 516   1          IIC_SDA_Low;
 517   1          IIC_Delay(1);
 518   1          IIC_SCL_High;
 519   1          IIC_Delay(2);
 520   1          IIC_SDA_High;
 521   1      }
 522          
 523          void Send_ACK(U8 i) //i=0 for ACK and i=1 for Nack
 524          {
 525   1          if(i == 0)
 526   1                      IIC_SDA_Low;
 527   1              else
 528   1                      IIC_SDA_High;
 529   1          IIC_Delay(1);
 530   1          IIC_SCL_High;
 531   1          IIC_Delay(1);
 532   1          IIC_SCL_Low;
 533   1          IIC_Delay(1);
 534   1          IIC_SDA_High;
 535   1      }
 536           
 537          void Check_ACK(void)
 538          {
 539   1          IIC_SDA_Set_Input;
 540   1          IIC_Delay(1);
 541   1          IIC_SCL_High;
 542   1          qnd_i2c_timeout = (U8) Read_SDA;
 543   1          IIC_Delay(1);
 544   1          IIC_SCL_Low;
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 10  

 545   1          IIC_SDA_Set_Output;
 546   1      }
 547          
 548          void Write_Bit(U8 i)
 549          {
 550   1          IIC_Delay(1);
 551   1          if(i == 0)
 552   1                      IIC_SDA_Low;
 553   1              else
 554   1                      IIC_SDA_High;
 555   1          IIC_Delay(1);
 556   1          IIC_SCL_High;
 557   1          IIC_Delay(2);
 558   1          IIC_SCL_Low;
 559   1      }
 560          
 561          void Write_Byte(U8 Data)
 562          {
 563   1          U8 i;
 564   1          for( i = 0;i < 8;i++)
 565   1          {
 566   2              Write_Bit(Data>>7);
 567   2              Data<<=1;
 568   2          }
 569   1      }
 570          
 571          U8 Read_Byte(void)
 572          {
 573   1          U8 Data1=0x00;
 574   1          U8 j;
 575   1          IIC_SDA_Set_Input;
 576   1          for( j = 0;j < 8;j++)
 577   1          {
 578   2              IIC_Delay(1);
 579   2              IIC_SCL_High;
 580   2              Data1 = (Data1<<1) | ((U8) Read_SDA & 0x01);
 581   2              IIC_Delay(1);
 582   2                  IIC_SCL_Low;
 583   2              }
 584   1          IIC_SDA_Set_Output;
 585   1          return Data1;
 586   1      }
 587           
 588          /*********************************************************************************************************
             -***
 589          ** Name: I2C_Write_1byte                         
 590          ** Funcation:write a data to a desired            
 591          **           register through i2c bus 
 592          ** Description: Slave---------device address
 593          **              Regis_Addr----register address
 594          **********************************************************************************************************
             -***/
 595          U8 I2C_Write_1byte(U8 Slave,U8 Regis_Addr,U8 Data)
 596          {
 597   1          U8 temp;
 598   1          temp=Slave;
 599   1      
 600   1          Start();
 601   1          Write_Byte(temp);
 602   1          Check_ACK();
 603   1          if (!qnd_i2c_timeout) 
 604   1          {
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 11  

 605   2              Write_Byte(Regis_Addr);
 606   2              Check_ACK();
 607   2              if (!qnd_i2c_timeout) 
 608   2              {
 609   3                  Write_Byte(Data);
 610   3                  Check_ACK();
 611   3              }
 612   2          }
 613   1          Stop();
 614   1          return !qnd_i2c_timeout;
 615   1      }
 616          
 617          /*********************************************************************************************************
             -**
 618          ** Name: I2C_Read_1byte                          
 619          ** Function: Read a data from a desired register 
 620          **           through i2c bus 
 621          ** Description: Slave---------device address
 622          **              Regis_Addr----register address
 623          **********************************************************************************************************
             -**/
 624          U8 I2C_Read_1byte(U8 Slave,U8 Regis_Addr)
 625          { 
 626   1          U8 Data=0x00;
 627   1          U8 temp;
 628   1          temp =Slave | 0x01;
 629   1      
 630   1          Start();
 631   1          Write_Byte(Slave);
 632   1          Check_ACK();
 633   1          if (!qnd_i2c_timeout) 
 634   1          {
 635   2              Write_Byte(Regis_Addr);
 636   2              Check_ACK();
 637   2              if(!qnd_i2c_timeout) 
 638   2              {
 639   3                  //stop();
 640   3                  Start();
 641   3                  Write_Byte(temp);
 642   3                  Check_ACK();
 643   3                  if (!qnd_i2c_timeout) 
 644   3                  {
 645   4                      Data = Read_Byte();
 646   4                      Send_ACK(1);
 647   4                  }
 648   3              }
 649   2          }
 650   1          Stop();
 651   1          return Data;
 652   1      }
 653          
 654          
 655          void QN_ChipInitialization()
 656          {
 657   1              I2C_Write_1byte(I2C_DEV0_ADDRESS,0x00,0x81);// reset all registers to the default value
 658   1          QND_Delay(20);
 659   1          I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x03,0x10);
 660   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x04,0x41);//fm-vol
 661   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x00,0x41);
 662   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x00,0x01);
 663   1          QND_Delay(20);
 664   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x18,0xe4);
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 12  

 665   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x1b,0xf0);
 666   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x11,0x50);//
 667   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x01,0x7e);
 668   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x02,0xb9);
 669   1              I2C_Write_1byte(I2C_DEV0_ADDRESS, 0x00,0x22);
 670   1      }
 671          
 672          void QND_Delay(U16 ms) 
 673          {
 674   1              U16 i,k;
 675   1          for(i=0; i<3000;i++) {    
 676   2                          for(k=0; k<ms; k++) {
 677   3                      }
 678   2          }
 679   1      }
 680          /**********************************************************************
 681          int QND_Init()
 682          **********************************************************************
 683          Description: Initialize device to make it ready to have all functionality ready for use.
 684          
 685          Parameters:
 686          None
 687          Return Value:
 688          1: Device is ready to use.
 689          0: Device is not ready to serve function.
 690          **********************************************************************/
 691          BYTE QND_Init() 
 692          {    
 693   1      /*  BYTE timeout;
 694   1          BYTE openTmp,chkflag;
 695   1              timeout = 100;
 696   1              chkflag = 1;
 697   1              while(timeout--) 
 698   1              {
 699   1                      QND_Delay(100);
 700   1                  openTmp = I2C_Read_1byte(I2C_DEV0_ADDRESS, CID2);
 701   1                      openTmp &=0xf0;  //for A1 and B1
 702   1                  if(openTmp == CHIPID_QN8027)
 703   1                      {
 704   1                  timeout = 0;
 705   1                  chkflag = 0;
 706   1                  }
 707   1              }
 708   1          if(chkflag) 
 709   1              {
 710   1              return 0;
 711   1          }
 712   1         
 713   1      */
 714   1          QN_ChipInitialization();
 715   1          I2C_Write_1byte(I2C_DEV0_ADDRESS,  00,  0x01); //resume original status of chip /* 2008 06 13 */
 716   1      //    qnd_Band = BAND_FM;
 717   1          return 1;
 718   1      }
 719          
 720          
 721          /**********************************************************************
 722          void QND_TuneToCH(UINT16 ch)
 723          **********************************************************************
 724          Description:    Tune to the specified channel. Before use this function
 725          make sure the QND_SetSysMode() has been called. If system is working 
 726          on FM&TX mode,it will turn FM to ch, and start Transmit; If system is
C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 13  

 727          working on FM&RX mode,it will turn FM to ch, and start FM play.
 728          Parameters:
 729          ch
 730          Set the frequency (10kHz) to be tuned,
 731          eg: 101.30MHz will be set to 10130.
 732          Return Value:
 733              None
 734          **********************************************************************/
 735          void QND_TuneToCH(U16 ch) 
 736          {
 737   1          QNF_SetCh(ch);
 738   1      //  QND_Delay(3);
 739   1      }
 740          
 741          
 742          /**********************************************************************
 743          UINT8 QNF_SetCh(UINT16 freq)
 744          **********************************************************************
 745          Description: set specified frequency 
 746          
 747          Parameters:
 748                  freq:  specified frequency that is set
 749          Return Value:
 750                   1: set success
 751          **********************************************************************/
 752          U8 QNF_SetCh(U16 freq) 
 753          {
 754   1          // calculate ch para
 755   1          U8 tStep;
 756   1          U8 tCh;
 757   1          U16 f; 
 758   1              freq=freq*10;
 759   1              f = FREQ2CHREG(freq); 
 760   1              // set to reg: CH
 761   1              tCh = (U8) f;
 762   1              I2C_Write_1byte(I2C_DEV0_ADDRESS,  CH, tCh);            
 763   1              // set to reg: CH_STEP
 764   1              tStep = I2C_Read_1byte(I2C_DEV0_ADDRESS,  CH_STEP);
 765   1              tStep &= ~CH_CH;
 766   1              tStep |= ((U8) (f >> 8) & CH_CH);
 767   1                      tStep |= 0x20;  //设置为发射模式，寄存器00H的bit5设置为1
 768   1              I2C_Write_1byte(I2C_DEV0_ADDRESS,  CH_STEP, tStep);
 769   1      
 770   1          return 1;
 771   1      }
 772          
 773          
 774          //===========================================================
 775          //
 776          //===========================================================
 777          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1933    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     42      24
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      10
   IDATA SIZE       =      4    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.

C51 COMPILER V9.00   FM                                                                    07/10/2012 15:51:55 PAGE 14  


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
